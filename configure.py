import sys, os, string, re, commands, types

import SCons

# The following adds all SCons SConscript API to the globals of this module.
version = map(int,string.split(SCons.__version__,'.'))
if version[1] == 96 and version[2] >= 90:
    from SCons.Script import *
else:  # old style
    import SCons.Script.SConscript
    globals().update(SCons.Script.SConscript.BuildDefaultGlobals())

# CONSTANTS -- DO NOT CHANGE
context_success = 1
context_failure = 0
unix_failure = 1

# Make sure error messages stand out visually
def stderr_write(message):
    sys.stderr.write('\n  %s\n' % message)

toheader = re.compile(r'\n((?:\n[^\n]+)+)\n'                     
                      '\s*\/\*(\^|\<(?:[^>]|\>[^*]|\>\*[^/])*\>)\*\/')
kandr = re.compile(r'\s*\{?\s*$') # K&R style function definitions end with {

def header(target=None,source=None,env=None):
# generate a header file
    inp = open(str(source[0]),'r')
    text = string.join(inp.readlines(),'')
    inp.close()
    file = str(target[0])
    prefix = env.get('prefix','')
    define = prefix + string.translate(os.path.basename(file),
                                       string.maketrans('.','_'))
    out = open(file,'w')
    out.write('/* This file is automatically generated. DO NOT EDIT! */\n\n')
    out.write('#ifndef _' + define + '\n')
    out.write('#define _' + define + '\n\n')
    for extract in toheader.findall(text):
        if extract[1] == '^':
            out.write(extract[0]+'\n\n')
        else:
            function = kandr.sub('',extract[0])
            out.write(function+';\n')
            out.write('/*'+extract[1]+'*/\n\n')
    out.write('#endif\n')
    out.close()
    return 0

Header = Builder (action = Action(header,varlist=['prefix']),
                  src_suffix='.c',suffix='.h')

include = re.compile(r'#include\s*\"([^\"]+)\.h\"')

def depends(env,list,file):
    filename = string.replace(env.File(file+'.c').abspath,'build/','',1)
    fd = open(filename,'r')
    for line in fd.readlines():
        for inc in include.findall(line):
            if inc not in list and inc[0] != '_':
                list.append(inc)
                depends(env,list,inc)
    fd.close()


include90 = re.compile(r'use\s+(\S+)')

def depends90(env,list,file):
    filename = string.replace(env.File(file+'.f90').abspath,'build/','',1)
    fd = open(filename,'r')
    for line in fd.readlines():
        for inc in include90.findall(line):
            if inc not in list and inc != 'rsf':
                list.append(inc)
                depends90(env,list,inc)
    fd.close()

def included(node,env,path):
    file = os.path.basename(str(node))
    file = re.sub('\.[^\.]+$','',file)
    contents = node.get_contents()
    includes = include.findall(contents)
    if file in includes:
        includes.remove(file)
    return map(lambda x: x + '.h',includes)

Include = Scanner(name='Include',function=included,skeys=['.c'])

plat = {'OS': 'unknown',
        'distro': 'unknown',
        'arch': 'unknown'}

# The functions called inside check_all
# are found further down, in the order they are called
# FDNSI = Failure Does Not Stop Installation
def check_all(context):
    
    identify_platform(context)
    cc  (context)
    ar  (context)
    libs(context)
    c99 (context) # FDNSI
    x11 (context) # FDNSI
    ppm (context) # FDNSI
    jpeg(context) # FDNSI
    mpi (context) # FDNSI
    api = api_options(context)
    if 'c++' in api:
        cxx(context)
    if 'f77' in api:
        f77(context)
    if 'f90' in api:
        f90(context)
    if 'matlab' in api:
        matlab(context)
    if 'python' in api:
        python(context)

def identify_platform(context):
    global plat
    context.Message("checking platform ... ")
    # Hey everybody, add a test for your platform here!

    # Check for OS or Unix environment
    if sys.platform[:5] == 'linux':
        plat['OS'] = 'linux'
    elif sys.platform[:5] == 'sunos':
        plat['OS'] = 'sunos' # SunOS
    elif sys.platform[:6] == 'darwin':
        plat['OS'] = 'darwin' # Mac OS X
    elif sys.platform[:6] == 'cygwin':
        plat['OS'] = 'cygwin'
    elif sys.platform[:7] == 'interix':
        plat['OS'] = 'interix' # Microsoft Windows Services for UNIX
    else:
        plat['OS'] = sys.platform

    # Check for distributions / OS versions
    try:
        from platform import architecture, uname
        plat['arch'] = architecture()[0]
        name = uname()[2].split('.')[-1]
        if plat['OS'] == 'linux':
            if name[:2] == 'fc':
                plat['distro'] = 'fc' # Fedora Core
            elif name[:2] == 'EL':
                plat['distro'] = 'EL' # Redhat Enterprise
            elif name[-7:] == 'generic':
                plat['distro'] = 'generic' # Ubuntu
        elif plat['OS'] == 'sunos':
            if name[:2] == '10':
                plat['distro'] = '10' # Solaris 10
        del architecture, uname
    except: # "platform" not installed. Python < 2.3
        pass # For each OS with Python < 2.3, should use specific
             # commands through os.system to find distro/version
    context.Result('%(OS)s [%(distro)s]' % plat)

# A C compiler is needed by most Madagascar programs
# Failing this test stops the installation.
def cc(context):
    context.Message("checking for C compiler ... ")
    CC = context.env.get('CC',WhereIs('gcc'))
    if CC:
        context.Result(CC)
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: gcc.')
        sys.exit(unix_failure)
    text = '''
    int main(int argc,char* argv[]) {
    return 0;
    }\n'''

    context.Message("checking if %s works ... " % CC)
    res = context.TryLink(text,'.c')
    context.Result(res)
    if not res:
        sys.exit(unix_failure)
    if CC[-3:]=='gcc':
        oldflag = context.env.get('CCFLAGS')
        for flag in ('-std=gnu99 -Wall -pedantic',
                     '-std=gnu9x -Wall -pedantic',
                     '-Wall -pedantic'):
            context.Message("checking if gcc accepts '%s' ... " % flag)
            context.env['CCFLAGS'] = oldflag + ' ' + flag
            res = context.TryCompile(text,'.c')
            context.Result(res)
            if res:
                break
        if not res:
            context.env['CCFLAGS'] = oldflag
        # large file support
        (status,lfs) = commands.getstatusoutput('getconf LFS_CFLAGS')
        if not status:
            oldflag = context.env.get('CCFLAGS')
            context.Message("checking if gcc accepts '%s' ... " % lfs)
            context.env['CCFLAGS'] = oldflag + ' ' + lfs
            res = context.TryCompile(text,'.c')
            context.Result(res)
            if not res:
                context.env['CCFLAGS'] = oldflag
	# if Mac OS X and fink installed, update CPPPATH and LIBPATH
	if plat['OS'] == 'darwin' and os.path.isdir('/sw'):
	    context.env['CPPPATH'] = context.env.get('CPPPATH',[]) + ['/sw/include',]
	    context.env['LIBPATH'] = context.env.get('LIBPATH',[]) + ['/sw/lib',]

    elif plat['OS'] == 'sunos':
        context.env['CCFLAGS'] = string.replace(context.env.get('CCFLAGS',''),
                                                '-O2','-xO2')

# Used for building libraries.
def ar(context):
    context.Message("checking for ar ... ")
    AR = context.env.get('AR',WhereIs('ar'))
    if AR:
        context.Result(AR)
        context.env['AR'] = AR
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: binutils.')
        sys.exit(unix_failure)


# Failing this check stops the installation.
def libs(context):
    context.Message("checking for RPC libraries ... ")
    LIBS = context.env.get('LIBS','m')
    if type(LIBS) is not types.ListType:
        LIBS = string.split(LIBS)
    if plat['OS'] == 'sunos':
        LIBS.append('nsl')
    elif plat['OS'] == 'cygwin':
        LIBS.append('rpc')
    elif plat['OS'] == 'darwin':
        LIBS.append('mx')
    elif plat['OS'] == 'interix':
        LIBS.append('rpclib')
    text = '''
    #include <rpc/types.h>
    #include <rpc/xdr.h>
    int main(int argc,char* argv[]) {
    return 0;
    }\n'''

    res = context.TryLink(text,'.c')
    if res:
        context.Result(str(LIBS))
        context.env['LIBS'] = LIBS
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: glibc-headers.')
        sys.exit(unix_failure)


# Complex number support according to ISO C99 standard
def c99(context):
    context.Message("checking complex support ... ")
    text = '''
    #include <complex.h>
    #include <math.h>
    int main(int argc,char* argv[]) {
    float complex c;
    float f;
    f = cabsf(ccosf(c));
    return (int) f;
    }\n'''

    res = context.TryLink(text,'.c')
    if res:
        context.Result(res)
    else:
        context.env['CCFLAGS'] = context.env.get('CCFLAGS','')+' -DNO_COMPLEX'
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Package needed for ISO C99 support: glibc-headers')


# The two lists below only used in the x11 check
xinc = [
    '/usr/X11/include',
    '/usr/X11R6/include',
    '/usr/X11R5/include',
    '/usr/X11R4/include',
    '/usr/include/X11',
    '/usr/include/X11R6',
    '/usr/include/X11R5',
    '/usr/include/X11R4',
    '/usr/local/X11/include',
    '/usr/local/X11R6/include',
    '/usr/local/X11R5/include',
    '/usr/local/X11R4/include',
    '/usr/local/include/X11',
    '/usr/local/include/X11R6',
    '/usr/local/include/X11R5',
    '/usr/local/include/X11R4',
    '/usr/X386/include',
    '/usr/x386/include',
    '/usr/XFree86/include/X11',
    '/usr/include',
    '/usr/local/include',
    '/usr/unsupported/include',
    '/usr/athena/include',
    '/usr/local/x11r5/include',
    '/usr/lpp/Xamples/include',
    '/usr/openwin/include',
    '/usr/openwin/share/include'
    ]

xlib = [
    '/usr/X11/lib',
    '/usr/X11R6/lib64',
    '/usr/X11R6/lib',
    '/usr/X11R5/lib',
    '/usr/X11R4/lib',
    '/usr/lib/X11',
    '/usr/lib/X11R6',
    '/usr/lib/X11R5',
    '/usr/lib/X11R4',
    '/usr/local/X11/lib',
    '/usr/local/X11R6/lib',
    '/usr/local/X11R5/lib',
    '/usr/local/X11R4/lib',
    '/usr/local/lib/X11',
    '/usr/local/lib/X11R6',
    '/usr/local/lib/X11R5',
    '/usr/local/lib/X11R4',
    '/usr/X386/lib',
    '/usr/x386/lib',
    '/usr/XFree86/lib/X11',
    '/usr/lib',
    '/usr/local/lib',
    '/usr/unsupported/lib',
    '/usr/athena/lib',
    '/usr/local/x11r5/lib',
    '/usr/lpp/Xamples/lib',
    '/lib/usr/lib/X11',
    '/usr/openwin/lib',
    '/usr/openwin/share/lib'
    ]

# If this check is failed and you do not have SEPlib installed,
# you will not be able to display .vpl images
def x11(context):
    text = '''
    #include <X11/Intrinsic.h>
    #include <X11/Xaw/Label.h>
    int main(int argc,char* argv[]) {
    return 0;
    }\n'''

    context.Message("checking for X11 headers ... ")
    INC = context.env.get('XINC','')
    if type(INC) is not types.ListType:
        INC = string.split(INC)

    oldpath = context.env.get('CPPPATH',[])

    res = None
    for path in filter(lambda x:
                       os.path.isfile(os.path.join(x,'X11/Xaw/Label.h')),
                       INC+xinc):
        context.env['CPPPATH'] = oldpath + [path,] 
        res = context.TryCompile(text,'.c')

        if res:
            context.Result(path)
            context.env['XINC'] = [path,]
            break

    if not res:
        context.Result(context_failure)
        stderr_write('xtpen (for displaying .vpl images) will not be built.')
        if plat['distro'] == 'fc':
            stderr_write('Package needed for xtpen: libXaw-devel.')
        context.env['XINC'] = None
        return

    context.Message("checking for X11 libraries ... ")
    LIB = context.env.get('XLIBPATH','')
    if type(LIB) is not types.ListType:
        LIB = string.split(LIB)

    oldlibpath = context.env.get('LIBPATH',[])
    oldlibs = context.env.get('LIBS',[])

    XLIBS = context.env.get('XLIBS')
    if XLIBS:
        if type(XLIBS) is not types.ListType:
            XLIBS = string.split(XLIBS)
    else:
        if  plat['OS'] == 'interix':
            XLIBS =  ['Xaw','Xt','Xmu','X11','Xext','SM','ICE']
        elif plat['OS'] == 'linux':
            XLIBS = ['Xaw','Xt']
        else:
            XLIBS = ['Xaw','Xt','X11']

    res = None
    for path in filter(os.path.isdir,LIB+xlib):
        context.env['LIBPATH'] = oldlibpath + [path,] 
        res = context.TryLink(text,'.c')

        if res:
            context.Result(path)
            context.env['XLIBPATH'] = [path,]
            context.env['XLIBS'] = XLIBS
            break
    if not res:
        context.Result(context_failure)
        context.env['XLIBPATH'] = None

    context.env['CPPPATH'] = oldpath
    context.env['LIBPATH'] = oldlibpath
    context.env['LIBS'] = oldlibs

def ppm(context):
    context.Message("checking for ppm ... ")
    LIBS = context.env.get('LIBS','m')
    if type(LIBS) is not types.ListType:
        LIBS = string.split(LIBS)
    text = '''
    #include <ppm.h>
    int main(int argc,char* argv[]) {
    return 0;
    }\n'''
    for ppm in [context.env.get('PPM','netpbm'),'netpbm.10']:
	LIBS.append(ppm)
	res = context.TryLink(text,'.c')
	
	if res:
	    context.Result(res)
	    context.env['PPM'] = ppm
	    break
	else:
	    LIBS.pop()

    if not res:
        context.Result(context_failure)
        stderr_write('ppmpen, vplot2gif, vplot2avi will not be built.')
        if plat['distro'] == 'fc':
            stderr_write('Package needed: netpbm-devel')
        context.env['PPM'] = None

#    LIBS.pop()

# If this test is failed, no writing to jpeg files
def jpeg(context):
    context.Message("checking for jpeg ... ")
    LIBS = context.env.get('LIBS','m')
    if type(LIBS) is not types.ListType:
        LIBS = string.split(LIBS)
    jpeg = context.env.get('JPEG','jpeg')
    LIBS.append(jpeg)
    text = '''
    #include <stdio.h>
    #include <jpeglib.h>
    int main(int argc,char* argv[]) {
    return 0;
    }\n'''

    res = context.TryLink(text,'.c')
    if res:
        context.Result(res)
        context.env['JPEG'] = jpeg
    else:
        context.Result(context_failure)
        context.env['JPEG'] = None
        stderr_write('sfbyte2jpg will not be built.')
        if plat['distro'] == 'fc':
            stderr_write('For sfbyte2jpg, install package libjpeg-devel.')

    LIBS.pop()

# If this test is failed, it is unknown what capabilities are lost
def mpi(context):
    context.Message("checking for MPI ... ")
    mpicc = WhereIs('mpicc')
    if mpicc:
        context.Message("checking if MPI works ... ")
        # Try linking with mpicc instead of cc
        text = '''
        #include <mpi.h>
        int main(int argc,char* argv[]) {
        MPI_Init(&argc,&argv);
        MPI_Finalize();
        }\n'''
        cc = context.env.get('CC')
        context.env['CC'] = mpicc
        res = context.TryLink(text,'.c')
        context.env['CC'] = cc
    else: # mpicc not found
        context.Result(context_failure)
        res = None
    if res:
        context.Result(res)
        context.env['MPICC'] = mpicc
    else:
        context.Result(context_failure)
        context.env['MPICC'] = None
        if plat['distro'] == 'fc':
            stderr_write('For MPI, install: openmpi, openmpi-devel, openmpi-libs.')


def api_options(context):
    context.Message("checking API options ... ")
    api = string.split(string.lower(context.env.get('API','')),',')
    valid_api_options = ['','c++', 'fortran', 'f77', 'fortran-90',
                         'f90', 'python', 'matlab']

    for option in api:
        if not option in valid_api_options:
            api.remove(option)

    # Make tests for fortrans in API easy
    for i in range(len(api)):
        if api[i] == 'fortran':
            api[i] = 'f77'
        elif api[i] == 'fortran-90':
            api[i] = 'f90'

    # Eliminate duplicates if user was redundant
    try: # sets module was introduced in Py 2.3
        import sets
        api = list(sets.Set(api))
        del sets
    except:
        pass # Not a big deal if this is not done

    # Readable output. For non-pythonistas,
    # [''] represents an emoticon, not "empty list"
    if api == ['']:
        context.Result('none')
    else:
        context.Result(str(api))
    context.env['API'] = api
    return api

# For the C++ API
def cxx(context):
    context.Message("checking for C++ compiler ... ")
    CXX = context.env.get('CXX')
    if CXX:
        context.Result(CXX)
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: gcc-c++')
        sys.exit(unix_failure)
    context.Message("checking if %s works ... " % CXX)
    text = '''
    #include <valarray>
    int main(int argc,char* argv[]) {
    return 0;
    }\n'''
    res = context.TryLink(text,'.cc')
    context.Result(res)
    if not res:
        del context.env['CXX']
        sys.exit(unix_failure)
    if CXX == 'g++':
        oldflag = context.env.get('CXXFLAGS')
        for flag in ['-Wall -pedantic']:
            context.Message("checking if g++ accepts '%s' ... " % flag)
            context.env['CXXFLAGS'] = oldflag + ' ' + flag
            res = context.TryCompile(text,'.cc')
            context.Result(res)
            if res:
                break
        if not res:
            context.env['CXXFLAGS'] = oldflag


# Used in checks for both f77 and f90
fortran = {'g77':'f2cFortran',
           'gfortran':'NAGf90Fortran', # used to be f2cFortran
           'f2c':'f2cFortran'}


def f77(context):
    context.Message("checking for F77 compiler ... ")
    F77 = context.env.get('F77')
    if not F77:
        compilers = ['g77','f77','f90','f95','xlf90','pgf90',
                     'ifort','ifc','pghpf']
        F77 = context.env.Detect(compilers)
        if not F77:
            for comp in compilers:
                F77 = WhereIs(comp)
                if F77:
                    break
        context.env['F77'] = F77
    if F77:
        context.Result(F77)
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: gcc-gfortran')
        sys.exit(unix_failure)
    if os.path.basename(F77) == 'ifc' or os.path.basename(F77) == 'ifort':
        intel(context)
        context.env.Append(F77FLAGS=' -Vaxlib')
    text = '''      program Test
      stop
      end
      '''
    context.Message("checking if %s works ... " % F77)
    oldlink = context.env.get('LINK')
    context.env['LINK'] = F77
    res = context.TryLink(text,'.f')
    context.env['LINK'] = oldlink
    context.Result(res)
    if not res:
        del context.env['F77']
        sys.exit(unix_failure)
    cfortran = fortran.get(os.path.basename(F77),'NAGf90Fortran')
    context.env['CFORTRAN'] = cfortran 
    context.Message("checking %s type for cfortran.h ... " % F77)
    context.Result(cfortran)

def f90(context):
    context.Message("checking for F90 compiler ... ")
    F90 = context.env.get('F90')
    if not F90:
        compilers = ['gfortran','f90','f95','xlf90','pgf90',
                     'ifort','ifc','pghpf']
        F90 = context.env.Detect(compilers)
        if not F90:
            for comp in compilers:
                F90 = WhereIs(comp)
                if F90:
                    break
        context.env['F90'] = F90
    if F90:
        context.Result(F90)
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: gcc-gfortran')
        sys.exit(unix_failure)
    if os.path.basename(F90) == 'ifc' or os.path.basename(F90) == 'ifort':
        intel(context)
        context.env.Append(F90FLAGS=' -Vaxlib')
    main = '''program Test
    end program Test
    '''
    module = '''module testf90
    end module testf90
    '''
    context.Message("checking if %s works ... " % F90)
    oldlink = context.env.get('LINK')
    context.env['LINK'] = F90
    res1 = context.TryCompile(module,'.f90')
    res2 = context.TryLink(main,'.f90')
    context.env['LINK'] = oldlink
    context.Result(res1 and res2)
    if not res1 or not res2:
        del context.env['F90']
        sys.exit(unix_failure)
    base = os.path.basename(F90)
    context.Message("checking %s type for cfortran.h ... " % base)
    cfortran = fortran.get(base,'NAGf90Fortran')
    context.env['CFORTRAN90'] = cfortran
    context.Result(cfortran)
    context.Message("checking F90 module extension ... ")
    f90module = re.compile(r'(?:testf90|TESTF90)(\.\w+)$')
    suffix = ''
    for file in os.listdir(os.getcwd()):
        gotit = f90module.match(file)
        if gotit:
            suffix = gotit.group(1)
            os.remove(file)
            break
    context.env['F90MODSUFFIX'] = suffix
    context.Result(suffix)


def matlab(context):
    context.Message("checking for Matlab ... ")
    matlab = WhereIs('matlab')
    if matlab:
        context.Result(matlab)
        RSFROOT_lib = os.path.join(context.env.get('RSFROOT'),'lib')
        MATLABPATH = os.environ.get('MATLABPATH')
        if MATLABPATH:
            MATLABPATH += ':' + RSFROOT_lib
        else:
            MATLABPATH = RSFROOT_lib
        context.env['MATLAB'] = 'MATLABPATH=%s %s -nosplash -nojvm -nodesktop' %(MATLABPATH,matlab)
    else:
        context.Result(context_failure)
        stderr_write('Please install Matlab.')
        context.env['MATLAB'] = None
        sys.exit(unix_failure)

    context.Message("checking for mex ... ")
    mex = WhereIs('mex')
    if mex:
        context.Result(mex)
        context.env['MEX'] = mex
    else:
        context.Result(context_failure)
        stderr_write('Please install mex.')
        context.env['MEX'] = None
        sys.exit(unix_failure)

    # See http://www.mathworks.com/access/helpdesk/help/techdoc/ref/mex.html
    if plat['OS'] == 'linux':
        if plat['arch'] == '32bit':
            suffix = 'glx'
        else:
            suffix = 'a64'
    elif plat['OS'] == 'sunos':
        suffix = 'sol'
    elif plat['OS'] == 'darwin':
        suffix = 'mac'
    else:
        suffix == 'glx'
    context.env['MEXSUFFIX'] = '.mex' + suffix

def python(context):
    context.Message("checking for SWIG ... ")
    if 'swig' in Environment().get('TOOLS'):
        context.Result( WhereIs('swig') )
    else:
        context.Result(context_failure)
        if plat['distro'] == 'fc':
            stderr_write('Needed package: swig')
        else:
             stderr_write('Please install SWIG.')
        sys.exit(unix_failure)

    context.Message("checking for numpy ... ")
    try:
        import numpy
        context.Result(context_success)
	context.env['PYMODULES'] = ['numpy']
    except:
        context.Result(context_failure)
        context.Message("checking for numarray ... ")
        try:
            import numarray
            context.Result(context_success)
            stderr_write('numarray development has stopped; plan to migrate to numpy')
	    context.env['PYMODULES'] = ['numarray']
        except:
            context.Result(context_failure)
            if plat['distro'] == 'fc':
                stderr_write('Needed package: numpy')
            else:
                stderr_write('Please install numpy.')
            sys.exit(unix_failure)

    context.Message("checking for scipy ... ")
    try:
        import scipy
        context.Result(context_success)
	context.env.Append(PYMODULES='scipy')
    except:
        context.Result(context_failure)

    context.Message("checking for pyct ... ")
    try:
        import pyct
        context.Result(context_success)
	context.env.Append(PYMODULES='pyct')
    except:
        context.Result(context_failure)

def intel(context):
    '''Trying to fix weird intel setup.'''
    libdirs = string.split(os.environ.get('LD_LIBRARY_PATH',''),':')
    libs = filter (lambda x: re.search('intel',x) and os.path.isdir(x),
                   libdirs)
    context.env.Append(ENV={'LD_LIBRARY_PATH':string.join(libs,':')})
    for key in ('INTEL_FLEXLM_LICENSE','INTEL_LICENSE_FILE','IA32ROOT'):
        license = os.environ.get(key)
        if license:
            context.env.Append(ENV={key:license})

def options(opts):
    opts.Add('ENV','SCons environment')
    opts.Add('AR','Static library archiver')
    opts.Add('JPEG','The libjpeg library')
    opts.Add('PPM','The netpbm library')
    opts.Add('CC','The C compiler')
    opts.Add('CCFLAGS','General options that are passed to the C compiler',
             '-O2')
    opts.Add('CPPPATH',
             'The list of directories that the C preprocessor will search')
    opts.Add('LIBPATH',
             'The list of directories that will be searched for libraries')
    opts.Add('LIBS',
             'The list of libraries that will be linked with executables')
    opts.Add('XLIBPATH','Location of X11 libraries')
    opts.Add('XLIBS','X11 libraries')
    opts.Add('XINC','Location of X11 headers')
    opts.Add('PROGPREFIX','The prefix used for executable file names','sf')
    opts.Add('API','Support for additional languages. Possible values: c++, fortran or f77, fortran-90 or f90, matlab, python')
    opts.Add('CXX','The C++ compiler')
    opts.Add('CXXFLAGS','General options that are passed to the C++ compiler',
             '-O2')
    opts.Add('F77','The Fortran-77 compiler')
    opts.Add('F77FLAGS','General options that are passed to the F77 compiler',
             '-O2')
    opts.Add('CFORTRAN','Type of the Fortran-77 compiler (for cfortran.h)')
    opts.Add('F90','The Fortran-90 compiler')
    opts.Add('F90FLAGS','General options that are passed to the F90 compiler',
             '-O2')
    opts.Add('CFORTRAN90','Type of the Fortran-90 compiler (for cfortran.h)')
    opts.Add('F90MODSUFFIX','Suffix of Fortran-90 module interface files')
    opts.Add('MEXSUFFIX','Suffix for mex files')
    opts.Add('MEX','Mex cmd')
    opts.Add('MATLAB','Matlab program')
    opts.Add('PYMODULES','List of Python modules available')

local_include = re.compile(r'\s*\#include\s*\"([^\"]+)')

def includes(list,file):
    global local_include
    fd = open(file,'r')
    for line in fd.readlines():
         match = local_include.match(line)            
         if match:
             other = os.path.join(os.path.dirname(file),match.group(1))
             if not other in list:
                 includes(list,other)
    list.append(file)
    fd.close()

def merge(target=None,source=None,env=None):
    global local_include
    sources = map(str,source)
    incs = []
    for src in sources:
        if not src in incs:
            includes(incs,src)
    out = open(str(target[0]),'w')
    for src in incs:
        inp = open(src,'r')
        for line in inp.readlines():
            if not local_include.match(line):
                out.write(line)
        inp.close()
    out.close()
    return 0

docmerge = '''echo "import rsfdoc" > $TARGET
echo "" >> $TARGET
cat $SOURCES >> $TARGET'''

def docextra(docmerge,source,copy):
    return docmerge + '''
    echo rsfdoc.progs[\\'%s\\']=%s >> $TARGET''' % (copy,source)

def placeholder(target=None,source=None,env=None):
    filename = str(target[0])
    out = open(filename,'w')
    var = env.get('var')
    out.write('#!/usr/bin/env python\n')
    out.write('import sys\n\n')
    out.write('sys.stderr.write(\'\'\'\n%s is not installed.\n')
    out.write('Check $RSFROOT/lib/rsfconfig.py for ' + var)
    out.write('\nand reinstall if necessary.')
    package = env.get('package')
    if package:
        out.write('\nPossible missing packages: ' + package)
    out.write('\n\'\'\' % sys.argv[0])\nsys.exit(1)\n')
    out.close()
    os.chmod(filename,0775)
    return 0

Place = Builder (action = Action(placeholder,varlist=['var','package']))

#	$Id$
