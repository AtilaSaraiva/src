#include "traceio.h"

#define VERBOSE

/* axis indices throughout: 0=z, 1=x, 2=y */

/** helper function to determine whether an index tuple is within rarray */
int ingrid(int ndim, IPNT n, IPNT gs, IPNT itr) {
  int ret=0;
  if (((ndim==1) &&
       (itr[0]>gs[0]-1)     &&
       (itr[0]<gs[0]+n[0])) ||
      ((ndim==2) &&
       (itr[0]>gs[0]-1)     &&
       (itr[0]<gs[0]+n[0])  &&
       (itr[1]>gs[1]-1)     &&
       (itr[1]<gs[1]+n[1])) ||
      ((ndim==3) &&
       (itr[0]>gs[0]-1)     &&
       (itr[0]<gs[0]+n[0])  &&
       (itr[1]>gs[1]-1)     &&
       (itr[1]<gs[1]+n[1])  &&
       (itr[2]>gs[2]-1)     &&
       (itr[2]<gs[2]+n[2]))) ret=1;
  return ret;
}

/** helper function to determine whether a coord tuple is within grid */
/*int ringrid(int ndim, IPNT n, RPNT d, RPNT o, RPNT x,FILE * stream) {*/
int ringrid(int ndim, IPNT n, RPNT d, RPNT o, RPNT x) {
  int ret=0;
  RPNT e;
  int i;

  for (i=0;i<RARR_MAX_NDIM;i++) e[i]=o[i]+(n[i]-1)*d[i];

  if (((ndim==1) &&
       (x[0]>=o[0])     &&
       (x[0]<=e[0])) ||
      ((ndim==2) &&
       (x[0]>=o[0])     &&
       (x[0]<=e[0])  &&
       (x[1]>=o[1])     &&
       (x[1]<=e[1])) ||
      ((ndim==3) &&
       (x[0]>=o[0])     &&
       (x[0]<=e[0])  &&
       (x[1]>=o[1])     &&
       (x[1]<=e[1])  &&
       (x[2]>=o[2])     &&
       (x[2]<=e[2]))) ret=1;
  
  /*
  fprintf(stream,"x=[%e %e] ",x[0],x[1]);
  fprintf(stream,"o=[%e %e] ",o[0],o[1]);
  fprintf(stream,"e=[%e %e] ",e[0],e[1]);
  fprintf(stream,"ringrid=%d\n",ret);
  */      

  return ret;
}

#ifdef IWAVE_USE_MPI 

/** Courtesy of Bee Bednar: light modification of his Build_MPI_SegY_tr.c 
    15.01.09: include file offset as first word, stored as off_t. */

void buildMPI_OFFSEGY(MPI_Datatype * ptr, int ns) {

  int i;
  const int     nblks = 11;
  int           lengs[nblks];
  MPI_Datatype  types[nblks];
  MPI_Aint      disps[nblks];
  size_t        sizes[nblks];
  
  lengs[0]=1;  types[0]=MPI_LONG_LONG;   sizes[0]=sizeof(off_t);
  lengs[1]=7;  types[1]=MPI_INT;    sizes[1]=sizeof(int);
  lengs[2]=4;  types[2]=MPI_SHORT;  sizes[2]=sizeof(short);
  lengs[3]=8;  types[3]=MPI_INT;    sizes[3]=sizeof(int);
  lengs[4]=2;  types[4]=MPI_SHORT;  sizes[4]=sizeof(short);
  lengs[5]=4;  types[5]=MPI_INT;    sizes[5]=sizeof(int);
  lengs[6]=46; types[6]=MPI_SHORT;  sizes[6]=sizeof(short);
  lengs[7]=6;  types[7]=MPI_FLOAT;  sizes[7]=sizeof(float);
  lengs[8]=1;  types[8]=MPI_INT;    sizes[8]=sizeof(int);
  lengs[9]=16; types[9]=MPI_SHORT;  sizes[9]=sizeof(short);
  lengs[10]=ns; types[10]=MPI_FLOAT;  sizes[10]=sizeof(float);

  disps[0]=0;
  for (i=1;i<nblks;i++) 
    disps[i]=disps[i-1]+lengs[i-1]*sizes[i-1];
  /* deprecated */
  MPI_Type_struct(nblks,lengs,disps,types,ptr); 
  /* supposedly more up-to-date */
  /*  MPI_Type_create_struct(nblks,lengs,disps,types,ptr); */
  MPI_Type_commit(ptr);

}

#endif

/* compute group index, set return value if irec >= last index
   for this group, else increment irec. Note - only for group 
   root 
*/

int calc_group(int * ng, int * ig, 
	       int * first, int * last, 
	       int rkw, int szw, int sz, 
	       int nrec, FILE * stream) {
  int err=0;
  div_t res;
  int i;
  int sg;
  
  /* compute number of groups */
  res=div(szw,sz);
  *ng=res.quot;
  if (res.rem) {
    fprintf(stream,"Error: calc_group\n");
    fprintf(stream,"world size %d not multiple of group size %d\n",szw,sz);
    err=E_OTHER;
  }
  if (!err) {
    res=div(rkw,sz);
    *ig=res.quot;
    res=div(nrec,*ng);
    /* size of all groups except possibly last: res.quot+1 */
    sg=res.quot;
    if (*ig<res.rem) sg++;
    *first=0;
    for (i=0;i<res.rem;i++) *first+=res.quot+1;
    for (i=res.rem;i<*ig;i++) *first+=res.quot;
    *last  = iwave_min(nrec-1,*first+sg-1);
  }
  return err;
}

int traceserver_init(FILE ** fpin, char * fin,
		     FILE ** fpout, char * fout,
		     int * irec, int * xrec, 
		     int * nrec, 
		     int * ntr, off_t * recoff,
#ifdef IWAVE_USE_MPI
		     MPI_Datatype * p,
#endif
		     float tol,
		     FILE * stream) {
  int ir;
  Value val;
  float scalco;
  float scalel;
  float sz,szp;
  float sx,sxp;
  float sy,syp;
  float ds;
  segy tr;

  short ns;
  int ins;
  int err=0;

  int first=0;

#ifdef IWAVE_USE_MPI
  int rkw;
  int rkl;
  int szw;
  int szl;
  int ng;
  int ig;
  int last;
#endif

#ifdef IWAVE_USE_MPI
  MPI_Comm_rank(MPI_COMM_WORLD,&rkw);
  rkl=retreiveRank();
  MPI_Comm_size(MPI_COMM_WORLD,&szw);
  szl=retreiveSize();
  if (rkl==0) {
#endif

    *fpin=NULL;
    *fpout=NULL;

    /* open files on i/o process of each group */
    /* input file must exist - acts as model for output */
    if (!(*fpin=fopen(fin,"r"))) {
      fprintf(stream,"Error: traceserver_init\n");
      fprintf(stream,"failed to open input file\n");
      err=E_FILE;
    }
    /* output file may or may not exist. If it does, then either it has the
       same length as the input file, or it is closed and reopened with the 
       "w" flag, in particular truncated. In the latter case the input is 
       copied onto the output, to create a file of the same length. We also 
       enable reading of the output file, as this may be necessary to accumulate
       output traces over subdomain boundaries.
    */
    if (!err && !(*fpout=fopen(fout,"r+"))) { 
      if (!err && !(*fpout=fopen(fout,"w+"))) {
	fprintf(stream,"Error: traceserver_init\n");
	fprintf(stream,"failed to open output file\n");
	err=E_FILE;
      }
    }
    if (err) {
      fprintf(stream,"Error: traceserver_init\n");
      fprintf(stream,"failed to open output file\n");
      err=E_FILE;
    }      
#ifdef IWAVE_USE_MPI
  }

  /* on root process of COMM_WORLD, read input file to determine record
     info. If necessary also copy traces to output file.*/
  if (!err && rkw==0) {
    /* in this case, local rank must also be zero (check!), and 
       thus files open in this process */
    if (rkl!=0) {
      fprintf(stream,"Error: traceserver_init\n");
      fprintf(stream,"world root must be root in its group\n");
      fprintf(stream,"world rank = %d, group rank = %d\n",rkw,rkl);
      err=E_OTHER;
    }

    /* if error flag has been set on root, broadcast and leave */

    if (!err) {
#endif
      /* read first trace */
      ir=0;
      *nrec=0;
      recoff[ir]=0;

      if (fgettr(*fpin,&tr)) {
	/* at least one record, at least one trace in it */
	(*nrec)++;
	ntr[ir]++;

	/* record ns for first trace, both as short and as int.*/
	ns=tr.ns;
	ins=tr.ns;

	/* tentative begin of next rec */
	recoff[ir+1]=ftello(*fpin);

	/* read scale information */
	gethdval(&tr,"scalco",&val);
	scalco = vtof(hdtype("scalco"),val);
	gethdval(&tr,"scalel",&val);
	scalel = vtof(hdtype("scalel"),val);
	
	/* read source position */
	gethdval(&tr,"sx",&val);
	sxp = vtof(hdtype("sx"),val);
	if (scalco > 0) { sxp *=  scalco; }
	if (scalco < 0) { sxp /= -scalco; }
	
	gethdval(&tr,"sy",&val);
	syp = vtof(hdtype("sy"),val);
	if (scalco > 0) { syp *=  scalco; }
	if (scalco < 0) { syp /= -scalco; }
	
	gethdval(&tr,"selev",&val);
	szp = vtof(hdtype("selev"),val);
	if (scalel > 0) { szp *=  scalel; }
	if (scalel < 0) { szp /= -scalel; }
	szp=-szp;

	/* set tracr, write trace to output file */
	tr.tracr=ntr[ir];
	fputtr(*fpout,&tr);

	/* trace reading loop */
	while (fgettr(*fpin,&tr)) {

	  /* compare ns with first trace - MUST BE SAME */
	  if (tr.ns != ns) err=E_OTHER;

	  /* extract source position */
	  
	  /* read scale information */
	  gethdval(&tr,"scalco",&val);
	  scalco = vtof(hdtype("scalco"),val);
	  gethdval(&tr,"scalel",&val);
	  scalel = vtof(hdtype("scalel"),val);
	  
	  /* read source position */
	  gethdval(&tr,"sx",&val);
	  sx = vtof(hdtype("sx"),val);
	  if (scalco > 0) { sx *=  scalco; }
	  if (scalco < 0) { sx /= -scalco; }
	  
	  gethdval(&tr,"sy",&val);
	  sy = vtof(hdtype("sy"),val);
	  if (scalco > 0) { sy *=  scalco; }
	  if (scalco < 0) { sy /= -scalco; }
	  
	  gethdval(&tr,"selev",&val);
	  sz = vtof(hdtype("selev"),val);
	  if (scalel > 0) { sz *=  scalel; }
	  if (scalel < 0) { sz /= -scalel; }
	  sz=-sz;

	  /* compare to previous */
	  ds = fmaxf(fabsf(sz-szp),fmaxf(fabsf(sx-sxp),fabsf(sy-syp)));
	  if (ds<tol) {
	    /* found another trace in current record */
	    ntr[ir]++;
	    recoff[ir+1]=ftello(*fpin);
	  }
	  else {
	    /* found first trace of next record */
	    ir++;
	    ntr[ir]=1;
	    (*nrec)++;
	    if (*nrec>MAX_RECS-1) err=E_OUTOFBOUNDS;
	    szp=sz;
	    sxp=sx;
	    syp=sy;
	  }

	  /* set tracr, write trace to output */
	  tr.tracr=ntr[ir];
	  fputtr(*fpout,&tr);

	}
      }
      else {
	fprintf(stream,"Error: traceserver_init\n");
	fprintf(stream,"failed to read first trace on input file\n");
	err=E_FILE;
      }
#ifdef IWAVE_USE_MPI
    }
  }

  /* assumes that any failure will duplicate failure on
     world root */
  MPI_Bcast(&err,1,MPI_INT,0,MPI_COMM_WORLD);

  if (err) return err;

  /* broadcast record info */
  MPI_Bcast(nrec,1,MPI_INT,0,MPI_COMM_WORLD);
  MPI_Bcast(ntr,*nrec,MPI_INT,0,MPI_COMM_WORLD);
  /* CAUTION: the following line assumes that the PEs in the comm all
     agree in word structure, i.e. that an off_t is the same sequence
     of bytes in all machines */
  MPI_Bcast((char *)(&(recoff[0])),(*nrec)*sizeof(off_t),MPI_CHAR,0,MPI_COMM_WORLD);

  /* broadcast number of samples as int, so that MPI_Datatype can be initialized */
  MPI_Bcast(&ins,1,MPI_INT,0,MPI_COMM_WORLD);
  
  /* construct MPI datatype in every process */
  buildMPI_OFFSEGY(p,ins);

  if (rkl==0) {
#endif
    fflush(*fpout);
    err=err||fseeko(*fpin,0L,SEEK_SET);
    err=err||fseeko(*fpout,0L,SEEK_SET);
    if (err) {
      fprintf(stream,"ERROR: traceserver_init\n");
      fprintf(stream,"seek failed\n");
    }
#ifdef IWAVE_USE_MPI
  }
  err= err || calc_group(&ng,&ig,&first,&last,rkw,szw,szl,*nrec,stream);

#endif

  /* initial set for irec, xrec */
  *irec=first;
  *xrec=first;

  return err;
}

int traceserver_rec(int * irec,
		    int * xrec,
		    int nrec,
		    FILE * stream) {
  int err=0;
  int last=nrec-1;        /* last record for group - serial default=nrec-1 */

#ifdef IWAVE_USE_MPI
  int first=0;            /* first record for group - serial default=0 */
  int rkw;                /* world rank */
  int rk;                 /* group rank */
  int szw;                /* world size */
  int sz;                 /* group size */
  int ng;                 /* number of groups */
  int ig;                 /* group index */

  /* this is only one of many possible ways to determine the 
     next record index. This one assumes that all groups have 
     the same size, and that the group size divides the world
     size exactly to give the number of groups. The records 
     are assigned to groups statically: if nrec/ng=lrec+rem/ng,
     with 0<=rem<ng, then the first rem groups get lrec+1 records, 
     the last ng-rem get lrec.

     This strategy is likely to be efficient only if the group jobs
     are truly uniform in size and nrec is large compared to ng. The
     most efficient strategy, queue-of-tasks, requires a master node
     dedicated to tracking irec requests.
  */
 
  /* ranks */
  MPI_Comm_rank(MPI_COMM_WORLD,&rkw);
  rk=retreiveRank();

  /* sizes */
  MPI_Comm_size(MPI_COMM_WORLD,&szw);
  sz=retreiveSize();

  err=calc_group(&ng,&ig,&first,&last,rkw,szw,sz,nrec,stream);

  /*  fprintf(stream,"tr_rec: ng=%d ig=%d first=%d last=%d nrec=%d \n",ng,ig,first,last,nrec,ng);*/
    
  if (!err && rk==0) {
    
#endif
    *irec=*xrec;
    (*xrec)++;    
    if (*irec > last) err=W_EOF;
    
#ifdef IWAVE_USE_MPI
  }    

  /* broadcast new record index, error */

  MPI_Bcast(irec,1,MPI_INT,0,retreiveComm());
  MPI_Bcast(&err,1,MPI_INT,0,retreiveComm());
  /*  fprintf(stream,"tr_rec: rkw=%d rk=%d ig=%d\n",rkw,rk,ig);*/
#endif
  /*  fprintf(stream,"tr_rec: last=%d irec=%d\n",last,*irec);*/
  return err;
}

int traceserver_seek(FILE * fp,
		     off_t * n) {
  int res=0;
#ifdef IWAVE_USE_MPI 
  if (retreiveRank()==0)  {
#endif
    res=fseeko(fp,*n,SEEK_SET);
#ifdef IWAVE_USE_MPI 
  }
#endif
  return res;
}

int traceserver_get(FILE * fp,
#ifdef IWAVE_USE_MPI
		    MPI_Datatype *p,
#endif
		    offsegy * otr) {

  int err=0;

#ifdef IWAVE_USE_MPI
  /*  MPI_Datatype p;*/
  /*  int ns=0;*/
  if (retreiveRank()==0) {
#endif

    otr->m=ftello(fp);
    if (!fgettr(fp,&(otr->tr))) err=W_EOF;
#ifdef IWAVE_USE_MPI 
  }
  MPI_Bcast(&err,1,MPI_INT,0,retreiveComm());
  /* if sz==1 don't need to send anything */
  if (!err && retreiveSize()>1) {
    /* int-ize header word ns */
    /*    ns=(otr->tr).ns;*/
    /*    err=MPI_Bcast(&ns,1,MPI_INT,0,retreiveComm());*/
    /*    buildMPI_OFFSEGY(&p,ns);*/
    /*    fprintf(stream,"rkl=%d broadcast trace with %d samples\n",retreiveRank(),tr->ns);*/
    err=err || MPI_Bcast(otr,1,*p,0,retreiveComm());
  }
#endif

  return err;
}

int traceserver_put(FILE * fp,
#ifdef IWAVE_USE_MPI
		    MPI_Datatype *p,
#endif
		    offsegy * otr) {

  int err=0;

#ifdef IWAVE_USE_MPI

  /* if sz==1 don't need to send anything */

  MPI_Status mpistat;
  int i;
  for (i=0;i<retreiveSize();i++) {
    if (retreiveRank()==i) {
      err=err || MPI_Send(otr,1,*p,0,i,retreiveComm());
    }
    if (retreiveRank()==0) {
      err=err || MPI_Recv(otr,1,*p,i,i,retreiveComm(),&mpistat);
    }
  }
  if (!err && retreiveRank()==0) {
#endif

    err=err||fseeko(fp,otr->m,SEEK_SET);
    if (!err) fputtr(fp,&(otr->tr));

#ifdef IWAVE_USE_MPI
  }
#endif
  return err;
}

int construct_tracegeom(tracegeom * tg,
			char * hdr,
			char * data,
			float tol,
			FILE * stream) {

  /*Igor - destroy previous one*/
  /*destroy_tracegeom(tg); */
  /*WWS 14.12.08 - clear out buffers, do not destroy tg - this object depends on it!*/
  setnull_tracegeom(tg);

  return traceserver_init(&(tg->fpin),hdr,
			  &(tg->fpout),data,
			  &(tg->irec),&(tg->xrec),
			  &(tg->nrec),
			  tg->ntr,tg->recoff,
#ifdef IWAVE_USE_MPI
			  &(tg->p),
#endif
			  tol,
			  stream);
}

int init_tracegeom(tracegeom * tg,
		   RPNT og,
		   IPNT n, RPNT d, RPNT o,
		   IPNT axord,
		   int order,
		   float dt, int ndim,
		   int usernt, float usert0, 
		   int initbuf,
		   FILE * stream) {

  /******************* BEGIN LOCAL DECLARATIONS **********************/

  int i;                        /* counter */
  offsegy otr;                  /* segy workspace aug. with off_t */
  Value val;                    /* header val workspace */

  float tmpx;                   /* temp storage for recvr coords */
  float tmpy;
  float tmpz;
  float tmpsx;                  /* temp storage for source coords */
  float tmpsy;
  float tmpsz;
  float tmpdt;                  /* temp storage for dt */
  int tmpnt;                    /* temp storage for number of samples */
  float tmpt0;                  /* temp storage for first sample time */

  float ozg;                    /* GLOBAL grid origin coordinates */ 
  float oxg; 
  float oyg;
  int nz; int nx; int ny;       /* LOCAL grid parameters */
  float oz; float ox; float oy;
  float dz; float dx; float dy;
  RPNT ol;                      /* parameters for extended grid */
  IPNT nl; 
  RPNT x;                       /* workspace to pass recv coords to ringrid */
  int marg;                     /* margin implied by sample order - added to grid
				   axis on each end */
  int init[MAX_TRACES];         /* flag array for convenience on re-reading */
  int iinit;                    /* initialized trace counter */
  int itr;                      /* trace counter */
  float * work;                 /* workspace for spline adjoint interpolation */
  int wlen;                     /* length of allocated spline workspace */
  int iend=1;                   /* endpoint code for splines (linear) */
  int err=0;                    /* error flag */

#ifdef IWAVE_USE_MPI
  int rk=0;                     /* rank */
#endif


  /******************* END LOCAL DECLARATIONS **********************/

#ifdef IWAVE_USE_MPI
  MPI_Comm_rank(MPI_COMM_WORLD,&rk);
#endif

  /* sanity check */
  if (tg->nrec==0) {
    fprintf(stream,"Error: init_tracegeom\n");
    fprintf(stream,"number of records = 0 on call\n");
    return E_BADINPUT;
  }

  /*  if (rk==0) fprintf(stderr,"in init: call tr_rec\n");*/
  /* obtain correct record number - if no more records, set return flag */
  err=traceserver_rec(&(tg->irec),&(tg->xrec),tg->nrec,stream);
  /*  fprintf(stream,"tg_init: irec=%d err=%d\n",tg->irec,err);*/
  if (err) {
    fprintf(stream,"NOTE: init_tracegeom from traceserver_rec\n");
    fprintf(stream,"no more records!\n");
    return err;
  }

  /* read trace info from fpout rather than fpin
     ONLY because tracr is GUARANTEED TO BE SET CORRECTLY
     in fpout - done in traceserver_init. Otherwise all 
     header and offset info is the same between the two.
     *

  /*  if (rk==0) fprintf(stderr,"in init: call tr_seek\n");*/
  /*  fprintf(stream,"rk=%d call traceserver_seek\n",retreiveRank()); */
  /* seek to correct location */
  /*  err=traceserver_seek(tg->fpin,&(tg->recoff[tg->irec]));*/
  err=traceserver_seek(tg->fpout,&(tg->recoff[tg->irec]));
  /*  fprintf(stream,"rk=%d return traceserver_seek\n",retreiveRank());*/
  if (err) {
    fprintf(stream,"Error: init_tracegeom from traceserver_seek\n");
    return err;
  }
  /* common initializations for record */

  /*  if (rk==0) fprintf(stderr,"in init: initializations\n");*/
  /* initialize flag array FOR RECORD */
  for (itr=0;itr<MAX_TRACES;itr++) init[itr]=0;
  /* initialize trace counter FOR RECORD */
  itr=0;
   
  /* initialize grid parameters - default outside dimn */
  nz=1; dz=1.0; oz=0.0; ozg = 0.0;
  nx=1; dx=1.0; ox=0.0; oxg = 0.0;
  ny=1; dy=1.0; oy=0.0; oyg = 0.0;
  
  /*  fprintf(stream,"axord: 0=%d 1=%d 2=%d\n",axord[0],axord[1],axord[2]);*/

  /* sanity check axis ordering array */
  if (ndim==1) {
    if (axord[0]!=0) { 
      fprintf(stream,"Error: axis order munged\n");
      return E_BADARRINDEX; 
    }
  }
  else if (ndim==2) {
    if (axord[0] < 0 || 
	axord[1] < 0 || 
	axord[0]+axord[1] != 1 ||
	axord[0]*axord[1] != 0) { 
      fprintf(stream,"Error: axis order munged\n");
      return E_BADARRINDEX; 
    }
  }
  else if (ndim==3) {
    if (axord[0] < 0 || 
	axord[1] < 0 || 
	axord[2] < 0 ||
	axord[0]+axord[1]+axord[2] != 3 ||
	axord[0]*axord[1]+axord[0]*axord[2]+axord[1]*axord[2] != 2 ||
	axord[0]*axord[1]*axord[2] != 0) { 
      fprintf(stream,"Error: axis order munged\n");
      return E_BADARRINDEX; 
    }
  }
  else {
    fprintf(stream,"Error: infeasible ndim=%d\n",ndim); 
    return E_OTHER; 
  }

  /* in computing local grid params for testing, include points
     at which interpolation will add contributions from the grid
     passed as argument - this means adding marg points on each
     end of each axis, shifting the origin left by marg*d[i] on 
     each axis. For symmetric interpolation (assumed), marg = 
     (order+1)/2.
  */
  marg=iwave_max(1,(order+1)/2);
  if (marg<0 || marg>2) {
    fprintf(stream,"Error: infeasible order=%d\n",order);
    return E_OTHER;
  }

  RASN(ol,RPNT_0);
  IASN(nl,IPNT_1);

  if (ndim > 0) { 
    nz=n[axord[0]]; 
    dz=d[axord[0]]; 
    oz=o[axord[0]]; 
    ozg=og[axord[0]];
    nl[axord[0]]=nz+2*marg;
    ol[axord[0]]=oz-marg*dz;
  }
  if (ndim > 1) { 
    nx=n[axord[1]]; 
    dx=d[axord[1]]; 
    ox=o[axord[1]]; 
    oxg=og[axord[1]];
    nl[axord[1]]=nx+2*marg;
    ol[axord[1]]=ox-marg*dx;
  }
  if (ndim > 2) { 
    ny=n[axord[2]]; 
    dy=d[axord[2]]; 
    oy=o[axord[2]]; 
    oyg=og[axord[2]];
    nl[axord[2]]=ny+2*marg;
    ol[axord[2]]=oy-marg*dy;
  }

      fprintf(stream,"nl = %d %d\n",nl[0],nl[1]);
      fprintf(stream,"ol = %e %e\n",ol[0],ol[1]);
      fprintf(stream,"d  = %e %e\n",d[0],d[1]);

  /* record grid dimension in tg struct */
  tg->ndim = ndim;
  
  /* record axis order for use on output */
  for (i=0;i<RARR_MAX_NDIM;i++) tg->axord[i]=axord[i];

  /* loop over traces in record, reading until either no more traces are
     read or until the source location is no longer the same */

  /*  fprintf(stream,"rk=%d start loop over %d traces\n",retreiveRank(),(tg->ntr)[tg->irec]);*/

  itr=0;          /* number of traces processed from this record */

  tg->ntraces=0;  /* number of traces located in grid */

  /*  if (rk==0) fprintf(stderr,"in init: read loop\n");*/

  while ( (itr < (tg->ntr)[tg->irec]) && (!err) ) {

    /*    fprintf(stream,"rk=%d itr=%d\n",retreiveRank(),itr);*/

    /*    if (rk==0) fprintf(stderr,"in init: call tr_get\n");*/
    /*    err=traceserver_get(tg->fpin,*/
    err=traceserver_get(tg->fpout,
#ifdef IWAVE_USE_MPI
			&(tg->p),
#endif
			&otr); 

    /*    if (rk==0) fprintf(stderr,"in init: process trace\n");*/
  
    if (!err) {

      /* extract info common TO RECORD from first trace IN RECORD */
      if (tg->ntraces==0) {

	/* time step is always that passed as arg */
	tg->dt   = dt;
    
	/* take trace time data from first trace read */
	gethdval(&(otr.tr),"ns",&val);
	tmpnt = vtoi(hdtype("ns"),val);
    
	/* TIME UNITS HARDWIRED TO MS */
	gethdval(&(otr.tr),"dt",&val);
	tmpdt = (1.e-3)*vtof(hdtype("dt"),val);      
    
	gethdval(&(otr.tr),"delrt",&val);
	tmpt0   = vtof(hdtype("delrt"),val);
    
	/* time step and output time data.
	   case 1: user specified output time grid */
	if ( usernt > 0 ) {
	  tg->interp=0;
	  tg->nt = usernt;
	  tg->ntout = tg->nt;
	  tg->dtout = tg->dt;
	  /* adjust t0 so that 0 is a sample point */
	  tg->t0 = dt*((int)floor(usert0/dt));
	  tg->t0out = tg->t0;
	}
	/* case 2: output time grid read from file */ 
	else {
	  tg->interp=1;
	  tg->ntout = tmpnt;
	  tg->dtout = tmpdt;
	  tg->t0out = tmpt0;
	  tg->nt = (int)((tmpnt-1)*tmpdt/dt)+1;
	  tg->t0 = dt*((int)floor(tmpt0/dt));
	}
    
	/* in any case, tmax (simulator stopping time) computed
	   from simulation time grid: */
	tg->tmax = tg->t0 + (tg->nt-1)*(tg->dt);	  

	/* read scale information */
	gethdval(&(otr.tr),"scalco",&val);
	tg->scalco = vtof(hdtype("scalco"),val);
	gethdval(&(otr.tr),"scalel",&val);
	tg->scalel = vtof(hdtype("scalel"),val);
	  
	/* read source position */
	gethdval(&(otr.tr),"sx",&val);
	tmpsx = vtof(hdtype("sx"),val);
	if (tg->scalco > 0) { tmpsx *=  tg->scalco; }
	if (tg->scalco < 0) { tmpsx /= -tg->scalco; }

	gethdval(&(otr.tr),"sy",&val);
	tmpsy = vtof(hdtype("sy"),val);
	if (tg->scalco > 0) { tmpsy *=  tg->scalco; }
	if (tg->scalco < 0) { tmpsy /= -tg->scalco; }

	gethdval(&(otr.tr),"selev",&val);
	tmpsz = vtof(hdtype("selev"),val);
	if (tg->scalel > 0) { tmpsz *=  tg->scalel; }
	if (tg->scalel < 0) { tmpsz /= -tg->scalel; }
	tmpsz=-tmpsz;

	/* store source info, assumed same for all traces
	   25.02.08: change is* to absolute rather than relative int
	   coord 
	   10.07.08: change it back.
	   22.10.08: introduce axis order permutation - only two allowed
	   23.10.08: sensible dimension options
	*/

	IASN(tg->is,IPNT_0);
	RASN(tg->rs,RPNT_0);
	if ( ndim == 3 ) {
	  tg->is[axord[1]]=(int)((tmpsx-oxg)/dx);
	  tg->rs[axord[1]]=(tmpsx-oxg-dx*tg->is[axord[1]])/dx;
	  tg->is[axord[2]]=(int)((tmpsy-oyg)/dy);
	  tg->rs[axord[2]]=(tmpsy-oyg-dy*tg->is[axord[2]])/dy;
	  tg->is[axord[0]]=(int)((tmpsz-ozg)/dz);
	  tg->rs[axord[0]]=(tmpsz-ozg-dz*tg->is[axord[0]])/dz;
	}
	else if ( ndim == 2 ) {
	  tg->is[axord[1]]=(int)((tmpsx-oxg)/dx);
	  tg->rs[axord[1]]=(tmpsx-oxg-dx*tg->is[axord[1]])/dx;
	  tg->is[axord[2]]=0;
	  tg->rs[axord[2]]=0.0;
	  tg->is[axord[0]]=(int)((tmpsz-ozg)/dz);
	  tg->rs[axord[0]]=(tmpsz-ozg-dz*tg->is[axord[0]])/dz;
	}
	else if ( ndim == 1 ) {
	  tg->is[axord[1]]=0;
	  tg->rs[axord[1]]=0.0;
	  tg->is[axord[2]]=0;
	  tg->rs[axord[2]]=0.0;
	  tg->is[axord[0]]=(int)((tmpsz-ozg)/dz);
	  tg->rs[axord[0]]=(tmpsz-ozg-dz*tg->is[axord[0]])/dz;
	}
	else { 
	  fprintf(stream,"Error: tracegeom_init - infeasible ndim=%d\n",ndim);
	  return E_BADINPUT; 
	}
      }

      tmpz=0.0;
      tmpx=0.0;
      tmpy=0.0;

      gethdval(&(otr.tr),"gx",&val);
      tmpx = vtof(hdtype("gx"),val);
      if (tg->scalco > 0) { tmpx *=  tg->scalco;}
      if (tg->scalco < 0) { tmpx /= -tg->scalco;}

      gethdval(&(otr.tr),"gy",&val);
      tmpy = vtof(hdtype("gy"),val);
      if (tg->scalco > 0) { tmpy *=  tg->scalco;}
      if (tg->scalco < 0) { tmpy /= -tg->scalco;}
      
      gethdval(&(otr.tr),"gelev",&val);
      tmpz = vtof(hdtype("gelev"),val);
      if (tg->scalel > 0) { tmpz *=  tg->scalel; }
      if (tg->scalel < 0) { tmpz /= -tg->scalel; }
      tmpz =- tmpz; 
      
      /* For all subsequent traces read, check that traces 
	 are all same length */
      gethdval(&(otr.tr),"ns",&val);
      tmpnt=vtoi(hdtype("ns"),val);
      if (tmpnt != tg->ntout) {
	fprintf(stream,"Error: tracegeom_init - change in nt from %d to %d\n",
		tg->ntout,tmpnt);
	return E_OTHER;
      }
	  
      /* store trace-dep info for each trace properly inside the grid */

      IASN(tg->ig[tg->ntraces],IPNT_0);
      RASN(tg->rg[tg->ntraces],RPNT_0);
      x[axord[0]]=tmpz;
      x[axord[1]]=tmpx;
      x[axord[2]]=tmpy;

      init[itr]=0;

      if ( (ndim ==3) &&	
	   ringrid(ndim,nl,d,ol,x) ) {
	tg->ig[tg->ntraces][axord[1]]=(int)((tmpx-oxg)/dx);
	tg->rg[tg->ntraces][axord[1]]=(tmpx-oxg-dx*tg->ig[tg->ntraces][axord[1]])/dx;
	tg->ig[tg->ntraces][axord[2]]=(int)((tmpy-oyg)/dy);
	tg->rg[tg->ntraces][axord[2]]=(tmpy-oyg-dy*tg->ig[tg->ntraces][axord[2]])/dy;
	tg->ig[tg->ntraces][axord[0]]=(int)((tmpz-ozg)/dz);
	tg->rg[tg->ntraces][axord[0]]=(tmpz-ozg-dz*tg->ig[tg->ntraces][axord[0]])/dz;
	init[itr] = 1;
      }
      if ( (ndim == 2) &&  
	   ringrid(ndim,nl,d,ol,x) ) {
	(tg->ig)[tg->ntraces][axord[1]]=(int)((tmpx-oxg)/dx);
	(tg->rg)[tg->ntraces][axord[1]]=(tmpx-oxg-dx*(tg->ig)[tg->ntraces][axord[1]])/dx;
	(tg->ig)[tg->ntraces][axord[2]]=0;
	(tg->rg)[tg->ntraces][axord[2]]=0.0;
	(tg->ig)[tg->ntraces][axord[0]]=(int)((tmpz-ozg)/dz);
	(tg->rg)[tg->ntraces][axord[0]]=(tmpz-ozg-dz*(tg->ig)[tg->ntraces][axord[0]])/dz;
	init[itr] = 1;
      }
      if ( (ndim == 1) &&
	   ringrid(ndim,nl,d,ol,x) ) {
	(tg->ig)[tg->ntraces][axord[1]]=0;
	(tg->rg)[tg->ntraces][axord[1]]=0.0;
	(tg->ig)[tg->ntraces][axord[2]]=0;
	(tg->rg)[tg->ntraces][axord[2]]=0.0;
	(tg->ig)[tg->ntraces][axord[0]]=(int)((tmpz-ozg)/dz);
	(tg->rg)[tg->ntraces][axord[0]]=(tmpz-ozg-dz*tg->ig[tg->ntraces][axord[0]])/dz;
	init[itr] = 1;
      }
      
      if (init[itr]) {
	gethdval(&(otr.tr),"tracl",&val);
	tg->tracl[tg->ntraces]=vtoi(hdtype("tracl"),val);
	gethdval(&(otr.tr),"tracr",&val);
	tg->tracr[tg->ntraces]=vtoi(hdtype("tracr"),val);
	gethdval(&(otr.tr),"fldr",&val);
	tg->fldr[tg->ntraces]=vtoi(hdtype("fldr"),val);
	gethdval(&(otr.tr),"tracf",&val);
	tg->tracf[tg->ntraces]=vtoi(hdtype("tracf"),val);
	tg->troff[tg->ntraces]=otr.m;
	
	/*	fprintf(stream,"rk=%d one more trace recorded, offset=%ld\n",retreiveRank(),tg->troff[tg->ntraces]);*/
	tg->ntraces++;
      }      
      /* one more trace read... */
      itr++; /* in record */
    }
  }
   
  /* allocate data buffer, optionally store data */
  
  if (tg->ntraces) {
    tg->buf = NULL;
    tg->buf =(float *)malloc(tg->ntraces * tg->nt * sizeof(float));
    if (!tg->buf) {
      fprintf(stream,"Error: tracegeom_init - failed to allocate trace\n");
      fprintf(stream,"buffer of length %d\n",
	      tg->ntraces*tg->nt*sizeof(float));
      return E_ALLOC;
    }
    for (i=0; i < tg->ntraces * tg->nt; i++) tg->buf[i] = 0.0;
    
    /* if data is to be initialized, re-read file, adjoint-interpolate
       active traces onto simulation time grid.
    */
    if (initbuf) {
      if (traceserver_seek(tg->fpin,&(tg->recoff[tg->irec]))) return E_FILE;
      iinit=0;
      wlen=cubicadj_getworksize(tg->nt,tmpnt);
      work=(float *)malloc(wlen*sizeof(float));
      if (!work) {
	fprintf(stream,"Error: tracegeom_init - failed to allocate work\n");
	fprintf(stream,"buffer of length %d\n",wlen*sizeof(float));
	return E_ALLOC;
      }
      for (i=0;i<(tg->ntr)[tg->irec];i++) {
	if (traceserver_get(tg->fpin,
#ifdef IWAVE_USE_MPI
			    &(tg->p),
#endif
			    &otr)) return E_OUTOFBOUNDS;
	if (init[i]) {
	  err=cubicadj_(&tmpt0,   &tmpdt,   (otr.tr).data,             &tmpnt,
			&(tg->t0),&(tg->dt),&((tg->buf)[iinit*tg->nt]),&(tg->nt),
			&iend,    work,     &wlen);
	  if (err) {
	    fprintf(stream,"Error: tracegeom_init from cubicadj, err=%d\n",
		    err);
	    return err;
	  }
	  iinit++;
	}
      }
      free(work);
    }
  }	       
  /* no traces properly in grid: setnull only trace-dep storage */
  else {
    tg->buf = NULL;
  }

  return err;
}

void destroy_tracegeom(tracegeom * tg) {
  tg->nrec=0;
  tg->irec=0;
  tg->xrec=0;
  fflush(tg->fpout);
  if (tg->fpin) fclose(tg->fpin);
  if (tg->fpout) fclose(tg->fpout);
  tg->fpin=NULL;
  tg->fpout=NULL;
  setnull_tracegeom(tg);
}

void setnull_tracegeom(tracegeom * tg) {
  if (tg->buf) free(tg->buf); 
  tg->buf=NULL;
  tg->ntraces=0;
  tg->nt=0;
  tg->ntout=0;
  tg->dt=0.0;
  tg->dtout=0.0;
  tg->t0=0.0;
  tg->t0out=0.0;
  tg->scalel=0;
  tg->scalco=0;
  tg->ndim=0;
}

void fprint_tracegeom(tracegeom const * tg,FILE *fp) {
  int i;
  fprintf(fp,"TRACE GEOMETRY STRUCT\n");
  fprintf(fp,"  -- global quantities -- \n");
  fprintf(fp,"nrec      = %12.1d\n",tg->nrec);
  fprintf(fp,"irec      = %12.1d\n",tg->irec);
  fprintf(fp,"xrec      = %12.1d\n",tg->xrec);
  fprintf(fp,"  -- record quantities -- \n");
  if (tg->nrec>0) {
    fprintf(fp,"ntr[irec] = %12.1d\n",(tg->ntr)[tg->irec]);
  }
  fprintf(fp,"ntraces   = %12.1d\n",tg->ntraces);
  fprintf(fp,"scalel    = %12.1d\n",tg->scalel);
  fprintf(fp,"scalco    = %12.1d\n",tg->scalco);
  if (tg->ndim > 0) fprintf(fp,"isz       = %12.1d\n",tg->is[tg->axord[0]]);
  if (tg->ndim > 1) fprintf(fp,"isx       = %12.1d\n",tg->is[tg->axord[1]]);
  if (tg->ndim > 2) fprintf(fp,"isy       = %12.1d\n",tg->is[tg->axord[2]]);
  if (tg->ndim > 0) fprintf(fp,"rsz       = %12.4e\n",tg->rs[tg->axord[0]]);
  if (tg->ndim > 1) fprintf(fp,"rsx       = %12.4e\n",tg->rs[tg->axord[1]]);
  if (tg->ndim > 2) fprintf(fp,"rsy       = %12.4e\n",tg->rs[tg->axord[2]]);
  fprintf(fp,"nt        = %12.1d\n",tg->nt);
  fprintf(fp,"ntout     = %12.1d\n",tg->ntout);
  fprintf(fp,"dt        = %12.4e\n",tg->dt);
  fprintf(fp,"dtout     = %12.4e\n",tg->dtout);
  fprintf(fp,"t0        = %12.4e\n",tg->t0);
  fprintf(fp,"t0out     = %12.4e\n",tg->t0out);
  fprintf(fp,"interp    = %12.1d\n",tg->interp);
  fprintf(fp,"    itr");
  if (tg->ndim > 0) fprintf(fp,"    igz");
  if (tg->ndim > 1) fprintf(fp,"    igx");
  if (tg->ndim > 2) fprintf(fp,"    igy");
  if (tg->ndim > 0) fprintf(fp,"      rgz    ");
  if (tg->ndim > 1) fprintf(fp,"      rgx    ");
  if (tg->ndim > 2) fprintf(fp,"      rgy    ");
  if (tg->ndim > 0) fprintf(fp,"  tracr");
  if (tg->ndim > 0) fprintf(fp,"   offset");
  fprintf(fp,"\n");
  for (i=0;i<tg->ntraces;i++) {
    fprintf(fp,"%6.d",i);
    if (tg->ndim > 0) fprintf(fp," %6.1d",tg->ig[i][tg->axord[0]]);
    if (tg->ndim > 1) fprintf(fp," %6.1d",tg->ig[i][tg->axord[1]]);
    if (tg->ndim > 2) fprintf(fp," %6.1d",tg->ig[i][tg->axord[2]]);
    if (tg->ndim > 0) fprintf(fp,"   %10.4e",tg->rg[i][tg->axord[0]]);
    if (tg->ndim > 1) fprintf(fp,"   %10.4e",tg->rg[i][tg->axord[1]]);
    if (tg->ndim > 2) fprintf(fp,"   %10.4e",tg->rg[i][tg->axord[2]]);
    if (tg->ndim > 0) fprintf(fp," %6.1d",tg->tracr[i]);
    if (tg->ndim > 0) fprintf(fp," %10.1ld",tg->troff[i]);
    fprintf(fp,"\n");
  }
  fprintf(fp, "\n");
}

void print_tracegeom(tracegeom const * tg) {
  fprint_tracegeom(tg,stdout);
}

void sampletraces(tracegeom * tg,
		  int order,
		  int it, 
		  IPNT n0,
		  IPNT gs0,
		  IPNT n,
		  IPNT gs,
		  ireal * d) {
  /*****************************************
   * gs input added 25.02.08: must treat 
   * ix,iy,iz as GLOBAL grid indices!!! 
   *****************************************
   * only orders 0,1 implemented: 06.21.08 
   *****************************************
   * input pointer, avoid copy - 15.01.09 
   *****************************************
   * test for being in grid - let accum. 
   * in writetraces handle
   * sampling by multiple domains. use 
   * ingrid function to determine in/out.
   * 11.03.09
   *****************************************
   * observe that test for grid should refer 
   * to COMPUTATIONAL grid, whereas offset
   * has to be computed for ALLOCATED grid
   * so BOTH have to be passed. This would
   * be simpler if it were an rarray app, as
   * then could use rget.
   * 14.3.09
   *****************************************/

  int itr;
  int ioff;
  int ndim;
  IPNT ind;
  
  if (it<0 || it>tg->nt-1) return;

  ndim=tg->ndim;
  IASN(ind,IPNT_0);

  for (itr=0;itr<tg->ntraces;itr++) {

    (tg->buf)[it+itr*tg->nt]=REAL_ZERO;
    
    /* set up index tuple, grid offset */
    if (ndim > 0) {
      ind[0]=(tg->ig)[itr][0];
      ioff = ind[0]-gs0[0];
    }
    if (ndim > 1) {
      ind[1]=(tg->ig)[itr][1];
      ioff+= (ind[1]-gs0[1])*n0[0];
    }
    if (ndim > 2) {
      ind[2]=(tg->ig)[itr][2];
      ioff+= (ind[2]-gs0[2])*n0[0]*n0[1];      
    }

    if (order==0) {
      if (ndim==1) {
	/* 0,0,0 */
	if (ingrid(ndim,n,gs,ind)   && 
	    (tg->rg)[itr][0] <= 0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff];
	/* 1,0,0 */
	ind[0]++;
	if (ingrid(ndim,n,gs,ind)   && 
	    (tg->rg)[itr][0] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1];
	ind[0]--;
      }
      else if (ndim == 2) {
	/* 0,0,0 */
	if (ingrid(ndim,n,gs,ind)   && 
	    (tg->rg)[itr][0] <= 0.5 && 
	    (tg->rg)[itr][1] <= 0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff];
	/* 1,0,0 */
	ind[0]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] >  0.5 && 
	    (tg->rg)[itr][1] <= 0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1];
	ind[0]--;
	/* 0,1,0 */
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] <= 0.5 && 
	    (tg->rg)[itr][1] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+n0[0]];
	ind[1]--;
	/* 1,1,0 */
	ind[0]++;
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] >  0.5 && 
	    (tg->rg)[itr][1] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1+n0[0]];
	ind[0]--;
	ind[1]--;
      }
      else if (ndim == 3) {
	/* 0,0,0 */
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] <= 0.5 && 
	    (tg->rg)[itr][1] <= 0.5 &&
	    (tg->rg)[itr][2] <= 0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff];
	/* 1,0,0 */
	ind[0]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] >  0.5 && 
	    (tg->rg)[itr][1] <= 0.5 &&
	    (tg->rg)[itr][2] <= 0.5)  
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1];
	ind[0]--;
	/* 0,1,0 */
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] <= 0.5 && 
	    (tg->rg)[itr][1] >  0.5 &&
	    (tg->rg)[itr][2] <= 0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+n0[0]];
	ind[1]--;
	/* 0,0,1 */
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] <= 0.5 && 
	    (tg->rg)[itr][1] <= 0.5 &&
	    (tg->rg)[itr][2] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+n0[0]*n0[1]];
	ind[2]--;
	/* 1,1,0 */
	ind[0]++;
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] >  0.5 && 
	    (tg->rg)[itr][1] >  0.5 &&
	    (tg->rg)[itr][2] <= 0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1+n0[0]];
	ind[0]--;
	ind[1]--;
	/* 1,0,1 */
	ind[0]++;
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] >  0.5 && 
	    (tg->rg)[itr][1] <= 0.5 &&
	    (tg->rg)[itr][2] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1+n0[0]*n0[1]];
	ind[0]--;
	ind[2]--;
	/* 0,1,1 */
	ind[1]++;
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] <= 0.5 && 
	    (tg->rg)[itr][1] >  0.5 &&
	    (tg->rg)[itr][2] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+n0[0]+n0[0]*n0[1]];
	ind[1]--;
	ind[2]--;
	/* 1,1,1 */
	ind[0]++;
	ind[1]++;
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)   &&
	    (tg->rg)[itr][0] >  0.5 && 
	    (tg->rg)[itr][1] >  0.5 &&
	    (tg->rg)[itr][2] >  0.5) 
	  (tg->buf)[it+itr*tg->nt] = d[ioff+1+n0[0]+n0[0]*n0[1]];
	ind[0]--;
	ind[1]--;
	ind[2]--;
      }
    }

    else if (order==1) {
      if (ndim==1) {
	/* 0,0,0 */
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*d[ioff];
	/* 1,0,0 */
	ind[0]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+= (tg->rg)[itr][0]*d[ioff+1];
	ind[0]--;
      }
      else if (ndim == 2) {
	/* 0,0,0 */
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*(1.0-(tg->rg)[itr][1])*d[ioff];
	/* 1,0,0 */
	ind[0]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (tg->rg)[itr][0]*(1.0-(tg->rg)[itr][1])*d[ioff+1];
	ind[0]--;
	/* 0,1,0 */
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*(tg->rg)[itr][1]*d[ioff+n0[0]];
	ind[1]--;
	/* 1,1,0 */
	ind[0]++;
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (tg->rg)[itr][0]*(tg->rg)[itr][1]*d[ioff+1+n0[0]];
	ind[0]--;
	ind[1]--;
      }
      else if (ndim == 3) {
	/* 0,0,0 */
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*(1.0-(tg->rg)[itr][1])*(1.0-(tg->rg)[itr][2])*d[ioff];
	/* 1,0,0 */
	ind[0]++;
	if (ingrid(ndim,n,gs,ind)) 
	(tg->buf)[it+itr*tg->nt]+=
	  (tg->rg)[itr][0]*(1.0-(tg->rg)[itr][1])*(1.0-(tg->rg)[itr][2])*d[ioff+1];
	ind[0]--;
	/* 0,1,0 */
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*(tg->rg)[itr][1]*(1.0-(tg->rg)[itr][2])*d[ioff+n0[0]];
	ind[1]--;
	/* 0,0,1 */
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*(1.0-(tg->rg)[itr][1])*(tg->rg)[itr][2]*d[ioff+n0[0]*n0[1]];
	ind[2]--;
	/* 1,1,0 */
	ind[0]++;
	ind[1]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (tg->rg)[itr][0]*(tg->rg)[itr][1]*(1.0-(tg->rg)[itr][2])*d[ioff+1+n0[0]];
	ind[0]--;
	ind[1]--;
	/* 1,0,1 */
	ind[0]++;
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (tg->rg)[itr][0]*(1.0-(tg->rg)[itr][1])*(tg->rg)[itr][2]*d[ioff+1+n0[0]*n0[1]];
	ind[0]--;
	ind[2]--;
	/* 0,1,1 */
	ind[1]++;
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (1.0-(tg->rg)[itr][0])*(tg->rg)[itr][1]*(tg->rg)[itr][2]*d[ioff+n0[0]+n0[0]*n0[1]];
	ind[1]--;
	ind[2]--;
	/* 1,1,1 */
	ind[0]++;
	ind[1]++;
	ind[2]++;
	if (ingrid(ndim,n,gs,ind)) 
	  (tg->buf)[it+itr*tg->nt]+=
	    (tg->rg)[itr][0]*(tg->rg)[itr][1]*(tg->rg)[itr][2]*d[ioff+1+n0[0]+n0[0]*n0[1]];
	ind[0]--;
	ind[1]--;
	ind[2]--;
      }
      else {
	return;
      }
    }
    else {
      return;
    }
  }
}

/* 17.01.09: abstracted from writetraces */
int assembletrace(tracegeom const * tg,
		  offsegy * otr,
		  int nb,
		  float dz,
		  float dx,
		  float dy,
		  float ozg,
		  float oxg,
		  float oyg,
		  int idz,
		  int idx,
		  int idy,
		  float * work,
		  int wl) {

  Value val;
  
  float tmp;
  float tmps;
  
  int err=0;
  int iend=1;
  
  if ((0 > nb) || (nb>tg->ntraces-1)) {
    err=E_OTHER;
    return err;
  }
 
  /* clear out header */
  memset(&(otr->tr),0,240);

  val.h=tg->scalco;
  puthdval(&(otr->tr),"scalco",&val);
  
  tmp =oxg + ((tg->ig)[nb][idx]+(tg->rg)[nb][idx])*dx;
  tmps=oxg +((tg->is)[idx]+(tg->rs)[idx])*dx;
  if (tg->scalco > 0) { tmp /=  tg->scalco; tmps /=  tg->scalco; }
  if (tg->scalco < 0) { tmp *= -tg->scalco; tmps *= -tg->scalco; }
  val.i=tmp;
  puthdval(&(otr->tr),"gx",&val);
  val.i=tmps;
  puthdval(&(otr->tr),"sx",&val);
  
  tmp =oyg + ((tg->ig)[nb][idy]+(tg->rg)[nb][idy])*dy;
  tmps=oyg + ((tg->is)[idy]+(tg->rs)[idy])*dy;
  if (tg->scalco > 0) { tmp /=  tg->scalco; tmps /=  tg->scalco; }
  if (tg->scalco < 0) { tmp *= -tg->scalco; tmps *= -tg->scalco; }
  val.i=tmp;
  puthdval(&(otr->tr),"gy",&val);
  val.i=tmps;
  puthdval(&(otr->tr),"sy",&val);
  
  val.h=tg->scalel;
  puthdval(&(otr->tr),"scalel",&val);
  
  tmp = -(ozg + ((tg->ig)[nb][idz] + (tg->rg)[nb][idz])*dz);
  tmps= -(ozg + ((tg->is)[idz]+(tg->rs)[idz])*dz);
  if (tg->scalel > 0) { tmp /=  tg->scalel; tmps /=  tg->scalel; }
  if (tg->scalel < 0) { tmp *= -tg->scalel; tmps *= -tg->scalel; }
  val.i=tmp;
  puthdval(&(otr->tr),"gelev",&val);
  val.i=tmps;
  puthdval(&(otr->tr),"selev",&val);
  
  val.u=1000.0*(tg->dtout);
  puthdval(&(otr->tr),"dt",&val);
  
  val.u=tg->ntout;
  puthdval(&(otr->tr),"ns",&val);
  
  val.h=tg->t0out;
  puthdval(&(otr->tr),"delrt",&val);
  
  val.i=(tg->tracl)[nb];
  puthdval(&(otr->tr),"tracl",&val);
  
  val.i=(tg->tracr)[nb];
  puthdval(&(otr->tr),"tracr",&val);
  
  val.i=(tg->fldr)[nb];
  puthdval(&(otr->tr),"fldr",&val);
  
  val.i=(tg->tracf)[nb];
  puthdval(&(otr->tr),"tracf",&val);
  
  /* interpolate based on flag. Note that if internal and 
     output grids are same, interp is a no-op, so interpolating
     in error is harmless. */
  if (tg->interp) {
    if ( (err=cubic_(&(tg->t0),&(tg->dt),&((tg->buf)[nb*tg->nt]),&(tg->nt),
		     &(tg->t0out),&(tg->dtout),(otr->tr).data,&(tg->ntout),
		     &iend,work,&wl)) ) { return err; }
  }
  /* otherwise simple copy, with obvious sanity check */
  else {
    if (tg->nt != tg->ntout) return E_OTHER;
    memcpy((otr->tr).data,&((tg->buf)[nb*tg->nt]),tg->nt*sizeof(float));
  } 
  
  otr->m=(tg->troff)[nb];

  return err;
}


/* 10.07.08: added og back in - note: GLOBAL */
/* 15.01.09: pass pointer to tg, avoid copy */
int writetraces(tracegeom const * tg, 
		RPNT d,
		RPNT og,
		FILE * stream) {
  
  /* BEGIN DECLARE WORKSPACE **************************************************/

  offsegy otr;                  /* segy+off_t struct for trace comm */
#ifdef IWAVE_USE_MPI
  segy tr;                      /* trace workspace for accumulation */
#endif
  int nb;                       /* trace number counter */

  int init[MAX_TRACES];         /* flag array - need to re-read */

  float dz = 1.0;               /* grid step in z */
  float dx = 1.0;               /* grid step in x */
  float dy = 1.0;               /* grid step in y */
  float ozg = 0.0;              /* global grid origin - z */
  float oxg = 0.0;              /* global grid origin - x */
  float oyg = 0.0;              /* global grid origin - y */
  int idz = 0;                  /* z axis index */
  int idx = 0;                  /* x axis index */
  int idy = 0;                  /* y axis index */

  int j;                        /* general purpose counter */

  int ndim;                     /* problem dimension (should be 1, 2, or 3!) */
  
  int err=0;                    /* error flag */
  float * work;                 /* interpolation workspace */
  int wl;                       /* length of interpolation workspace */

#ifdef IWAVE_USE_MPI
  int tleft;                    /* total number of traces left to record */
  MPI_Status stat;       
#endif

  /* END DECLARE WORKSPACE **************************************************/

  ndim = tg->ndim;
  if (ndim < 1 || ndim > RARR_MAX_NDIM ) {
    fprintf(stream,"ERROR: writetraces\n");
    fprintf(stream,"ndim=%d out of range [1,%d]\n",ndim);
    return E_OTHER;
  }

  if (tg->ntr[tg->irec] > MAX_TRACES) {
    fprintf(stream,"ERROR: writetraces\n");
    fprintf(stream,"number of traces = %d in record %d exceeds hard-coded limit = %d\n",
	    tg->ntr[tg->irec],
	    tg->irec,
	    MAX_TRACES);
    return E_OTHER;
  }

  for (j=0;j<MAX_TRACES;j++) init[j]=0;  

  if (ndim > 0)  { idz=(tg->axord)[0]; dz = d[(tg->axord)[0]]; ozg = og[(tg->axord[0])]; }
  if (ndim > 0)  { idx=(tg->axord)[1]; dx = d[(tg->axord[1])]; oxg = og[(tg->axord[1])]; }
  if (ndim > 0)  { idy=(tg->axord)[2]; dy = d[(tg->axord)[2]]; oyg = og[(tg->axord)[2]]; }

  /* allocate workspace for interpolation, even if not needed */
  wl=cubic_getworksize(tg->nt);
  work=(float *)malloc(sizeof(float)*wl);
  if (!work) return E_ALLOC;

  /* first pass: the only pass in serial, rank 0 in parallel */
#ifdef IWAVE_USE_MPI
  if (retreiveRank()==0) {
#endif

    /* seek to file begin */
    err=fseeko(tg->fpout,0L,SEEK_SET);
    if (err) {
      fprintf(stream,"ERROR: writetraces from fseeko 1, err=%d\n",err);
      return err;
    }

#ifdef VERBOSE 
    fprintf(stream,"writetraces: first pass trace loop rk 0\n");
#endif
    for (nb=0;nb<tg->ntraces;nb++) {
      err=assembletrace(tg,&otr,nb,
			dz,dx,dy,ozg,oxg,oyg,idz,idx,idy,
			work,wl);
      if (err) {
	fprintf(stream,"ERROR: writetraces from assembletrace, err=%d\n",err);
	return err;
      }
	  
#ifdef VERBOSE
      fprintf(stream,"writetraces: rk 0 write trace %d tracr=%d offset=%ld\n",nb,otr.tr.tracr,otr.m);
#endif
      err=fseeko(tg->fpout,otr.m,SEEK_SET);
      if (err) {
	fprintf(stream,"ERROR: writetraces from fseeko 2, err=%d\n",err);
	return err;
      }      
      fputtr(tg->fpout,&(otr.tr));
      
      init[otr.tr.tracr]=1;
    }
     
#ifdef IWAVE_USE_MPI
  }

  /* second pass - from here on rank 0 acts as server */

#ifdef VERBOSE 
    fprintf(stream,"writetraces: second pass trace loop rk 0\n");
#endif

  /* collect ntraces info */
  tleft=0;
  MPI_Reduce((void *)(&(tg->ntraces)),(void *)(&tleft),1,MPI_INT,MPI_SUM,0,retreiveComm());

  if (retreiveRank()==0) {

#ifdef VERBOSE
    fprintf(stream,"writetraces: total number of traces = %d\n",tleft);
#endif
 
    /* account for traces already written */
    tleft-=tg->ntraces;

    while (tleft > 0 && !err) {
     
#ifdef VERBOSE
      fprintf(stream,"writetraces: number of traces yet to be recd = %d\n",tleft);
#endif
      err=err || MPI_Recv(&otr,1,tg->p,MPI_ANY_SOURCE,0,retreiveComm(),&stat);
      if (!err) {
#ifdef VERBOSE
	fprintf(stream,"RECV from rank %d offset=%ld tracr=%d ns=%d\n",stat.MPI_SOURCE,otr.m,otr.tr.tracr,otr.tr.ns); 
#endif
	/* two different options, depending on whether any part of this
	   trace has been written already. If so, read it back into buffer,
	   add data samples to trace passed via comm. In either case, write 
	   out.
	*/
	if (init[otr.tr.tracr]) {
	  fprintf(stream,"writetraces: init flag set, read to update\n");
	  err=fseeko(tg->fpout,otr.m,SEEK_SET);
	  if (err) {
	    fprintf(stream,"ERROR: writetraces from fseeko 3, err=%d\n",err);
	    return err;
	  }
	  if (HDRBYTES+(tg->ntout)*sizeof(float) !=fgettr(tg->fpout,&tr)) {
	    fprintf(stream,"ERROR: writetraces from fgettr, failed to read %d bytes\n",
		    HDRBYTES+(tg->ntout)*sizeof(float));
	    return err;
	  }
	  for (j=0;j<tr.ns;j++) 
	    otr.tr.data[j]+=tr.data[j];  	 
	} 

	err=fseeko(tg->fpout,otr.m,SEEK_SET);
	if (err) {
	  fprintf(stream,"ERROR: writetraces from fseeko 4, err=%d\n",err);
	  return err;
	}
	fputtr(tg->fpout,&(otr.tr));       
	init[otr.tr.tracr]=1;
	tleft--;
#ifdef VERBOSE
	fprintf(stream,"trace %d written, %d left\n",otr.tr.tracr,tleft);
#endif
      }
    }
  }
  else {
    nb=0;
    while (nb<tg->ntraces && !err) {
      err=assembletrace(tg,&otr,nb,
			dz,dx,dy,ozg,oxg,oyg,idz,idx,idy,
			work,wl);
      if (!err) {
#ifdef VERBOSE
	fprintf(stream,"SEND from rank=%d offset=%ld ns=%d\n",retreiveRank(),otr.m,otr.tr.ns);
#endif
	err=err || MPI_Send(&otr,1,tg->p,0,0,retreiveComm());
	nb++;
      }      
    }
  }
#endif 

  free(work);
  return err;

}


