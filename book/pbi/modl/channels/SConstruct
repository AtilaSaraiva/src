#
# Make a deep-water channel model
#
# James W. Jennings Jr.
# Research Scientist
# 
# Bureau of Economic Geology
# John A. and Katherine G. Jackson School of Geosciences
# University of Texas at Austin
# University Station, Box X
# Austin, TX 78713-8924
# 
# 512-471-1534 (voice)
# 512-471-0140 (fax)
# mailto:jim.jennings@beg.utexas.edu
# http://www.beg.utexas.edu/staffinfo/jennings01.htm
# 
# July 2005
#
# $Id$
#

#
# Setting up
#

from math    import pi
from rsfproj import *
import os
import string
import rfield
import channels

# Authentication for the private data server

private = { 'server'   : os.environ.get('BEG_SERVER'),
            'login'    : os.environ.get('BEG_LOGIN'),
            'password' : os.environ.get('BEG_PASSWORD')}

#
# User adjustable settings
#

#
# Grid specification
#
# This current version of channels.py interpolates 15 2D arrays of
# channel position and skew from Mathematica-exported files to your
# desired grid.  The original files were generated in Mathematica on
# the following grid:
#
# n1=181   d1=30m   o1=0m 
# n2=101   d2=30m   o2=0m          
#
# The Mathematica grid spans:
#
# 0m <= x <= 5400m
#
# and
#
# 0m <= y <= 3000m
#
# Your grid should be within this range to avoid extrapolation on the
# edges.  These grid parameters set the location and size of your grid
# relative to the Mathematica arrays.  After the channels are created
# optional x and y padding is added, increasing nx and ny to values
# larger than those specified here (see padding parameter below), and
# the grid origin is reset to zero.
#
# Future versions of channels.py may generate position and skew
# internally, avoiding the interpolation-extrapolation issue.
#
# The following example spans:
#
# 0m <= x <= (nx-1)*dx = 5385m
#
# and
#
# 0m <= y <= (ny-1)*dy = 2985m
#
# nx=360   dx=15m   ox=0m         
# ny=200   dy=15m   oy=0m          
#

#
# The z coordinate measures height (not depth) above the bottom of the
# first channel.  The top of the last channel is at 110m.
#
# There are two sets of vertical grid parameters, one for a reservoir
# grid that contains the channels, and another set for a grid of
# overburden with only background material with it's noise, but no
# channels.  The two grids have the same x and y grid parameters, but
# they may have different z direction grid size, spacing, and location.
#
# You can choose any vertical grid.  Choosing a reservoir grid smaller
# than the channel range will produce a grid that clips some of the
# channels. Choosing a larger grid will generate extra "pad" volume
# above or below the channels.  After the channels are created the grid
# origin is reset to zero.  The overburden grid will have no channels,
# even if you choose it's location within the zone where the channels
# exist.
#
# The following example creates a vertical reservoir grid that spans
# -20m <= z <= 129m, with a 20m pad below the bottom channel, and a 19m
# pad above the top channel:
#
# res_grid_par['nz'] = 150
# res_grid_par['dz'] =   1 (m)
# res_grid_par['oz'] = -20 (m)
#

#
# Additional padding in the x and y directions: grid_par['xy_pad']
#
# This parameter controls the width (in cells) for additional all-shale
# padding to be added to all four horizontal sides of the model after
# the channels are constructed.  After the pad is added, the x and y
# origin is reset to zero.
#

grid_par = {'nx':360, 'dx':15, 'ox':0,      # common x & y grid parameters
            'ny':200, 'dy':15, 'oy':0,
            'xy_pad':40}

res_grid_par = grid_par.copy()              # reservoir z grid parameters
res_grid_par['nz'] =  90
res_grid_par['dz'] =   2
res_grid_par['oz'] = -40

ovr_grid_par = grid_par.copy()              # overburden z grid parameters
ovr_grid_par['nz'] =  50
ovr_grid_par['dz'] =  40
ovr_grid_par['oz'] = 130

#
# Channel geometrical properties
#

geo_par = {}

# Amalgamated sand geometrical properties 

# width at channel bottom
# fraction of channel top width
geo_par['as_width']   = 0.8

# lateral shift at abs(skew)=1 (channel max bend)
# fraction of channel top width
geo_par['as_shift']   = 0.8

# height at skew=0 (channel inflection)
# fraction of channel depth
geo_par['as_height0'] = 0.5

# height at abs(skew)=1 (channel max bend)
# fraction of channel depth
geo_par['as_height1'] = 0.8

# cross-section shape factor
# =1 parabolic, >1 more blunt, <1 more pointy
geo_par['as_shape']   = 1.2   

# Bar drape geometrical properties 

# bar drape profile depth
# fraction of basic channel depth
geo_par['bd_depth']  =  0.8

# bar drape profile z shift
# fraction of basic channel depth, positive is down
geo_par['bd_zshift'] = -0.15

# Margin drape geometrical properties 

# margin drape profile depth
# fraction of basic channel depth
geo_par['md_depth']  =  1.2

# margin drape profile z shift
# fraction of basic channel depth, positive is down
geo_par['md_zshift'] =  0.1

#
# Sand fraction parameters 
#

sand_par = {}

# sand fraction in the bypass drape
sand_par['bd_sand'] = 0.3

# sand fraction in the margin drape
sand_par['md_sand'] = 0.2

# sand fraction in the amalgamated sand
sand_par['as_sand'] = 1.0

# sand fraction in non-amalgamated sand at channel top
sand_par['na_sand0'] = 0.4

# sand fraction in non-amalgamated sand just outside the amalgamated sand
sand_par['na_sand1'] = 0.9

#
# Porosity random field properties
#
# These parameters are used to generate random fields of noise to be
# added to the background and sand porosity.  The same noise propogates
# through the subsequent generation of the rho, vp, and vs grids.  In
# this example we are choosing different standard deviations and
# different correlation ranges for the background and sand, but the
# same anisotropy orientation.  We are also choosing to use the same
# parameters for the background noise in both the reservoir and
# overburden grids.
#
# The code will make one realizataion for the background noise, and 15
# different realizations for the channels, one for each of the 15
# channels in the model.  The 15 sand realizatins are all made with the
# same set of parameters.  The random number seeds are preset.  A small
# coding change would allow for user setting of the random number seeds
# for different realizations of the entire model.
#

# Background noise parameters
bk_noise_par = {'taper_switch':True,    # covariance taper switch
                'std_dev': 0.007,       # porosity noise standard devietion
                'alpha':1,              # covariance shape parameter
                'oriu':[1,0,0],         # covariance range orientation vectors
                'oriv':[0,1,0], 
                'oriw':[0,0,1],
                'ru':1000,              # covariance range parameters
                'rv':1000,   
                'rw':   1}

# Amalgamated and non-amalgamated sand noise parameters
sd_noise_par = {'taper_switch':True,    # covariance taper switch
                'std_dev':0.01,         # porosity noise standard devietion
                'alpha':1,              # covariance shape parameter
                'oriu':[1,0,0],         # covariance range orientation vectors
                'oriv':[0,1,0], 
                'oriw':[0,0,1],
                'ru':200,               # covariance range parameters
                'rv':200,   
                'rw':  1}

#
# Taper parameters
#
# A linear taper is applied, if desired, to the rock properties (phi,
# rho, vp, and vs) at the top and bottom of each of the reservoir and
# overburden grids.  However, it probably makes most sense to use only
# a top taper in the overburden, and only a bottom taper in the
# reservoir, as in this example.
# 
# The properties are linearly interpolated between those generated by
# the channel model, and a set of constants for the top (or bottom) of
# the grid. The weighting is computed to produce the constant values at
# the top (or bottom) of the taper zone, the channel model output at
# the bottom (or top) of the taper zone and below (or above), and
# linear weighting with depth in between.
#
# If a taper thickness is set to zero no taper will be applied in the
# corresponding taper zone.
#

# Reservoir taper parameters
res_taper_par = { 'top_h'    :    0,      # thickness (m)
                  'top_phi'  :    0.3500, # porosity (fraction)
                  'top_rho'  :    1.6865, # density (gm/cc)
                  'top_vp'   : 1964.5730, # Vp (m/s)
                  'top_vs'   :  509.7961, # Vs (m/s)
                  'bot_h'    :   20,      # thickness (m)
                  'bot_phi'  :    0.1554, # porosity (fraction)
                  'bot_rho'  :    2.3431, # density (gm/cc)
                  'bot_vp'   : 2429.1460, # Vp (m/s)
                  'bot_vs'   : 1019.5922} # Vs (m/s)

# Overburden taper parameters
ovr_taper_par = { 'top_h'    : 2000,      # thickness (m)
                  'top_phi'  :    0.3500, # porosity (fraction)
                  'top_rho'  :    1.6865, # density (gm/cc)
                  'top_vp'   : 1964.5730, # Vp (m/s)
                  'top_vs'   :  509.7961, # Vs (m/s)
                  'bot_h'    :    0,      # thickness (m)
                  'bot_phi'  :    0.1554, # porosity (fraction)
                  'bot_rho'  :    2.3431, # density (gm/cc)
                  'bot_vp'   : 2429.1460, # Vp (m/s)
                  'bot_vs'   : 1019.5922} # Vs (m/s)

#
# Available memory size setting for transpose operations (Mb)
#

memsize = 512

#
# End of user adjustable settings
#

#
# Make reservoir model grids
#

channels.make_reservoir (   memsize, private,
                            res_grid_par, geo_par,
                            sand_par, bk_noise_par, sd_noise_par,
                            res_taper_par)

#
# Make overburden model grids
#

channels.make_overburden (memsize, ovr_grid_par, bk_noise_par, ovr_taper_par)

#
# Make plots
#

list_res = ['res_sand_xypad',
            'res_phi_noise_taper',
            'res_rho_noise_taper',
            'res_vp_noise_taper',
            'res_vs_noise_taper']

bias_res = {'res_sand_xypad'       :    0.5,
            'res_phi_noise_taper'  :    0.2,
            'res_rho_noise_taper'  :    2,
            'res_vp_noise_taper'   : 2500,
            'res_vs_noise_taper'   : 1000}

list_ovr = ['ovr_phi_noise_taper',
            'ovr_rho_noise_taper',
            'ovr_vp_noise_taper',
            'ovr_vs_noise_taper']

bias_ovr = {'ovr_phi_noise_taper'  :    0.2,
            'ovr_rho_noise_taper'  :    2,
            'ovr_vp_noise_taper'   : 2500,
            'ovr_vs_noise_taper'   : 1000}

for cube in (list_res):
    Result (cube,
            '''
            byte gainpanel=all allpos=n pclip=100 bias=%g |
            grey3 title="%s" color=j frame1=%d frame2=%d frame3=%d
            ''' % (bias_res[cube],cube,
                   grid_par['nx']/2+grid_par['xy_pad'],
                   grid_par['ny']/2+grid_par['xy_pad'],
                   res_grid_par['nz']/2) )

for cube in (list_ovr):
    Result (cube,
            '''
            byte gainpanel=all allpos=n pclip=100 bias=%g |
            grey3 title="%s" color=j frame1=%d frame2=%d frame3=%d
            ''' % (bias_ovr[cube],cube,
                   grid_par['nx']/2+grid_par['xy_pad'],
                   grid_par['ny']/2+grid_par['xy_pad'],
                   ovr_grid_par['nz']/2) )

#
# End
#

End ()
