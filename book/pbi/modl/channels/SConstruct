#
# Make a deep-water channel model
#
# James W. Jennings Jr.
# Research Scientist
# 
# Bureau of Economic Geology
# John A. and Katherine G. Jackson School of Geosciences
# University of Texas at Austin
# University Station, Box X
# Austin, TX 78713-8924
# 
# 512-471-1534 (voice)
# 512-471-0140 (fax)
# mailto:jim.jennings@beg.utexas.edu
# http://www.beg.utexas.edu/staffinfo/jennings01.htm
# 
# July 2005
#
# $Id$
#

#
# Setting up
#

from math    import pi
from rsfproj import *
import os
import string
import rfield
import channels

# Authentication for the private data server

private = { 'server'   : os.environ.get('BEG_SERVER'),
            'login'    : os.environ.get('BEG_LOGIN'),
            'password' : os.environ.get('BEG_PASSWORD')}

#
# User adjustable settings
#

#
# Grid specification
#
# This SConstruct version interpolates 15 2D arrays of channel position
# and skew from Mathematica-exported files to your desired grid.  The
# original files were generated in Mathematica on the following grid:
#
# n1=181   d1=30m   o1=0m 
# n2=101   d2=30m   o2=0m          
#
# The Mathematica grid spans:
#
# 0m <= x <= 5400m
#
# and
#
# 0m <= y <= 3000m
#
# Your grid should be within this range to avoid extrapolation on the
# edges.  These grid parameters set the location and size of your grid
# relative to the Mathematica arrays.  After the channels are created
# optional x and y padding is added, increasing nx and ny to values
# larger than those specified here (see padding parameter below), and
# the grid origin is reset to zero.
#
# Future versions of this SConstruct may generate position and
# skew internally, avoiding the interpolation-extrapolation issue.
#
# The following example spans:
#
# 0m <= x <= (nx-1)*dx = 5385m
#
# and
#
# 0m <= y <= (ny-1)*dy = 2985m
#
# nx=360   dx=15m   ox=0m         
# ny=200   dy=15m   oy=0m          
#

#
# The z coordinate measures height (not depth) above the bottom of the
# first channel.  The top of the last channel is at 110m.
#
# There are two sets of vertical grid parameters, one for a reservoir
# grid that contains the channels, and another set for a grid of
# overburden with only background material with it's noise, but no
# channels.  The two grids have the same x and y grid parameters, but
# they may have different z direction grid size, spacing, and location.
#
# You can choose any vertical grid.  Choosing a reservoir grid smaller
# than the channel range will produce a grid that clips some of the
# channels. Choosing a larger grid will generate extra "pad" volume
# above or below the channels.  After the channels are created the grid
# origin is reset to zero.  The overburden grid will have no channels,
# even if you choose it's location within the zone where the channels
# exist.
#
# The following example creates a vertical reservoir grid that spans
# -20m <= z <= 129m, with a 20m pad below the bottom channel, and a 19m
# pad above the top channel:
#
# nz_res=150   dz_res=1m   oz_res=-20m
#

#
# Set the grid parameters here
#

# Array sizes (number of cells)

nx     =  360   
ny     =  200
nz_res =   90
nz_ovr =   50

# Cell sizes (in meters)

dx     =  15          
dy     =  15
dz_res =   2
dz_ovr =  40

# Axis origin (in meters)

ox     =    0          
oy     =    0          
oz_res =  -40
oz_ovr =  130

#
# Additional padding in the x and y directions 
#
# This parameter controls the width (in cells) for additional all-shale
# padding to be added to all four horizontal sides of the model after
# the channels are constructed.  After the pad is added, the x and y
# origin is reset to zero.
#

xy_pad = 40

#
# Amalgamated sand geometrical properties 
#

# width at channel bottom
# fraction of channel top width
as_width   = 0.8

# lateral shift at abs(skew)=1 (channel max bend)
# fraction of channel top width
as_shift   = 0.8

# height at skew=0 (channel inflection)
# fraction of channel depth
as_height0 = 0.5

# height at abs(skew)=1 (channel max bend)
# fraction of channel depth
as_height1 = 0.8

# cross-section shape factor
# =1 parabolic, >1 more blunt, <1 more pointy
as_shape   = 1.2   

#
# Bar drape geometrical properties 
#

# bar drape profile depth
# fraction of basic channel depth
bd_depth  =  0.8

# bar drape profile z shift
# fraction of basic channel depth, positive is down
bd_zshift = -0.15

#
# Margin drape geometrical properties 
#

# margin drape profile depth
# fraction of basic channel depth
md_depth  =  1.2

# margin drape profile z shift
# fraction of basic channel depth, positive is down
md_zshift =  0.1

#
# Sand fraction parameters 
#

# sand fraction in the bypass drape
bd_sand = 0.3

# sand fraction in the margin drape
md_sand = 0.2

# sand fraction in the amalgamated sand
as_sand = 1.0

# sand fraction in non-amalgamated sand at channel top
na_sand0 = 0.4

# sand fraction in non-amalgamated sand just outside the amalgamated sand
na_sand1 = 0.9

#
# Porosity random field properties
#
# These parameters are used to generate random fields of noise to be
# added to the background and sand porosity.  The same noise propogates
# through the subsequent generation of the rho, vp, and vs grids.  In
# this example we are choosing different standard deviations and
# different correlation ranges for the background and sand, but the
# same anisotropy orientation.  We are also choosing to use the same
# parameters for the background noise in both the reservoir and
# overburden grids.
#
# The code will make one realizataion for the background noise, and 15
# different realizations for the channels, one for each of the 15
# channels in the model.  The 15 sand realizatins are all made with the
# same set of parameters.  The random number seeds are preset.  A small
# coding change would allow for user setting of the random number seeds
# for different realizations of the entire model.
#

# Background standard deviation
bk_std_dev = 0.007

# Amalgamated and non-amalgamated sand (sand) standard deviation
sd_std_dev = 0.01

# Covariance range orientation vectors
oriu = [1,0,0]
oriv = [0,1,0]
oriw = [0,0,1]

# Background covariance range parameters
bk_ru = 1000         
bk_rv = 1000
bk_rw =    1

# Sand covariance range parameters
sd_ru =  200         
sd_rv =  200
sd_rw =    1

#
# Taper thicknesses
#
# A linear taper is applied, if desired, to the rock properties (phi,
# rho, vp, and vs) at the top and bottom of each of the reservoir and
# overburden grids.  However, it probably makes most sense to use only
# a top taper in the overburden, and only a bottom taper in the
# reservoir, as in this example.
# 
# The properties are linearly interpolated between those generated by
# the channel model, and a set of constants for the top (or bottom) of
# the grid. The weighting is computed to produce the constant values at
# the top (or bottom) of the taper zone, the channel model output at
# the bottom (or top) of the taper zone and below (or above), and
# linear weighting with depth in between.
#
# These parameters set the thicknesses of the taper zones in meters. 
# If a value is set to zero no taper will be applied in the
# corresponding taper zone.
#

top_taper_res =    0
bot_taper_res =   20

top_taper_ovr = 2000
bot_taper_ovr =    0

#
# Taper properties
#

# Porosity (fraction)
top_taper_phi = 0.3500
bot_taper_phi = 0.1554

# Density (gm/cc)
top_taper_rho = 1.6865
bot_taper_rho = 2.3431

# Vp (m/s)
top_taper_vp = 1964.5730
bot_taper_vp = 2429.1460

# Vs (m/s)
top_taper_vs =  509.7961
bot_taper_vs = 1019.5922

#
# Available memory size setting for transpose operations (Mb)
#

memsize = 512

#
# End of user adjustable settings
#

#
# Make reservoir model grids
#

channels.make_reservoir (   private=private, memsize=memsize, xy_pad=xy_pad,
                            nx=nx,    ny=ny,    nz=nz_res,
                            dx=dx,    dy=dy,    dz=dz_res,
                            ox=ox,    oy=oy,    oz=oz_res,
                            oriu=oriu,      oriv=oriv,      oriw=oriw,
                            bk_ru=bk_ru,    bk_rv=bk_rv,    bk_rw=bk_rw,
                            sd_ru=sd_ru,    sd_rv=sd_rv,    sd_rw=sd_rw,
                            bk_std_dev=bk_std_dev,  sd_std_dev=sd_std_dev,
                            bd_depth=bd_depth,      md_depth=md_depth,
                            bd_zshift=bd_zshift,    md_zshift=md_zshift,
                            as_width=as_width,      as_shift=as_shift, 
                            as_height0=as_height0,  as_height1=as_height1, 
                            as_shape=as_shape,      as_sand=as_sand,
                            bd_sand=bd_sand,        md_sand=md_sand,
                            na_sand0=na_sand0,      na_sand1=na_sand1,
                            top_taper=top_taper_res,        bot_taper=bot_taper_res,
                            top_taper_phi=top_taper_phi,    top_taper_rho=top_taper_rho,
                            top_taper_vp=top_taper_vp,      top_taper_vs=top_taper_vs,
                            bot_taper_phi=bot_taper_phi,    bot_taper_rho=bot_taper_rho,
                            bot_taper_vp=bot_taper_vp,      bot_taper_vs=bot_taper_vs)


#
# Make overburden model grids
#

channels.make_overburden (  memsize=memsize, xy_pad=xy_pad,
                            nx=nx,    ny=ny,    nz=nz_ovr,
                            dx=dx,    dy=dy,    dz=dz_ovr,
                            ox=ox,    oy=oy,    oz=oz_ovr,
                            oriu=oriu,      oriv=oriv,      oriw=oriw,
                            bk_ru=bk_ru,    bk_rv=bk_rv,    bk_rw=bk_rw,
                            bk_std_dev=bk_std_dev,
                            top_taper=top_taper_ovr,        bot_taper=bot_taper_ovr,
                            top_taper_phi=top_taper_phi,    top_taper_rho=top_taper_rho,
                            top_taper_vp=top_taper_vp,      top_taper_vs=top_taper_vs,
                            bot_taper_phi=bot_taper_phi,    bot_taper_rho=bot_taper_rho,
                            bot_taper_vp=bot_taper_vp,      bot_taper_vs=bot_taper_vs)

#
# Make plots
#

list_res = ['res_sand_xypad',
            'res_phi_noise_taper',
            'res_rho_noise_taper',
            'res_vp_noise_taper',
            'res_vs_noise_taper']

bias_res = {'res_sand_xypad'       :    0.5,
            'res_phi_noise_taper'  :    0.2,
            'res_rho_noise_taper'  :    2,
            'res_vp_noise_taper'   : 2500,
            'res_vs_noise_taper'   : 1000}

list_ovr = ['ovr_phi_noise_taper',
            'ovr_rho_noise_taper',
            'ovr_vp_noise_taper',
            'ovr_vs_noise_taper']

bias_ovr = {'ovr_phi_noise_taper'  :    0.2,
            'ovr_rho_noise_taper'  :    2,
            'ovr_vp_noise_taper'   : 2500,
            'ovr_vs_noise_taper'   : 1000}

for cube in (list_res):
    Result (cube,
            '''
            byte gainpanel=all allpos=n pclip=100 bias=%g |
            grey3 title="%s" color=j frame1=%d frame2=%d frame3=%d
            ''' % (bias_res[cube],cube,nx/2+xy_pad,ny/2+xy_pad,nz_res/2)
           )

for cube in (list_ovr):
    Result (cube,
            '''
            byte gainpanel=all allpos=n pclip=100 bias=%g |
            grey3 title="%s" color=j frame1=%d frame2=%d frame3=%d
            ''' % (bias_ovr[cube],cube,nx/2+xy_pad,ny/2+xy_pad,nz_ovr/2)
           )

#
# End
#

End ()
