from rsfproj import *

# put parameters in text (ASCII) files

# Depth of interfaces
Flow('depth.asc',None,
     'echo 300 500 600 700 800 n1=5 data_format=ascii_float in=$TARGET')

# Velocity in "reservoir"
reservoir = (2000,2200)

# Two velocity layer models
for case in range(2):
    Flow('veloc%d.asc' % (case+1),None,
         '''
         echo 1500 1700 %d 2300 2400 2500 n1=6
         data_format=ascii_float in=$TARGET
         ''' % reservoir[case])

# Convert from text to RSF format
for par in ('depth','veloc1','veloc2'):
    Flow(par,par+'.asc','dd form=native')

for case in range(2):
    vel = 'veloc%d' % (case+1)
    Plot(vel,['depth',vel],
         '''
         pad beg1=1 | cmplx ${SOURCES[1]} |
         graph label1=Depth unit1=m label2=Velocity unit2=m/s
         dash=%d wanttitle=n
         ''' % case)
    Plot(vel+'+',['depth',vel],
         '''
         pad beg1=1 | cmplx ${SOURCES[1]} |
         graph label1=Depth unit1=m label2=Velocity unit2=m/s
         dash=%d wanttitle=n symbol=o symbolsz=10
         ''' % case)

# Display data
Result('modl','veloc1 veloc2 veloc1+ veloc2+','Overlay')

# Make constant Vs and density
Flow('vs','veloc1','math output=1000')
Flow('density','veloc1','math output=1')

# Generate a seismic trace
for case in ('1','2'):
    # generate reflectivity (PP,PS,SS)
    refl = 'refl'+case
    Flow(refl,['depth','veloc'+case,'vs','density'],
         '''
         modrefl vp=${SOURCES[1]} vs=${SOURCES[2]} rho=${SOURCES[3]}
         nt=1000 dt=0.004 
         ''')
    ai = 'ai'+case
    Flow(ai,refl,'causint')
    # generate PP reflection data
    data = 'data'+case
    Flow(data,refl,'window n2=1 | ricker1 frequency=10')

# Take difference
Flow('diff','data1 data2','add scale=-1,1 ${SOURCES[1]}')

# Display data
Result('data','data1 data2 diff',
       '''
       cat axis=2 ${SOURCES[1:3]} |
       dots labels=Before:After:Difference label1=Time unit1=s
       yreverse=y gaineach=n
       ''')

g0=0.95  # starting change 
g1=2-g0  # last change
ng=101   # number of changes to scan
dg = (g1-g0)/(ng-1)

for niter in (1,3,100):
    
    scan = 'scan%d' % niter
    
    # Scan shifts computing local similarity
    Flow(scan,'data2 data1',
         '''
         warpscan other=${SOURCES[1]} niter=%d
         ng=%d g0=%g dg=%g rect1=50 | 
         math output='(1+input)^4'
         ''' % (niter,ng,g0,dg))
    Plot(scan,
         '''
         grey title="Stretch Scan" allpos=y 
         color=j pclip=100
         label1=Time unit1=s label2=Gamma
         ''')

    pick = 'pick%d' % niter

    # Pick the stretch
    Flow(pick,scan,'pick rect1=50 vel0=1 | window')
    Plot(pick,
         '''
         graph transp=y min2=%g max2=%g 
         yreverse=y plotcol=7 plotfat=5 
         wantaxis=n wanttitle=n pad=n
         ''' % (g0,g1))
    Result(scan,[scan,pick],'Overlay')

# Convert stretch to shift
Flow('shift','pick100','math output="(input-1)*x1" ')

# Apply the stretch
Flow('warp','data2 data1 shift',
     '''
     warp1 other=${SOURCES[1]} warpin=${SOURCES[2]}
     verb=1 nliter=0 
     ''')

# Take difference
Flow('diff2','data1 warp','add scale=-1,1 ${SOURCES[1]}')

# Display data after warping
Result('warp','data1 warp diff2',
       '''
       cat axis=2 ${SOURCES[1:3]} |
       dots labels=Before:After:Difference label1=Time unit1=s
       yreverse=y gaineach=n
       ''')

# Add random noise
Flow('noisy','data1','noise seed=2006 var=0.0000001')

# Denoising with SWT

Flow('clean','noisy','swtdenoise ratio=0 n_layer=1')

Result('swt','noisy clean',
       '''
       cat axis=2 ${SOURCES[1]} |
       dots labels=Before:After label1=Time unit1=s
       yreverse=y gaineach=n
       ''')

Result('spec','noisy clean',
       '''
       cat axis=2 ${SOURCES[1]} |
       spectra |
       dots labels=Before:After label1=Frequency unit1=Hz
       yreverse=y gaineach=n
       ''')

End()
