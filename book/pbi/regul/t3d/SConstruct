from rsfproj import *

private = {'login':os.environ.get('BEG_LOGIN'),
           'password':os.environ.get('BEG_PASSWORD'),
           'server':os.environ.get('BEG_SERVER')}

segy = 'P100335SERGUI.DAT'

Fetch(segy,'total',private)

# Converting from SEGY to RSF and splitting headers from the data
# t3d.rsf is data
# h3d.rsf is trace headers

Flow('t3d h3d ./a3d ./b3d',segy,
     '''
     segyread tape=$SOURCE
     tfile=${TARGETS[1]} hfile=${TARGETS[2]} bfile=${TARGETS[3]}
     ''',stdin=0)

# Converting trace headers to float

Flow('thed','h3d','dd type=float')

# Computing inline and crossline offset (in km)

Flow('hx','thed','headermath output="(gx-sx)/1000" ')
Flow('hy','thed','headermath output="(gy-sy)/1000" ')

## vel = 1.35

## Flow('datum','hx hy',
##      '''
##      math hx=${SOURCES[0]} hy=${SOURCES[1]}
##      output="sqrt(hx*hx+hy*hy+0.000025)/%g"
##      ''' % (vel*vel ))

## Flow('tdat','t3d datum',
##      'window max1=4 | stretch rule=d datum=${SOURCES[1]} | transp')


tmax = 4 # maximum time

# Transpose to time slices

Flow('tdat','t3d','window max1=%g | transp memsize=500' % tmax)

az = 1.13 # guess at the acquisition azimuth (in radians)

# Rotate the offset azimuth (by converting to complex)

Flow('coff','hx hy',
     '''
     cmplx ${SOURCES[:2]} |
     math output="input*exp(I*%g)" |
     dd type=float
     ''' % az,stdin=0)



#for off in ('toff','coff'):

# Plot the offset geometry

Result('coff',

       '''
       dd type=complex | window |
       graph symbol=x label1=In-line label2=Cross-line
       title="Offset"
             ''')

## Flow('datbin','datum coff',
##      '''
##      window |
##      bin head=${SOURCES[1]}
##      xkey=0 ykey=1 interp=2
##      nx=141 dx=0.05 x0=-3.35
##      ny=141 dy=0.05 y0=-3.5
##      ''')

## Result('datbin',
##        '''
##        grey title="Datum" color=j allpos=y scalebar=y
##        transp=n yreverse=n barlabel="Time Shift (s)"
##        ''')
       

# Binning interpolation/stacking to regular grid
# tbin.rsf is regularly sampled data
# tfld.rsf is fold

Flow('tbin tfld','tdat coff',
     '''
     bin fold=${TARGETS[1]} head=${SOURCES[1]}
     xkey=0 ykey=1 interp=2
     nx=141 dx=0.05 x0=-3.35
     ny=141 dy=0.05 y0=-3.5
     ''')

# Plot the fold

Result('tfld',
       '''
       grey allpos=y pclip=100
       transp=n yreverse=n scalebar=1
       label1=In-line label2=Cross-line
       wheretitle=t wherexlabel=b
       title="Fold Map"
       ''')

# Make mask for missing traces

Flow('mask','tfld','spray axis=1 n=1001 o=0 d=0.004')

# Transpose and tpow

Flow('tran','tbin',
     '''
     transp plane=23 | transp plane=12 |
     tpow tpow=2.5
     ''')
       
# Plot regular data

Result('tbin','tran',
       '''
       byte gainpanel=70 |
       grey3 title="Binned Data"
       frame1=500 frame2=67 frame3=70
       ''')

# Select a slice

Flow('slice2','tran','window n3=1 f3=70')

# Model slope

Flow('dip0','slice2',
     'math output="x2/(x1+0.001)*%g" ' % (0.05/(0.004*1.5*1.5)))

# Estimate slope

Flow('dip2','slice2 dip0',
     'dip rect1=10 rect2=3 idip=${SOURCES[1]} nj1=2')

Result('dip2',
       '''
       grey color=j scalebar=y title="Dominant Slope" clip=4
       minval=-4 maxval=4
       ''')

# Plane-wave destruction residual

Flow('pwd2','slice2 dip2','pwd dip=${SOURCES[1]} nj1=2')

Plot('pwd2','grey title=Residual clip=10')

Result('pwd2','slice2 pwd2','OverUnderAniso')

# Interpolate

Flow('slice2i','slice2 dip2','dealias dip=${SOURCES[1]}')

# Comparison

Plot('slice2','grey title=Slice clip=10')

Plot('slice2i','grey title=Interpolated clip=10')

Result('slice2','slice2 slice2i','OverUnderAniso')

Plot('wslice','slice2',
     'window max1=3 max2=0 | grey title=Slice clip=10')

Plot('wslice2','slice2i',
     'window max1=3 max2=0 | grey title=Interpolated clip=10')

Result('wslice','wslice wslice2','SideBySideAniso')

Plot('wwslice','slice2',
     'window max1=2 max2=0 min2=-2 | grey title=Slice clip=10')

Plot('wwslice2','slice2i',
     'window max1=2 max2=0 min2=-2 | grey title=Interpolated clip=10')

Result('wwslice','wwslice wwslice2','SideBySideAniso')

## Flow('tbak','tbin datbin',
##      '''
##      transp plane=23 | transp plane=12 |
##      stretch rule=d datum=${SOURCES[1]} inv=y
##      ''')

## Result('tbak',
##        '''
##        tpow tpow=2.5 |
##        byte gainpanel=70 |
##        grey3 title="Binned"
##        frame1=500 frame2=70 frame3=70
##        ''')

#### 3-D Processing
###################

# Model slopes

Flow('idip','tran',
     'math output="x2/(x1+0.001)*%g" ' % (0.05/(0.004*1.5*1.5)))

Flow('xdip','tran',
     'math output="x3/(x1+0.001)*%g" ' % (0.05/(0.004*1.5*1.5)))

# Estimate slopes

Flow('dip','tran idip xdip mask',
     '''
     dip rect1=10 rect2=3 rect3=3
     idip=${SOURCES[1]} xdip=${SOURCES[2]} mask=${SOURCES[3]}
     nj1=2 nj2=2 liter=20 niter=5
     ''')

Plot('idip','dip',
     '''
     window n4=1 |
     byte clip=8 bar=bar |
     grey3 frame1=500 frame2=67 frame3=70
     color=j scalebar=y title="Inline Slope" 
     minval=-8 maxval=8
     ''')

Plot('xdip','dip',
     '''
     window f4=1 |
     byte clip=8 bar=bar |
     grey3 frame1=500 frame2=67 frame3=70
     color=j scalebar=y title="Crossline Slope" 
     minval=-8 maxval=8
     ''')

Result('dip','idip xdip','SideBySideAniso')

# Plane-wave destruction residual

Flow('pwd','tran dip','pwd dip=${SOURCES[1]} nj1=2 nj2=2')

Plot('ipwd','pwd',
     '''
     window n4=1 |
     byte gainpanel=70 clip=30 |
     grey3 frame1=500 frame2=67 frame3=70
     title="Inline Residual" 
     ''')

Plot('xpwd','pwd',
     '''
     window n4=1 |
     byte gainpanel=70 clip=30 |
     grey3 frame1=500 frame2=67 frame3=70
     title="Crossline Residual" 
     ''')

Result('pwd','ipwd xpwd','SideBySideAniso')

# Interpolate

Flow('tran2','tran dip','dealias dip=${SOURCES[1]}')

# Plot regular data

Result('tbin2','tran2',
       '''
       byte gainpanel=70 clip=30 |
       grey3 title="Interpolated Data"
       frame1=500 frame2=134 frame3=140
       ''')

# Create header for regular data

ntr = 281*281

Flow('tracl',None,'math n1=%d o1=1 d1=1 output=x1' % ntr)

Flow('slice','tran2', 'window n1=1')

Flow('fldr','slice',
     'put o1=1 d1=1 | math output=x1 | put n2=1 n1=%d' % ntr)
Flow('tracf','slice',
     'put o2=1 d2=1 | math output=x2 | put n2=1 n1=%d' % ntr)

Flow('hx2','slice','math output=x1 | put n2=1 n1=%d' % ntr)
Flow('hy2','slice','math output=x2 | put n2=1 n1=%d' % ntr)

# Unrotate offset

Flow('coff0','hx2 hy2',
     '''
     cmplx ${SOURCES[:2]} |
     math output="input*exp(-I*%g)" | window
     ''' % az,stdin=0)

Flow('hx0','coff0','real')
Flow('hy0','coff0','imag')

# Compute source positions

gx='525157'
gy='6237880'

Flow('sx','hx0','math output="%s-1000*input" ' % gx)
Flow('sy','hy0','math output="%s-1000*input" ' % gy)

Flow('gx','sx','math output=%s | window' % gx)
Flow('gy','sy','math output=%s | window' % gy)

# Time sampling

Flow('ns','sx','math output=1001')
Flow('dt','sx','math output=4000')

Flow('zero17','sx','math output=0 | spray axis=2 n=17')

Flow('zero13','sx','math output=0 | spray axis=2 n=13')

Flow('header',
     'tracl tracl fldr tracf zero17 sx sy gx gy zero13 ns dt',
     '''
     cat axis=2 ${SOURCES[1:12]} | pad n2=71 |
     transp | dd type=int
     ''')

# Write out SEGY

segy2 = '/data9/ricarte/Interpolate.sgy'

Flow(segy2,'tran2 header a3d b3d',
     '''
     segywrite tape=$TARGET ns=1001
     tfile=${SOURCES[1]} hfile=${SOURCES[2]} bfile=${SOURCES[3]}
     ''',stdout=-1)

End()

