# Data inversion for von Karman autocorrelation in 1D Fourier domain
#
# April 2007
#
# Thomas Jules Browaeys 
# Bureau of Economic Geology
# University of Texas at Austin
# mailto:jules.browaeys@beg.utexas.edu


from rsfproj import *
from math import pi


# Spatial 1D grid
# ---------------
# nx = number of points in X
# dx = space data step sampling

# Slave parameters (spatial frequency content)
#
# fpx = 1/dx        = frequency space periodicity (Hz)
# lx  = nx*dx       = space period
# dfx = 1/lx        = frequency step
# fmx = 1/dx - 1/lx = maximum frequency
# fnx = 1/(2*dx)    = nx/(2*lx) = Nyquist frequency
#
# Signal X detecting content (Hz) =  dfx < fx < fnx


private = {'login':os.environ.get('BEG_LOGIN'),
            'password':os.environ.get('BEG_PASSWORD'),
            'server':os.environ.get('BEG_SERVER')}


# DATA (07): z(col=0) rho(col=5) VP (col=6) and VS (col=7)

# Well A
dfile = '07-23-36-10.txt'
pgrid = {'nx':7033, 'ny':8, 'ox':155.875, 'dx':0.125, 'col':6}
# VP (6)
fcbpm = {'bp':0.7847, 'fc1':0.6784, 'fc2':1.4850278, 'bp1':6.698, 'bp2':0.349, 'bp3':1.0}
# VS (7)
#fcbpm = {'bp':1.0466, 'fc1':0.5069, 'fc2':1.430250, 'bp1':5.9241, 'bp2':0.2833, 'bp3':1.0}

# Well B
#dfile = '07-26-36-10.txt'
#pgrid = {'nx':7044, 'ny':8, 'ox':157.125, 'dx':0.125, 'col':7}
# VP (6)
#fcbpm = {'bp':1.89926, 'fc1':0.6133, 'fc2':1.681, 'bp1':5.34, 'bp2':1.00, 'bp3':1.0}
# VS (7)
#fcbpm = {'bp':2.84062, 'fc1':0.68047651, 'fc2':1.518522, 'bp1':3.0759, 'bp2':4.5, 'bp3':1.0}


# DATA (04): z(col=0) rho(col=1) VP (col=2) and VS (col=3)

# Well C
#dfile = '04-02-37-10.txt'
#pgrid = {'nx':6921, 'ny':4, 'ox':142.5, 'dx':0.125, 'col':3}
# VP (2)
#fcbpm = {'bp':1.3377, 'fc1':0.5198378, 'fc2':1.854343528, 'bp1':7.21752, 'bp2':0.3, 'bp3':1.0}
# VS (3)
#fcbpm = {'bp':1.246, 'fc1':0.558081343, 'fc2':1.99418703, 'bp1':5.01091, 'bp2':0.352044, 'bp3':1.0}

# Well D
#dfile = '04-13-36-10.txt'
#pgrid = {'nx':7113, 'ny':4, 'ox':161.75, 'dx':0.125, 'col':3}
# VP (2)
#fcbpm = {'bp':0.638323, 'fc1':0.706749585, 'fc2':1.82077179, 'bp1':2.5841, 'bp2':0.19704, 'bp3':1.0}
# VS (3)
#fcbpm = {'bp':0.57290, 'fc1':0.706749585, 'fc2':1.82077179, 'bp1':2.5841, 'bp2':0.19704, 'bp3':1.0}


Fetch(dfile,'apache',private)


Flow('sonic',dfile,
     '''
     echo n1=%(ny)d n2=%(nx)d o2=%(ox)g d2=%(dx)g in=$SOURCE data_format=ascii_float |
     dd form=native | transp |
     window n1=%(nx)d n2=1 f2=%(col)d |
     put label1=Depth unit1=m label2=Velocity unit2=m/s
     ''' % pgrid)

Result('sonic','graph title="Sonic well log"')


# Shift and scale by mean signal


Flow('mscale','sonic','stack axis=1 norm=n | math output="input*%g"' % (1./pgrid['nx']))
Flow('msonic','mscale','spray axis=1 n=%d o=%g' % (pgrid['nx'],pgrid['ox']))
Flow('signal',['sonic','msonic'],'math r=${SOURCES[0]} m=${SOURCES[1]} output="r/m-1."')

Result('signal','graph min1=%g max1=%g title="Sonic log VS - Well 4" label2= unit2=' % (pgrid['ox'],pgrid['ox']+(pgrid['nx']-1.)*pgrid['dx']))


# Discrete Fourier Transform (fft) (k=0,N-1)
#
# S(k*DF) = DL*sum(n=0,N-1) s(n*DL)*exp(-2*i*pi*k*n/N)
# s  = spatial signal
# S  = frequency signal
# N  = points number in space
# DF = frequency sampling step = 1/L
# L  = spatial length of signal = 1/DF
# DL = space sampling step = L/N = 1/(N*DF)
# FM = maximum frequency = 1/DL - 1/L
#
# Symmetry S(-u) = S*(u)
# Periodicity S(ix+NX) = S(ix)
# Physical vectors (k=0,N-1)
# S(N-1) = S(-1) = S*(1)
# S(N-2) = S(-2) = S*(2)
# ...
# S(N/2+1) = S(-N/2-1) = S*(N/2-1)
# S(N/2)   = S(-N/2)   = S*(N/2)
#
# Dimension in Fourier space [0,nx/2] is nx/2+1
# [fx] = dfx*(-nx/2+1:1:nx/2)


Flow('fsignal','signal','fft1 sym=y')
Flow('rfsignal','fsignal','add abs=y | real | put label1=f unit1=1/m label2= unit2=')

Result('rfsignal','graph min1=0. min2=0. max1=1. max2=2.5 title="Sonic log spectrum"')


# Estimation of stochastic correlation parameters
# -----------------------------------------------
# Estimation of von Karman filter logarithm in spectral domain
# Separate least square on 2 parameters: exponent and amplitude
# Gauss Newton algorithm on nonlinear parameter b*b
# Hu = Hurst exponent > -0.5


Flow('irfsignal','rfsignal','karman verb=y niter=100 x0=.2')

Result('fitfilt','rfsignal irfsignal',
       '''
       cat ${SOURCES[0:2]} axis=2 |
       put label2= unit2= label1=f unit1=1/m | graph min1=0. min2=0. title="Spectrum F(k) estimation"
       ''',stdin=0)


# Logarithmic plot for separable least square inversion method 
# ------------------------------------------------------------


Flow('illbfilt','irfsignal','math output="log(1.+((%g)*x1)^2)"' % (2.*pi*fcbpm['bp']))
Flow('lifsignal','irfsignal','math output="log(input)"')
Flow('lfsignal','rfsignal','math output="log(input)"')

Flow('illsignal','illbfilt lifsignal','cmplx ${SOURCES[0:2]}',stdin=0)
Flow('llsignal','illbfilt lfsignal','cmplx ${SOURCES[0:2]}',stdin=0)

Result('llisignalf','llsignal illsignal',
     '''
     cat ${SOURCES[0:2]} axis=2 |
     put label1='Ln[1+(kb)\^2\_]' unit1= label2='Ln[F(k)]' unit2= |
     graph min1=0. max1=5.3 title="Estimation - VS - Well 4"
     ''',stdin=0)


# Domain restriction for parameters estimation
# --------------------------------------------
# Clipping frequencies f = sqrt(exp( )-1)/(2.*pi*b)
# Convergence for close initial guess 


Flow('rrfsignal','rfsignal','window max1=%g' % (fcbpm['fc1']))

# Flow('rrfsignal','rfsignal','window min1=%g max1=%g' % (fcbpm['fc1'],fcbpm['fc2']))
# Flow('rrfsignal','rfsignal','window min1=%g' % (fcbpm['fc2']))

Flow('irrfsignal','rrfsignal','karman verb=y niter=100 x0=.1')

Result('rfitfilt','rrfsignal irrfsignal',
       '''
       cat ${SOURCES[0:2]} axis=2 |
       put label2= unit2= label1=f unit1=1/m | graph min1=0. min2=0. title="Spectrum F(k) restricted"
       ''',stdin=0)


Flow('irllbfilt','irrfsignal','math output="log(1.+((%g)*x1)^2)"' % (2.*pi*fcbpm['bp1']))

# Flow('irllbfilt','irrfsignal','math output="log(1.+((%g)*x1)^2)"' % (2.*pi*fcbpm['bp2']))
# Flow('irllbfilt','irrfsignal','math output="log(1.+((%g)*x1)^2)"' % (2.*pi*fcbpm['bp3']))

Flow('lirfsignal','irrfsignal','math output="log(input)"')
Flow('lrfsignal','rrfsignal','math output="log(input)"')

Flow('irllsignal','irllbfilt lirfsignal','cmplx ${SOURCES[0:2]}',stdin=0)
Flow('rllsignal','irllbfilt lrfsignal','cmplx ${SOURCES[0:2]}',stdin=0)

Result('rllisignalf','rllsignal irllsignal',
     '''
     cat ${SOURCES[0:2]} axis=2 |
     put label1='Ln[1+(kb)\^2\_]' unit1= label2='Ln[F(k)]' unit2= |
     graph min1=0. title="Restriction - VS - Well 1"
     ''',stdin=0)


# -----------
# Termination
# -----------


End()
