\title{Guide to SLIM programs in RSF}
\email{ghennenfent@eos.ubc.ca}
\author{Gilles Hennenfent}
\lefthead{Hennenfent}
\righthead{SLIM programs in RSF}

\maketitle

\begin{abstract}
  This guide introduces the RSF programs written at the Seismic
  Laboratory for Imaging and Modeling
  (\href{http://slim.eos.ubc.ca}{SLIM}) at the University of British
  Columbia (\href{http://www.ubc.ca}{UBC}) and illustrates their usage
  with examples.
\end{abstract}

\subsection{sfthr: threshold RSF datasets}

\begin{verbatim}
NAME
        sfthr
SYNOPSIS
        sfthr < in.rsf > out.rsf fthr=fthr.rsf thr= fthr= mode=
COMMENTS
        Threshold float/complex inputs given a constant/varying
        threshold level.

        Methods available:
        - soft
        - hard
        - non-negative Garrote (nng)

        Written by: Gilles Hennenfent & Colin Russell, UBC
        Created: February 2006

PARAMETERS
        string  fthr=   varying threshold level (>0) 
        string  mode=   'soft', 'hard', 'nng' (default: soft)
        float   thr=    threshold level (>0)
SOURCE
        user/slim/thr.c
\end{verbatim}

\noindent
Consider the vector $\vector{x}:=\{x_i\}_{0\leq i <m}\in\mathbb{R}^m$.
Soft thresholding is defined as
%
\begin{equation}
\label{eq:soft}
\mathcal{S}_\gamma(\vector{x}):=\{\mbox{sign}(x_i)\cdot
\max(|x_i|-\gamma,0)\}_{0\leq i <m},
\end{equation}
%
with $\gamma$ a positive threshold level. Hard thresholding is defined
as
%
\begin{equation}
\label{eq:hard}
\mathcal{H}_\gamma(\vector{x}):=\{\max(|x_i|-\gamma,0)\cdot x_i\}_{0\leq i <m}.
\end{equation}
%
Finally, non-negative Garrote (nng) thresholding is defined as
%
\begin{equation}
\label{eq:nng}
\mathcal{T}^{nng}_\gamma(\vector{x}):=\{\max(|x_i|-\gamma,0)\cdot 
(x_i-\gamma^2/x_i)\}_{0\leq i <m}.
\end{equation}

\inputdir{sfthr}
\multiplot{4}{data,soft,hard,nng}{width=.45\textwidth}{Thresholding
  example of a line whose range is symmetric about the origin.}

The extension to positive varying threshold level is straightforward
by replacing $\gamma$ by $\gamma_i$ in
Eq.'s~\eqref{eq:soft},\eqref{eq:hard}, and \eqref{eq:nng}.

In RSF, to soft threshold a dataset with a constant, use the following
commands
%
\begin{verbatim}
bash$ sfmath n1=100 n2=1 output='1' | sfnoise rep=y >data.rsf
bash$ sfthr <data.rsf thr=2 >res1.rsf
\end{verbatim}
%
or replace the last command by
%
\begin{verbatim}
bash$ sfthr <data.rsf thr=2 method=soft >res2.rsf
\end{verbatim}
%
This is also equivalent to soft thresholding data.rsf with a vector of
same size mythr.rsf whose entries are all set to 2.
%
\begin{verbatim}
bash$ sfmath n1=100 n2=1 output='2' >mythr.rsf
bash$ sfthr <data.rsf fthr=mythr.rsf method=soft >res3.rsf
\end{verbatim}
%
If thr=.5 and fthr=mythr.rsf are specified at the same time, the
effective threshold level is 1, obtained by multiplying mythr.rsf
entries by 0.5
%
\begin{verbatim}
bash$ sfthr <data.rsf thr=.5 fthr=mythr.rsf method=soft >res4.rsf
\end{verbatim}

\multiplot{4}{data1,soft1,hard1,nng1}{width=.45\textwidth}{Random
  vector thresholding example.}

Note that thresholding is an element-wise operation. \texttt{sfthr}
can thus deal with arbitrarily large datasets.
%
\newpage
\subsection{sfsort: sort RSF vectors}

\begin{verbatim}
NAME
        sfsort
SYNOPSIS
        sfsort < in.rsf > out.rsf memsize=500 ascmode=n
COMMENTS
        Sort in ascending/descending order absolute value entries of a
        float/complex vector.
        
        Written by: Gilles Hennenfent & Henryk Modzelewski, UBC
        Created: February 2006
        
PARAMETERS
        bool    ascmode=n [y/n] y=ascending; n=descending 
        int     memsize=500     Available memory size (in Mb)
SOURCE
        user/slim/sort.c
\end{verbatim}

\noindent
\texttt{sfsort} is useful for sorting RSF vectors either in ascending
or descending order with respect to the absolute value of their
entries. The sorting is done using \texttt{qsort} from stdlib.h. This
function is an implementation of the quicksort algorithm.
\texttt{sfsort} has two modes: 1) in-core if the user-specified
memsize is big enough to load the full dataset in memory and sort it,
and else 2) out-of-core. In the latter case, we implemented a divide
and conquer approach. The large dataset is first divided in pieces
that fit in memory. These pieces are sorted and written to disk in
temporary files. The second step is a merge process of the temporary
files.

\inputdir{sfsort}
\multiplot{3}{datasort,incore,outofcore}{width=.45\textwidth}{Sorting
  example.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 


