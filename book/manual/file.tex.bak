\section{Main operations with RSF files (file.c)}




\subsection{{sf\_file\_error}}
Sets an error on opening files. It sets the value of \texttt{error} (a static variable of type \texttt{bool}). This variable is used in the \texttt{sf\_input\_error} as an if-condition.

\subsubsection*{Call}
\begin{verbatim}sf_file_error(err);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_file_error(bool err)
/*< set error on opening files >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[err] value of type \texttt{bool} which is to be assigned to the static variable \texttt{error}.
\end{desclist}




\subsection{{sf\_error}}
Outputs an error message to the \texttt{stderr} (usually the screen) if the file cannot be opened. The '\texttt{:}' after the format specifiers in the call to \texttt{sf\_error} ensures that any system errors are also included in the output. 

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt message]
   \setlength\itemsep{0pt}
   \item[file]    pointer to the input file structure (\texttt{sf\_file}). 
   \item[message] the error message to be output to \texttt{stderr}. 
   \item[name]    name of the file which was to be opened.    
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
static void sf_input_error(sf_file file, const char* message, const char* name)
{
   if (error) 
       sf_error ("%s: %s %s:",__FILE__,message,name);
   sf_fileclose(file);
}
\end{verbatim}




\subsection{{sf\_input}}
Creates an input file structure and returns a pointer to that file structure. It will create the symbol table, input parameters to the table and write them in a temporary file and check for any errors in the input of the parameters. It will also set the format of the file and then return a pointer to the file structure.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[tag] a tag for the input file (\texttt{const char*}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the input file structure.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
sf_file sf_input (/*@null@*/ const char* tag)
/*< Create an input file structure >*/
{
    int esize;
    sf_file file;
    char *filename, *format;
    size_t len;
    extern off_t ftello (FILE *stream);

   ...

    return file;
}
\end{verbatim}




\subsection{{sf\_output}}
Creates an output file structure and returns a pointer to that file structure. It will create the symbol table, a header file and put the path of the data file in the header with the key "\texttt{in}". 

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[tag] a tag for the output file (\texttt{const char*}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the input file structure.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
sf_file sf_output (/*@null@*/ const char* tag)
/*< Create an output file structure.
---
Should do output after sf_input. >*/
{
    sf_file file;
    char *headname, *dataname, *path, *name, *format;
    size_t namelen;
    extern int mkstemp (char *template);
    extern off_t ftello (FILE *stream);

   ...

    return file;
}
\end{verbatim}




\subsection{{sf\_gettype}}
Returns the type of  the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[file->type] type of the file structure.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
sf_datatype \texttt{sf\_gettype (sf_file file)
/*< return file type >*/
{
    return file->type;
}
\end{verbatim}




\subsection{{sf\_getform}}
Returns the file form, e.g.~\texttt{SF\_ASCII}, \texttt{SF\_XDR}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[file->form] form of the file structure.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
sf_dataform sf_getform (sf_file file)
/*< return file form >*/
{
    return file->form;
}
\end{verbatim}




\subsection{{sf\_esize}}
Returns the size of the element type of the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[size] size in bytes of the type of the file structure.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
size_t sf_esize(sf_file file)
/*< return element size >*/
{
    sf_datatype type;

   ...
}
\end{verbatim}




\subsection{{sf\_settype}}
Sets the type of the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is to be set (\texttt{sf\_file}). 
   \item[type] the type to be set. Must be of type \texttt{sf\_datatype}, e.g.~\texttt{SF\_INT}.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_settype (sf_file file, sf_datatype type)
/*< set file type >*/
{
    file->type = type;
    sf_putint(file,"esize",(int) sf_esize(file));
}
\end{verbatim}




\subsection{{sf\_setpars}}
Changes the parameter table from that of the file to the one which has parameters from the command line.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose parameter table is to be closed (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setpars (sf_file file)
/*< change parameters to those from the command line >*/
{
    char *in;

   ...
}
\end{verbatim}




\subsection{{sf\_bufsiz}}
Returns the size of the buffer associated with the file. It gets the buffer size using the file descriptor of the file and the predefined structure \texttt{stat}. This provides control over the I/O operations, making them more efficient.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose buffer size is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[bufsiz] size of the buffer of the file structure.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
size_t sf_bufsiz(sf_file file)
/*< return buffer size for efficient I/O >*/
{
    size_t bufsiz;
    int filedes;
    struct stat buf;

   ...    
    return bufsiz;
}       
\end{verbatim}




\subsection{{sf\_setform}}
Sets the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR}, \texttt{SF\_NATIVE}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt form]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose form is to be set (\texttt{sf\_file}). 
   \item[form] the type to be set. Must be of type \texttt{sf\_datatype}, e.g.~\texttt{SF\_ASCII}.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setform (sf_file file, sf_dataform form)
/*< set file form >*/
{
    size_t bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_setformat}}
Sets the format of the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc. Format is the combination of file form and its type, e.g.~\texttt{ASCII\_INT}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt format]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose format is to be set (\texttt{sf\_file}). 
   \item[format] the type to be set (\texttt{const char*}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setformat (sf_file file, const char* format)
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/
{
    
   ...
}
\end{verbatim}




\subsection{{sf\_getfilename}}
Returns a boolean value (true or false), depending on whether it was able to find the filename of an open file or not. The search is based on finding the file descriptor of an open file, if it is found the return value is \texttt{true}, otherwise \texttt{false}. Once the file name is found it is copied to the value pointed by the pointer \texttt{filename} which is given as input and is already defined in the \texttt{sf\_input}. 

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt filename]
   \setlength\itemsep{0pt}
   \item[fp] a pointer to the file structure whose file name is required (\texttt{FILE*}).
   \item[filename] pointer to the parameter on which the found file name is to be stored.    
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[success] a boolean value which is true if the filename is found otherwise false.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
static bool getfilename (FILE* fp, char *filename)
/* Finds filename of an open file from the file descriptor.

Unix-specific and probably non-portable. */
{
    DIR* dir;
    struct stat buf;
    struct dirent *dirp;
    bool success;

   ...
    return success;
}
\end{verbatim}




\subsection{{sf\_gettmpdatapath}}
Returns the path of temporary data. It takes no input parameters. The places it looks for the temporary data path are listed in the function definition comment.

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[path] a pointer (of type \texttt{char}) to the value of the \texttt{tmpdatapath}.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
static char* gettmpdatapath (void) 
/* Finds temporary datapath.

Datapath rules:
1. check tmpdatapath= on the command line
2. check TMPDATAPATH environmental variable
3. check .tmpdatapath file in the current directory
4. check .tmpdatapath in the home directory
5. return NULL
*/
{
    char *path, *penv, *home, file[PATH_MAX];
    
   ...
    return NULL;
}
\end{verbatim}




\subsection{{sf\_getdatapath}}
Returns the path of the data. It takes no input parameters. The places it looks for the temporary data path are listed in the function definition comment.

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[path] a pointer (of type char) to the value of the \texttt{datapath}.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
static char* getdatapath (void) 
/* Finds datapath.

Datapath rules:
1. check datapath= on the command line
2. check DATAPATH environmental variable
3. check .datapath file in the current directory
4. check .datapath in the home directory
5. use '.' (not a SEPlib behavior)
*/
{
    char *path, *penv, *home, file[PATH_MAX];
    
   ...
    return path;
}
\end{verbatim}




\subsection{{sf\_readpathfile}}
Returns a boolean value (true or false), depending on whether it was able to find the data path in an open file or not. Once the \texttt{datapath} is found it is copied to the value pointed by the pointer \texttt{datapath} which is given as input and is already defined in the \texttt{sf\_input}. 

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[filename] a pointer to the file name in which datapath is to be found (\texttt{const char}). 
   \item[datapath] pointer to the parameter which is being looked for.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[success] a boolean value which is true if the filename is found otherwise false.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
static bool readpathfile (const char* filename, char* datapath) 
/* find datapath from the datapath file */
{
    FILE *fp;
    char host[PATH_MAX], *thishost, path[PATH_MAX];
   ...
    return true;
}
\end{verbatim}




\subsection{{sf\_fileclose}}
Closes the file and frees any allocated space, like the temporary file and buffer.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file which is to be closed (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_fileclose (sf_file file) 
/*< close a file and free allocated space >*/
{
    if (NULL == file) return;
   ...    
}
\end{verbatim}




\subsection{{sf\_histint}}
Extracts an integer from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. It uses \hyperref[sec:sf_simtab_getint]{\texttt{sf\_simtab\_getint}}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which an integer is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the integer variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the integer was extracted successfully.
   \item[false] a boolean value. It is returned if the integer was not extracted successfully 
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par)
/*< read an int parameter from file >*/ 
{
    return sf_simtab_getint (file->pars,key,par);
}
\end{verbatim}




\subsection{{sf\_histints}}
Extracts an array of integer values from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which an integer array is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the integer array which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the array of integer type value variable where the extracted value is to be copied. 
   \item[n] size of the array to be extracted. Must be of \texttt{size\_t}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the integer type value was extracted successfully.
   \item[false] a boolean value. It is returned if the integer type value was not extracted successfully.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) 
/*< read an int array of size n parameter from file >*/ 
{
    return sf_simtab_getints (file->pars,key,par, n);
}
\end{verbatim}




\subsection{{sf\_histlargeint}}
Extracts a large integer from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. 
It uses \hyperref[sec:sf_simtab_getlargeint]{\texttt{sf\_simtab\_getlargeint}}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a large integer is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the large integer variable where the extracted value is to be copied. Must be of type \texttt{off\_t} which is defined in the header \texttt{<sys/types.h>}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt false]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the large integer was extracted successfully.
   \item[false] a boolean value. It is returned if the large integer was not extracted successfully.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histlargeint (sf_file file, const char* key,/*@out@*/ off_t* par)
/*< read a sf_largeint parameter from file >*/ 
{
    return sf_simtab_getlargeint (file->pars,key,par);
}
\end{verbatim}




\subsection{{sf\_histfloat}}
Extracts a float value from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. 

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a floating point number is to be extracted. Must be of 
type \texttt{sf\_file}.
   \item[key]  the name of the entry which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the float type value variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt false]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the float type value was extracted successfully.
   \item[false] a boolean value. It is returned if the float type value was not extracted successfully.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) 
/*< read a float parameter from file >*/
{
    return sf_simtab_getfloat (file->pars,key,par);
}
\end{verbatim}




\subsection{{sf\_histdouble}}
Extracts a double type value from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. 

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt table]
   \setlength\itemsep{0pt}
   \item[file]  file from which a double type value is to be extracted (\texttt{sf\_file}). 
   \item[table] the table from which the vale has to be extracted. Must be of type \texttt{sf\_simtab}.
   \item[key]   the name of the entry which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]   pointer to the double type value variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the double type value was extracted successfully.
   \item[false] a boolean value. It is returned if the double type value was not extracted successfully.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) 
/*< read a float parameter from file >*/
{
    return sf_simtab_getdouble (file->pars,key,par);
}
\end{verbatim}




\subsection{{sf\_histfloats}}
Extracts an array of float values from the file. If the extraction is successful returns a \texttt{true}. It uses \hyperref[sec:sf_simtab_getfloats]{\texttt{sf\_simtab\_getfloats}}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a float type array is to be extracted (\texttt{sf\_file}). 
   \item[key]  the name of the float array which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the array of float type value variable where the extracted value is to be copied. 
   \item[n]    size of the array to be extracted  (\texttt{size\_t}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histfloats (sf_file file, const char* key,
          /*@out@*/ float* par,   size_t n) 
/*< read a float array of size n parameter from file >*/ 
{
    return sf_simtab_getfloats (file->pars,key,par, n);
}
\end{verbatim}




\subsection{{sf\_histbool}}
Extracts a boolean value from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a bool type value is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the bool variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt false]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the integer was extracted successfully.
   \item[false] a boolean value. It is returned if the integer was not extracted successfully 
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) 
/*< read a bool parameter from file >*/
{
    return sf_simtab_getbool (file->pars,key,par);
}
\end{verbatim}




\subsection{{sf\_histtbools}}
Extracts an array of bool values from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}.It uses \hyperref[sec:sf_simtab_getbools]{\texttt{sf\_simtab\_getbools}}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which an array of bool  value is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the bool array which has to be extracted. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the array of bool type value variable where the extracted value is to be copied. 
   \item[n]    size of the array to be extracted. Must be of \texttt{size\_t}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt false]
   \setlength\itemsep{0pt}
   \item[true]  a boolean value. It is returned if the float type value was extracted successfully.
   \item[false] a boolean value. It is returned if the float type value was not extracted successfully.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histbools (sf_file file, const char* key,
                   /*@out@*/ bool* par, size_t n) 
/*< read a bool array of size n parameter from file >*/ 
{
    return sf_simtab_getbools (file->pars,key,par, n);
}
\end{verbatim}




\subsection{{sf\_histstring}}
Extracts a string pointed by the input key from the file. If the value is \texttt{NULL} it will return \texttt{NULL}, otherwise it will allocate a new block of memory of \texttt{char} type and copy the memory block from the table to the new block and return a pointer to the newly allocated block of memory. It uses \hyperref[sec:sf_simtab_getstring]{\texttt{sf\_simtab\_getstring}}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a string is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the string which has to be extracted. Must be of the type \texttt{const char*}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[string] a pointer to allocated block of memory containing a string of characters. 
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
char* sf_histstring (sf_file file, const char* key) 
/*< read a string parameter from file (returns NULL on failure) >*/ 
{
    return sf_simtab_getstring (file->pars,key);
}
\end{verbatim}




\subsection{{sf\_fileflush}}
Outputs the parameters from source file to the output file. It sets the data format in the output file and prepares the file for writing binary data.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] pointer to the output file (\texttt{sf\_file}). 
   \item[src]  a pointer to the input file structure (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_fileflush (sf_file file, sf_file src)
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/ 
{
    time_t tm;
    char line[BUFSIZ];
...

}
\end{verbatim}




\subsection{{sf\_putint}}
Enters an integer value in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input. Must be of the type \texttt{const char*}.
   \item[par]  integer parameter which is to be written.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putint (sf_file file, const char* key, int par)
/*< put an int parameter to a file >*/
{
    char val[256];

    snprintf(val,256,"%d",par);
    sf_simtab_enter (file->pars,key,val);
}
\end{verbatim}




\subsection{{sf\_putints}}
Enters an array of integer values in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input. Must be of the type \texttt{const char*}.
   \item[par]  pointer to integer parameter array which is to be written. 
   \item[n]    size of the array to be written (\texttt{size\_t}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putints (sf_file file, const char* key, const int* par, size_t n)
/*< put an int array of size n parameter to a file >*/
{
    int i;
    char val[1024], *v;

    v = val;
    for (i=0; i < n-1; i++) {
        v += snprintf(v,1024,"%d,",par[i]);
    }
    snprintf(v,1024,"%d",par[n-1]);

    sf_simtab_enter (file->pars,key,val);
}
\end{verbatim}



\subsection{{sf\_putlargeint}}
Enters a long integer value in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input. Must be of the type \texttt{const char*}.
   \item[par]  integer parameter which is to be written.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putlargeint (sf_file file, const char* key, off_t par)
/*< put a sf_largeint parameter to a file >*/
{
    char val[256];

    snprintf(val,256,"%lld",(long long int) par);
    sf_simtab_enter (file->pars,key,val);
}
\end{verbatim}




\subsection{{sf\_putfloat}}
Enters a float value in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input. Must be of the type \texttt{const char*}.
   \item[par]  floating point parameter which is to be written.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putfloat (sf_file file, const char* key,float par)
/*< put a float parameter to a file >*/
{
    char val[256];

    snprintf(val,256,"%g",par);
    sf_simtab_enter (file->pars,key,val);
}
\end{verbatim}




\subsection{{sf\_putstring}}
Enters a string in to the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input. Must be of the type \texttt{const char*}.
   \item[par]  pointer to the string parameter which is to be written.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putstring (sf_file file, const char* key,const char* par)
/*< put a string parameter to a file >*/
{
    char *val;
    
    val = (char*) alloca(strlen(par)+3); 
    sprintf(val,"\"%s\"",par);
    sf_simtab_enter (file->pars,key,val);
}
\end{verbatim}




\subsection{{sf\_putline}}
Enters a string line in to the file.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt line]
   \setlength\itemsep{0pt}
   \item[file] the file in which the string line is to be stored (\texttt{sf\_file}). 
   \item[line] pointer to the which is to be written. 
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putline (sf_file file, const char* line)
/*< put a string line to a file >*/
{
    if (0 >= fprintf(file->stream,"\t%s\n",line))
        sf_error ("%s: cannot put line '%s':",__FILE__,line);
}
\end{verbatim}




\subsection{{sf\_setaformat}}
Sets number format specifiers for ASCII output. This can be used in \texttt{sf\_complexwrite}, for example.  

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt format]
   \setlength\itemsep{0pt}
   \item[format] a number format, e.g.~\%5g. 
   \item[line]   numbers in the ASCII line.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
                    int line /* numbers in line */ )
/*< Set format for ascii output >*/
{
    size_t len;

...    
}
\end{verbatim}




\subsection{{sf\_complexwrite}}
Writes a complex array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_complexwrite (sf_complex* arr, size_t size, sf_file file)
/*< write a complex array arr[size] to file >*/
{
    char* buf;
    size_t i, left, nbuf, bufsiz;
    sf_complex c;

   ...
}
\end{verbatim}




\subsection{{sf\_complexread}}
Reads a complex array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_complexread (/*@out@*/ sf_complex* arr, size_t size, sf_file file)
/*< read a complex array arr[size] from file >*/
{
    char* buf;
    size_t i, left, nbuf, got, bufsiz;
    float re, im;

   ...
}
\end{verbatim}




\subsection{{sf\_charwrite}}
Writes a character array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_charwrite (char* arr, size_t size, sf_file file)
/*< write a char array arr[size] to file >*/
{
    char* buf;
    size_t i, left, nbuf, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_uncharwrite}}
Writes a unsigned character array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file)
/*< write an unsigned char array arr[size] to file >*/
{
    char* buf;
    size_t i, left, nbuf, bufsiz;

...
}
\end{verbatim}




\subsection{{sf\_charread}}
Reads a character array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file)
/*< read a char array arr[size] from file >*/
{
    char* buf;
    size_t i, left, nbuf, got, bufsiz;
    int c;

   ...
}
\end{verbatim}




\subsection{{sf\_uncharread}}
Reads an unsigned character array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file)
/*< read a uchar array arr[size] from file >*/
{
    char* buf;
    size_t i, left, nbuf, got, bufsiz;
    int c;

   ...
}
\end{verbatim}




\subsection{{sf\_intwrite}}
Writes an integer array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_intwrite (int* arr, size_t size, sf_file file)
/*< write an int array arr[size] to file >*/
{
    char* buf;
    size_t i, left, nbuf, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_intread}}
Reads an integer array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file)
/*< read an int array arr[size] from file >*/
{
    char* buf;
    size_t i, left, nbuf, got, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_shortread}}
Reads an short array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[arr ] a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_shortread (/*@out@*/ short* arr, size_t size, sf_file file)
/*< read a short array arr[size] from file >*/
{
    char* buf;
    size_t i, left, nbuf, got, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_shortwrite}}
Writes an short array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_shortwrite (short* arr, size_t size, sf_file file)
/*< write a short array arr[size] to file >*/
{
    char* buf;
    size_t i, left, nbuf, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_floatwrite}}
Writes an float array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_floatwrite (float* arr, size_t size, sf_file file)
/*< write a float array arr[size] to file >*/
{
    char* buf;
    size_t i, left, nbuf, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_floatread}}
Reads a float array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file)
/*< read a float array arr[size] from file >*/
{
    char* buf;
    size_t i, left, nbuf, got, bufsiz;

   ...
}
\end{verbatim}




\subsection{{sf\_bytes}}
Returns the size of the file in bytes.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose size is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[size] the size of the file structure in bytes.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
off_t sf_bytes (sf_file file)
/*< Count the file data size (in bytes) >*/
{
    int st;
    off_t size;
    struct stat buf;
    
   ...
}
\end{verbatim}




\subsection{{sf\_tell}}
Returns the current value of the position indicator of the file.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure the value of whose position indicator required (\texttt{sf\_file}).
\end{desclist}                 

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[] Current value of the position indicator of the file. It is of type \texttt{off\_t}.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
off_t sf_tell (sf_file file)
/*< Find position in file >*/
{
    extern off_t ftello (FILE *stream);
    return ftello(file->stream);
}
\end{verbatim}




\subsection{{sf\_tempfile}}
Creates a temporary file with a unique file name.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt dataname]
   \setlength\itemsep{0pt}
   \item[dataname] a pointer to the value of the name of the temporary file (\texttt{char**}).
   \item[mode] mode of the file to be created, e.g.~\texttt{w+}.
 \end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[tmp] a pointer to the temporary file.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
FILE *sf_tempfile(char** dataname, const char* mode)
/*< Create a temporary file with a unique name >*/
{
    FILE *tmp;
    char *path;
    extern FILE * fdopen (int fd, const char *mode);
    extern int mkstemp (char *template);
    
   ...
    return tmp;
}
\end{verbatim}




\subsection{{sf\_seek}}

\subsubsection*{Definition}
\begin{verbatim}
void sf_seek (sf_file file, off_t offset, int whence)
/*< Seek to a position in file. Follows fseek convention. >*/
{
    extern int fseeko(FILE *stream, off_t offset, int whence);

    if (0 > fseeko(file->stream,offset,whence))
        sf_error ("%s: seek problem:",__FILE__);
}
\end{verbatim}




\subsection{{sf\_unpipe}}
Redirects a pipe input to a directly accessible file.

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure which is to be unpiped (\texttt{sf\_file}).
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_unpipe (sf_file file, off_t size) 
/*< Redirect a pipe input to a direct access file >*/
{
    off_t nbuf, len, bufsiz;
    char *dataname=NULL;
    FILE* tmp;
    char *buf;

   ...
} 
\end{verbatim}



\subsection{{sf\_unpipe}}
Redirects a pipe input to a directly accessible file.

\subsubsection*{Definition}
\begin{verbatim}
void sf_close(void)
/*< Remove temporary files >*/
{
    int i;
    sf_file file;

   ...   
}
\end{verbatim}




