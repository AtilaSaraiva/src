\author{Sir Charles Antony Richard Hoare}
%%%%%%%%%%%%%%%%%%%%%
\title{Homework 2}

\begin{abstract}
  This homework has four parts. 
  \begin{enumerate}
  \item Theoretical and programming questions related to data attributes and digital convolution.  
  \item Measuring the performance of sorting algorithms.
  \item Analyzing a digital elevation map by applying a running average filter.
  \item Analyzing a digital elevation map by applying derivative filters.
  \end{enumerate}
\end{abstract}

\section{Prerequisites}

Completing the computational part of this homework assignment requires
\begin{itemize}
\item \texttt{Madagascar} software environment available from \\
\url{http://www.ahay.org/}
\item \LaTeX\ environment with \texttt{SEG}\TeX\ available from \\ 
\url{http://www.ahay.org/wiki/SEGTeX}
\end{itemize}
To do the assignment on your personal computer, you need to install
the required environments. 

The homework code is available from the \texttt{Madagascar} repository
by running
\begin{verbatim}
svn co http://svn.code.sf.net/p/rsf/code/trunk/book/geo391/hw2
\end{verbatim}

\section{Data attributes and digital convolution}

You can either write your answers to theoretical questions on paper or
edit them in the file \texttt{hw2/paper.tex}. Please show all the
mathematical derivations that you perform.

\begin{enumerate}

\item The varimax attribute is defined as
\begin{equation}
  \label{eq:varimax}
\phi[\mathbf{a}] = \frac{\displaystyle N\,\sum\limits_{n=1}^N
  a_n^4}{\displaystyle \left(\sum\limits_{n=1}^{N} a_n^2\right)^2}
\end{equation}

Suppose that the data vector $\mathbf{a}$ consists of random noise:
the data values $a_n$ are independent and identically distributed with
a zero-mean Gaussian distribution: $E[a_n]=0$, $E[a_n^2]=\sigma^2$,
$E[a_n^4]=3\,\sigma^4$. Find the mathematical expectation of
$\phi[\mathbf{a}]$.

\item The matrix in equation~(\ref{eq:conv}) represents a convolution operator with zero boundary conditions.
\begin{equation}
\label{eq:conv}
\mathbf{F} = \left[\begin{array}{llllll}
f_1 & f_0 & 0   & 0   & 0   & 0   \\
f_2 & f_1 & f_0 & 0   & 0   & 0   \\
f_3 & f_2 & f_1 & f_0 & 0   & 0   \\
0   & f_3 & f_2 & f_1 & f_0 & 0   \\
0   & 0   & f_3 & f_2 & f_1 & f_0 \\
0   & 0   & 0   & f_3 & f_2 & f_1 \\
\end{array}\right]\;.
\end{equation}

The operator is implemented in the C function \texttt{hw2/conv.c}.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=15,title=hw2/conv.c]{conv.c}

\begin{enumerate}
\item Modify the matrix and the program to implement periodic boundary conditions.
\item Add the code for the adjoint (matrix transpose) operator.
\end{enumerate}

\item The C code in \texttt{hw2/filter.c} implements a recursive filtering
  operator.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=13,title=hw2/filter.c]{filter.c}

\begin{enumerate}
\item Express this filter in the $Z$-transform notation as a ratio
  of two polynomials.
\item Add code for the adjoint operator.
\end{enumerate}

\end{enumerate}

\section{Sorting algorithms}
\inputdir{sorting}

\begin{enumerate}          
\item Change directory to \texttt{hw2/sorting}.
\item Run
\begin{verbatim}
scons movie.vpl
\end{verbatim}
and observe a movie illustrating the slow data sorting algorithm. The
algorithm is implemented in the \texttt{slow\_sort} function in the
file \texttt{sorting.c}.

\item Run
\begin{verbatim}
scons view
\end{verbatim}
to compute the cost of slow sorting experimentally. The output is
shown in Figure~\ref{fig:cost}.

\sideplot{cost}{width=\textwidth}{Experimental cost of slow sorting. 
The logarithm of the cost is shown against the logarithm of the data size.}

If we approximate the cost as $P(N)=C\,N^\epsilon$, what is the value of
$\epsilon$ observed in the picture?

\item Open the file \texttt{sorting.c} in a text editor and edit it to 
fix the specified line in the \texttt{quick\_sort} function.

\item Open the file \texttt{SConstruct} in a text editor and uncomment 
      the specified line.

\item Rerun
\begin{verbatim}
scons movie.vpl
\end{verbatim}
to observe a change in the sorting movie. Debug your changes to the
program if necessary.

\item Run
\begin{verbatim}
scons view
\end{verbatim}
to observe the change in the algorithm cost. What is the new
experimental value of $\epsilon$?

\item \textbf{EXTRA CREDIT} for
further improving the speed of the 
\texttt{quick\_sort} algorithm.
\end{enumerate}

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,title=sorting/sorting.c]{sorting/sorting.c}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,title=sorting/SConstruct]{sorting/SConstruct}

\section{Running median and running mean filters}
\inputdir{running}

\sideplot{dem}{width=0.9\textwidth}{Digital elevation map of the 
west Austin area.}

In this part of the homework, we will analyze the digital elevation map of the West Austin Area, shown in Figure~\ref{fig:dem}. Our task is to separate the data into ``signal'' and
``noise'' by applying running mean and median filters.  The result of
applying a running median filter is shown in
Figure~\ref{fig:ave,res}. Running median effectively smooths the data
by removing local outliers.

\multiplot{2}{ave,res}{width=0.45\textwidth}{Data separated into
  signal (a) and noise (b) by applying a running median filter.}

The algorithm is implemented in program \texttt{running.c}.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,title=running/running.c]{running/running.c}

\begin{enumerate}
\item Change directory to \texttt{hw2/running}.
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Modify the \texttt{running.c} program and the
  \texttt{SConstruct} file to compute running mean instead of running
  median. Compare the results.
\item \textbf{EXTRA CREDIT} for improving the efficiency of the
  running median algorithm. Run
\begin{verbatim}
scons time.vpl
\end{verbatim}
  to display a figure that compares the efficiency of running median
  computations using the slow sorting from function \texttt{median} in
  program \texttt{running.c} and the fast quantile algorithm (library
  function \texttt{sf\_quantile} ). Your goal is to make the algorithm
  even faster. You may consider parallelization, reusing previous windows,
  other fast sorting strategies, etc.
\end{enumerate}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,title=running/SConstruct]{running/SConstruct}

\section{Derivative filters}
\inputdir{helix}

In this part of the assignment, we return to the digital elevation map
of the of the of the Mount St. Helens area, shown in
Figure~\ref{fig:data}.

\sideplot{data}{width=\textwidth}{Digital elevation map of Mount St. Helens area.}

Figure~\ref{fig:der} shows a directional derivative, a digital approximation to
\begin{equation}
\label{eq:der}
\cos{\alpha}\,\frac{\partial}{\partial x_1} + \sin{\alpha}\,\frac{\partial}{\partial x_2}\;,
\end{equation}
applied to the data. A directional derivative highlights the structure
of the mountain as if illuminating it with a light source.

\sideplot{der}{width=\textwidth}{Directional derivative of elevation.}

Figure~\ref{fig:helder} shows an application of \emph{helical
derivative}, a filter designed by spectral factorization of the
Laplacian filter
\begin{equation}
\label{eq:lap4}
L(Z_1,Z_2) = 4 - Z_1 - 1/Z_1 - Z_2 - 1/Z_2\;.
\end{equation}
To invert the Laplacian filter, we put on a helix, where it takes
the form
\begin{equation}
\label{eq:lap1}
L_H(Z) = 4 - Z - Z^{-1} - Z^{N_1} - Z^{-N_1}\;,
\end{equation} 
and factor it into two minimum-phase parts $L_H(Z) = D(Z)\,D(1/Z)$
using the Wilson-Burg algorithm. The helical derivative $D(Z)$
enhances the image but does not have a preferential direction.

\sideplot{helder}{width=\textwidth}{Helix derivative of elevation.}

\begin{enumerate}
\item Change directory to \texttt{hw2/helix}.
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Edit the \texttt{SConstruct} file. Find the parameter that corresponds to $\alpha$ in equation~(\ref{eq:der}) and try to modify it until you create the most interesting image. After changing the parameter, you can view the result by running
\begin{verbatim}
scons der.view
\end{verbatim}
\item \textbf{EXTRA CREDIT} for suggesting and implementing a method for finding optimal $\alpha$ automatically.
\item A more accurate version of the Laplacian filter is
\begin{eqnarray}
\nonumber
\hat{L}_2(Z_1,Z_2) = 20 & - & 4\,Z_1 - 4\,Z_1^{-1} - 4\,Z_2 - 4\,Z_2^{-1} \\
&  & - Z_1\,Z_2 - Z_1\,Z_2^{-1} - Z_2\,Z_1^{-1} - Z_1^{-1}\,Z_2^{-1}\;.
\label{eq:lap9}
\end{eqnarray}
Modify the \texttt{SConstruct} file to use filter~(\ref{eq:lap9}) instead of~(\ref{eq:lap4}).
\item  \textbf{EXTRA CREDIT} An even more accurate version of the Laplacian filter involves polynomial division in addition to polynomial multiplication. Find the coefficient for the polynomial division and modify the \texttt{SConstruct} file to implement the corresponding helical derivative.
\end{enumerate}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,title=helix/SConstruct]{helix/SConstruct}

%\newpage

\section{Completing the assignment}

\begin{enumerate}
\item Change directory to \texttt{hw2}.
\item Edit the file \texttt{paper.tex} in your favorite editor and change the
  first line to have your name instead of Hoare's.
\item Run
\begin{verbatim}
sftour scons lock
\end{verbatim}
to update all figures.
\item Run
\begin{verbatim}
sftour scons -c
\end{verbatim}
to remove intermediate files.
\item Run
\begin{verbatim}
scons pdf
\end{verbatim}
to create the final document.
\item Submit your result (file \texttt{paper.pdf}) on paper or by
e-mail.
\end{enumerate}
