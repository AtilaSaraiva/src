\author{Robert Keys}
%%%%%%%%%%%%%%%%%%%%
\title{Homework 3 \\ Due in class on Tuesday, November 2}

\begin{abstract}
  This homework has five parts. 
  \begin{enumerate}
  \item Theoretical questions related to digital filtering.
  \item Data interpolation after coordinate transformation.
  \item Analyzing data by applying a running median filter.
  \item Analyzing data by applying Fourier compression.
  \item Applying one of these algorithms to your own data.
  \end{enumerate}
\end{abstract}

\section{Filter design}

You can either write your answers on paper or edit them in the file
\verb#hw3/paper.tex#. Please show all the mathematical
derivations that you perform.

\begin{enumerate}

\item The Taylor series expansion of the inverse sine function around zero is
\begin{equation}
  \label{eq:arcsin}
  \arcsin{x} = x + \frac{1}{2}\,\frac{x^3}{3} + 
  \frac{1 \cdot 3}{2 \cdot 4}\,\frac{x^5}{5} + 
  \frac{1 \cdot 3 \cdot 5}{2 \cdot 4 \cdot 6}\,\frac{x^7}{7} + 
  \cdots
\end{equation}
\begin{enumerate}
\item Show how one can use expansion~(\ref{eq:arcsin}) to design a
  digital filter that approximates the derivative
  operator. \textbf{Hint:} use the identity $Z-1/Z =
  2\,i\,\sin{\omega}$ for $Z = \exp{(i\,\omega)}$.
\item In particular, find a seven-point derivative filter of the form
\begin{equation}
  \label{eq:d6}
  D(Z) = d_{-3}/Z^{3} + d_{-2}/Z^{2} + d_{-1}/Z + d_0 + 
  d_1\,Z + d_2\,Z^2 + d_3\,Z^3\;.
\end{equation}
\end{enumerate}

\item The Taylor series expansion of $Z^s$ around $Z=1$ is
\begin{equation}
  \label{eq:zs}
  Z^s = 1 + s\,(Z-1) + \cdots  
\end{equation}
\begin{enumerate}
\item The first term in expansion~(\ref{eq:zs}) can be used to
  define nearest-neighbor interpolation. The first two terms can be
  used to define linear interpolation. Going to a larger number of
  terms corresponds to \emph{Lagrangian} interpolation. Define a
  three-point interpolation filter using the first three terms of
  expansion~(\ref{eq:zs}).
\item Define a recursive interpolation filter of the form
\begin{equation}
  \label{eq:rec}
  Z^s \approx R(Z) = \frac{a_0(s) + a_1(s)\,Z}{1 + b_1(s)\,Z}
\end{equation}
by expanding it in a Taylor series around $Z=1$ and comparing this
series with expansion~(\ref{eq:zs}).
\end{enumerate}

\item Consider the parabolic filter $F(Z)$ defines as
\begin{equation}
\label{eq:parab}
F(Z) = 1 + 4 Z + 9 Z^2 + \ldots + N^2 Z^{N-1}\;.
\end{equation} 

\begin{enumerate}
\item Show that this filter can be implemented with recursive filtering (polynomial division).
\item What is the advantage of recursive filtering? Does it depend on $N$?
\end{enumerate}

\item The matrix in equation~(\ref{eq:conv}) represents a convolution operator with zero boundary conditions.
\begin{equation}
\label{eq:conv}
\mathbf{F} = \left[\begin{array}{llllll}
f_1 & f_0 & 0   & 0   & 0   & 0   \\
f_2 & f_1 & f_0 & 0   & 0   & 0   \\
f_3 & f_2 & f_1 & f_0 & 0   & 0   \\
0   & f_3 & f_2 & f_1 & f_0 & 0   \\
0   & 0   & f_3 & f_2 & f_1 & f_0 \\
0   & 0   & 0   & f_3 & f_2 & f_1 \\
\end{array}\right]\;.
\end{equation}

The operator is implemented in the C code below.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=15]{conv.c}

\begin{enumerate}
\item Modify the matrix and the program to implement periodic boundary conditions.
\item Add the code for the adjoint (matrix transpose) operator.
\end{enumerate}

\item The following C code (included in \texttt{filter.c} file in
  directory \texttt{geo391/hw3}) implements a recursive filtering
  operator.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=13]{filter.c}

\begin{enumerate}
\item Express this filter in the $Z$-transform notation as a ratio
  of two polynomials.
\item Add code for the adjoint operator.
\end{enumerate}

\item The parabolic B-spline $\beta_3(x)$ is a function defined as
 \begin{equation}
   \label{eq:b3} 
   \beta_3(x) = \int\limits_{-\infty}^{\infty} \beta_2(t)\,\beta_1(x-t)\,d t\;,
\end{equation}
where
\begin{equation}
   \label{eq:b1}
   \beta_1(x) = \left\{\begin{array}{lcl} 1 & \quad\mbox{for}\quad & |x| \le 1/2 \\
       0 &\quad \mbox{for}\quad& |x| > 1/2\end{array}\right.
 \end{equation}
and
\begin{equation}
  \label{eq:b2} 
   \beta_2(x) = \int\limits_{-\infty}^{\infty} \beta_1(t)\,\beta_1(x-t)\,d t\;
   = \left\{\begin{array}{lcl} 1-|x| &\quad \mbox{for}\quad& |x| \le 1 \\
       0 & \quad \mbox{for}\quad&  |x| > 1\end{array}\right.
\end{equation}

\begin{enumerate}
\item Find an explicit expression for $\beta_3(x)$.
\item Show that decomposing a continuous data function $d(x)$ into the convolution basis 
  with parabolic B-spines
  \begin{equation}
    \label{eq:basis} 
    d(x) = \sum\limits_k c_k\,\beta_3(x-k)
  \end{equation}
  leads to an interpolation filter of the form
  \begin{equation}
    \label{eq:bz}
    Z^s \approx B_3(Z) = \frac{a_0(s)/Z + a_1(s) + a_2(s)\,Z}{b_0/Z + b_1 + b_2\,Z}\;.
  \end{equation}
  Define $a_0(s)$, $a_1(s)$, $a_2(s)$, $b_0$, $b_1$, and $b_2$.
\end{enumerate}

\end{enumerate}

\section{Interpolation after coordinate transformation}
\inputdir{rotate}

In this exercise, we will use a slice out of a 3-D CT-scan of a
carbonate rock sample, shown in
Figure~\ref{fig:circle}\footnote{Courtesy of Jim Jennings
  (currently at Shell.)}. Notice microfracture channels.

\multiplot{2}{circle,rotate}{width=0.45\textwidth}{Slice of a CT-scan
  of a carbonate rock sample. (a) Original. (b) After clockwise rotation
  by $90^{\circ}$.}

The goal of the exercise is to apply a coordinate transformation to
the original data. A particular transformation that we will study is
coordinate rotation. Figure~\ref{fig:rotate} shows the original slice
rotated by 90 degrees. A 90-degree rotation in this case amounts to
simple transpose. However, rotation by a different angle requires
interpolation from the original grid to the modified grid.

The task of coordinate rotation is accomplished by the C program
\texttt{rotate.c}, included below. Two different methods are implemented: 
nearest-neighbor interpolation and bilinear interpolation. In the
$Z$-transform notation, the nearest neighbor interpolation corresponds
to the filter
\begin{equation}
\label{eq:nearest}
Z^s \approx N(Z) = 1
\end{equation}
while linear interpolation corresponds to the filter
\begin{equation}
\label{eq:linear}
Z^s \approx L(Z) = 1-s + s\,Z\;.
\end{equation}
To test the accuracy of different methods, we can rotate the original
data in small increments and then compare the result of rotating to
$360^{\circ}$ with the original data. Figure~\ref{fig:nearest,linear}
compares the error of the nearest-neighbor and bilinear interpolations
after rotating the original slice in increments of $20^{\circ}$. The
accuracy is comparatively low for small discontinuous features like
microfracture channels.

To improve the accuracy further, one needs to employ a longer
filter. One popular choice is \emph{cubic convolution} interpolation,
invented by Robert Keys (a geophysicist, currently at ConocoPhillips).
The cubic convolution filter can be expressed as the filter
\begin{eqnarray}
\nonumber
Z^s \approx C(Z) & = & -\frac{s\,(1-s)^2}{2}\,Z^{-1} + \frac{(1-s)\,(2 + 2\,s - 3 s^2)}{2} + \\
&  & \frac{s\,(1 + 4\,s - 3\,s^2)}{2}\,Z - \frac{(1-s)\,s^2}{2}\,Z^2\;.
\label{eq:cubic}
\end{eqnarray}
and is designed to approximate the ideal sinc-function interpolator.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=19]{rotate/rotate.c}

\multiplot{3}{nearest,linear}{width=0.45\textwidth}{Error of different
  interpolation methods computed after full circle rotation in
  increments of 20 degrees. (a) Nearest-neighbor interpolation. (b)
  Bi-linear interpolation.}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single]{rotate/SConstruct}

Your task:
\begin{enumerate}
\item Change directory to \verb#geo391/hw3/rotate#
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Additionally, you can run
\begin{verbatim}
scons nearest.vpl
\end{verbatim}
and
\begin{verbatim}
scons linear.vpl
\end{verbatim}
to see movies of incremental slice rotation with different methods.
\item Modify the \texttt{rotate.c} program and the \texttt{SConstruct} file to implement the cubic convolution interpolation and to compare 
its results with the two other methods.
\item \textbf{EXTRA CREDIT} for implementing an interpolation algorithm, which is more accurate than cubic convolution.
\end{enumerate}

\section{Running median and running mean filters}
\inputdir{running}

\plot{bay}{width=\textwidth}{Digital elevation map of the San Francisco
  Bay Area.}

We return the digital elevation map of the San Francisco Bay Area, shown in Figure~\ref{fig:bay}.

In this exercise, we will separate the data into ``signal'' and
``noise'' by applying running mean and median filters.  The result of
applying a running median filter is shown in
figure~\ref{fig:med,res}. Running median effectively smooths the data
by removing local outliers.

\multiplot{2}{med,res}{width=0.45\textwidth}{Data separated into signal (a) and noise (b) by applying a running median filter.}

%\plot{time}{width=\textwidth}{CPU time for computing the running median with different algorithms as a function of the window size. 
%The dashed line corresponds to slow sorting in program \texttt{running.c}, the solid line corresponds to the fast \emph{quantile} algorithm.}

The algorithm is implemented in program \texttt{running.c}.

\lstinputlisting[frame=single]{running/running.c}

\begin{enumerate}
\item Change directory to \verb#geo391/hw2/running#
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Modify the \texttt{running.c} program and the \texttt{SConstruct} file to compute running mean instead of running median. Compare the results.
\item \textbf{EXTRA CREDIT} for improving the efficiency of the running median algorithm. Run
\begin{verbatim}
scons time.vpl
\end{verbatim}
to display a figure that compares the efficiency of running median computations using the slow sorting from function \texttt{median} in program \texttt{running.c} and the fast quantile algorithm (library function \verb#sf_quantile# ). Your goal is to make the algorithm even faster. Consider parallelization, reusing previous window results, other fast sorting strategies, etc.
\end{enumerate}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single]{running/SConstruct}

\section{Fourier compression}
\inputdir{fourier}

\plot{fft}{width=\textwidth}{Absolute value of the Fourier transform of the digital elevation data. The frame inside shows a window selected for compression.}

The goal of your next assignment is to find a compressed
representation of the data in the Fourier transform
domain. Figure~\ref{fig:fft} shows the Fourier transform of the
digital elevation data from Figure~\ref{fig:bay}. We can see that most
of the energy gets concentrated near the center (zero frequency). 

There are two alternative ways to compress data in the Fourier domain:
\begin{itemize}
\item One approach is to
select a range of frequencies that contain the most important
information. An advantage of this approach is the ability to subsample
the original data by transforming back from a windowed range of frequencies.
The results from this method are shown in Figure~\ref{fig:sig,cut}.
\item Another approach is to zero all Fourier coefficients below a certain threshold value, regardless of which frequencies they represent.  
 The results from this method are shown in Figure~\ref{fig:thr,noi}. Figure~\ref{fig:hist} shows a selected threshold plotted against the histogram of Fourier coefficients.
\end{itemize}

\multiplot{2}{sig,cut}{width=0.45\textwidth}{Data separated into signal (a) and noise (b) by applying Fourier compression with windowing.}
\multiplot{2}{thr,noi}{width=0.45\textwidth}{Data separated into signal (a) and noise (b) by applying Fourier compression with thresholding.}

\sideplot{hist}{width=0.8\textwidth}{Normalized histogram of Fourier coefficients (by absolute value). The vertical line shows a selected threshold.}

\begin{enumerate}
\item Change directory to \verb#geo391/hw2/fourier#
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Modify the \texttt{SConstruct} file to decrease the size of the window so that the noise level increases in Figure~\ref{fig:cut}. How do you measure the noise level? Find a level that you find negligibly small.
\item Modify the \texttt{SConstruct} file to increase the threshold value so that the compression achieves the same quality as in the previous case. The noise level in Figure~\ref{fig:noi} should match that in Figure~\ref{fig:cut}.
\item Compare the number of nonzero Fourier coefficients in both cases. Which method achieves a better compression?
\item \textbf{EXTRA CREDIT} for finding a way for a better compression of the data in the Fourier domain. Your data reconstruction should have 
the same noise level, yet the number of non-zero coefficients in the Fourier domain should be smaller.
\end{enumerate}

\lstinputlisting[frame=single]{fourier/SConstruct}

\section{Your own data}

Your final task is to apply one of the data analysis techniques of the
previous sections to your own data:
\begin{enumerate}
\item Select a dataset suitable for interpolation by POCS or for
  coordinate transformation.
\item Apply one the algorithm of the previous two sections and choose
  appropriate parameters.
\item Include the results in your homework.
\end{enumerate}

\section{Completing the assignment}

\begin{enumerate}
\item Change directory to \verb#geo391/hw3#.
\item Edit the file \texttt{paper.tex} in your favorite editor and change the
  first line to have your name instead of Keys's.
\item Run
\begin{verbatim}
sftour scons lock
sftour scons -c
\end{verbatim}
and
\begin{verbatim}
scons pdf
\end{verbatim}
\item Submit your result (file \texttt{paper.pdf}) by printing it out
  or by e-mail.
\end{enumerate}

\nocite{keys}

\bibliographystyle{seg}
\bibliography{hw3}
