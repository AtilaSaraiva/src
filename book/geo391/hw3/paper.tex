\author{Robert Keys}
%%%%%%%%%%%%%%%%%%%%
\title{Homework 3}

\begin{abstract}
  This homework has four parts. 
  \begin{enumerate}
  \item Theoretical questions related to digital filter design.
  \item Missing data interpolation by projection onto convex sets.
  \item Data interpolation after coordinate transformation.
  \item Applying one of these algorithms to your own data.
  \end{enumerate}
\end{abstract}

\section{Filter design}

You can either write your answers on paper or edit them in the file
\verb#hw3/paper.tex#. Please show all the mathematical
derivations that you perform.

\begin{enumerate}

\item The Taylor series expansion of the inverse sine function around zero is
\begin{equation}
  \label{eq:arcsin}
  \arcsin{x} = x + \frac{1}{2}\,\frac{x^3}{3} + 
  \frac{1 \cdot 3}{2 \cdot 4}\,\frac{x^5}{5} + 
  \frac{1 \cdot 3 \cdot 5}{2 \cdot 4 \cdot 6}\,\frac{x^7}{7} + 
  \cdots
\end{equation}
\begin{enumerate}
\item Show how one can use expansion~(\ref{eq:arcsin}) to design a
  digital filter that approximates the derivative
  operator. \textbf{Hint:} use the identity $Z-1/Z =
  2\,i\,\sin{\omega}$ for $Z = \exp{(i\,\omega)}$.
\item In particular, find a seven-point derivative filter of the form
\begin{equation}
  \label{eq:d6}
  D(Z) = d_{-3}/Z^{3} + d_{-2}/Z^{2} + d_{-1}/Z + d_0 + 
  d_1\,Z + d_2\,Z^2 + d_3\,Z^3\;.
\end{equation}
\end{enumerate}

\item The Taylor series expansion of $Z^s$ around $Z=1$ is
\begin{equation}
  \label{eq:zs}
  Z^s = 1 + s\,(Z-1) + \cdots  
\end{equation}
\begin{enumerate}
\item The first term in expansion~(\ref{eq:zs}) can be used to
  define nearest-neighbor interpolation. The first two terms can be
  used to define linear interpolation. Going to a larger number of
  terms corresponds to \emph{Lagrangian} interpolation. Define a
  three-point interpolation filter using the first three terms of
  expansion~(\ref{eq:zs}).
\item Define a recursive interpolation filter of the form
\begin{equation}
  \label{eq:rec}
  Z^s \approx R(Z) = \frac{a_0(s) + a_1(s)\,Z}{1 + b_1(s)\,Z}
\end{equation}
by expanding it in a Taylor series around $Z=1$ and comparing this
series with expansion~(\ref{eq:zs}).
\end{enumerate}

\item The following C code (included in \texttt{filter.c} file in
  directory \texttt{geo391/hw3}) implements a recursive filtering
  operator.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=13]{filter.c}

\begin{enumerate}
\item Express this filter in the $Z$-transform notation as a ratio
  of two polynomials.
\item Add code for the adjoint operator.
\end{enumerate}

\item The parabolic B-spline $\beta_3(x)$ is a function defined as
 \begin{equation}
   \label{eq:b3} 
   \beta_3(x) = \int\limits_{-\infty}^{\infty} \beta_2(t)\,\beta_1(x-t)\,d t\;,
\end{equation}
where
\begin{equation}
   \label{eq:b1}
   \beta_1(x) = \left\{\begin{array}{lcl} 1 & \quad\mbox{for}\quad & |x| \le 1/2 \\
       0 &\quad \mbox{for}\quad& |x| > 1/2\end{array}\right.
 \end{equation}
and
\begin{equation}
  \label{eq:b2} 
   \beta_2(x) = \int\limits_{-\infty}^{\infty} \beta_1(t)\,\beta_1(x-t)\,d t\;
   = \left\{\begin{array}{lcl} 1-|x| &\quad \mbox{for}\quad& |x| \le 1 \\
       0 & \quad \mbox{for}\quad&  |x| > 1\end{array}\right.
\end{equation}

\begin{enumerate}
\item Find an explicit expression for $\beta_3(x)$.
\item Show that decomposing a continuous data function $d(x)$ into the convolution basis 
  with parabolic B-spines
  \begin{equation}
    \label{eq:basis} 
    d(x) = \sum\limits_k c_k\,\beta_3(x-k)
  \end{equation}
  leads to an interpolation filter of the form
  \begin{equation}
    \label{eq:bz}
    Z^s \approx B_3(Z) = \frac{a_0(s)/Z + a_1(s) + a_2(s)\,Z}{b_0/Z + b_1 + b_2\,Z}\;.
  \end{equation}
  Define $a_0(s)$, $a_1(s)$, $a_2(s)$, $b_0$, $b_1$, and $b_2$.
\end{enumerate}

\end{enumerate}

\section{Projection onto convex sets}
\inputdir{pocs}

In this exercise, we will use a depth slice from a 3-D seismic
volume, shown in Figure~\ref{fig:horizon}\footnote{Courtesy of Matt
  Hall (ConocoPhillips Canada Ltd.)}. Notice a channel structure. 

\multiplot{2}{horizon,hole}{width=0.45\textwidth}{Seismic depth slice
  with a channel structure. (a) Original. (b) After removing
  selected parts of the data.}

The goal of the exercise is to figure out if one can use compactness
of the Fourier transform to reconstruct missing data. The missing
parts are created artificially by cutting holes in the original data
[Figure~\ref{fig:hole}].

\plot{fft}{width=\textwidth}{(a) Double Fourier transform of the
  original data (absolute value). (b) Fourier-domain mask for
  selecting a convex set. (c) Double Fourier transform of the data
  with holes.}

Figure~\ref{fig:fft}(a) and~\ref{fig:fft}(c) show the digital Fourier
transform of the original data and the data with holes. Stripes at
zero wavenumbers are caused by non-periodicity of the original depth
slice. Otherwise the support of the data in the Fourier domain is
compact thanks to the data smoothness. Cutting holes in the physical
domain creates discontinuities that make the Fourier response
penetrate beyond the original support. Figure~\ref{fig:fft}b shows a
Fourier-domain mask designed to contain the support of the original
data.

To accomplish the task of missing data interpolation, we will use an
iterative method known as POCS (\emph{projection onto convex
sets}). By definition, a convex set $\mathcal{C}$ is a set of
functions such that, for any $f_1(\mathbf{x})$ and $f_2(\mathbf{x})$
from the set, $g(x) = \lambda\,f_1(\mathbf{x}) +
(1-\lambda)\,f_2(\mathbf{x})$ (for $0 \le \lambda \le 1$) also belongs
to the set. A projection onto a convex set means finding a function in
the set that is of the shortest distance to the given function. The
POCS theorem states that if one wants to find a function that belongs
to the intersection of two convex sets $C_1$ and $C_2$, the task can
be accomplished iteratively by alternating projections onto the two
sets.

In our example, $C_1$ is the set of all functions that are equal to
the known data outside of the holes. $C_2$ is the set of all functions
that have a predifined compact support in the Fourier domain (and
therefore are smooth in the physical domain). The algorithm consists
of the following steps:
\begin{enumerate}
\item Apply double Fourier transform 
\item Multiply by a Fourier-transform mask to enforce compact support.
\item Apply inverse Fourier transform.
\item Replace data outside of the holes with known data.
\item Repeat
\end{enumerate}
The output after 30 iterations is shown in Figure~\ref{fig:pocs}.

\sideplot{pocs}{width=\textwidth}{Missing data interpolated by
  iterative projection onto convex sets.}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single]{pocs/SConstruct}

Your task:
\begin{enumerate}
\item Change directory to \verb#geo391/hw3/pocs#
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Additionally, you can run
\begin{verbatim}
scons pocs.vpl
\end{verbatim}
to see a movie of different iterations.
\item By modifying appropriate parameters in the \texttt{SConstruct} file and repeating computations,
find out
\begin{enumerate}
\item How many iterations are required for convergence?
\item How large can you make the holes and still be able to achieve a reasonably good reconstruction?
\end{enumerate}
\item \textbf{EXTRA CREDIT} for finding a different convex set for either better or faster missing data reconstruction.
\end{enumerate}

\newpage

\section{Interpolation after coordinate transformation}
\inputdir{rotate}

In this exercise, we will use a slice out of a 3-D CT-scan of a
carbonate rock sample, shown in
Figure~\ref{fig:circle}\footnote{Courtesy of Jim Jennings
  (currently at Shell.)}. Notice microfracture channels.

\multiplot{2}{circle,rotate}{width=0.45\textwidth}{Slice of a CT-scan
  of a carbonate rock sample. (a) Original. (b) After clockwise rotation
  by $90^{\circ}$.}

The goal of the exercise is to apply a coordinate transformation to
the original data. A particular transformation that we will study is
coordinate rotation. Figure~\ref{fig:rotate} shows the original slice
rotated by 90 degrees. A 90-degree rotation in this case amounts to
simple transpose. However, rotation by a different angle requires
interpolation from the original grid to the modified grid.

The task of coordinate rotation is accomplished by the C program
\texttt{rotate.c}, included below. Two different methods are implemented: 
nearest-neighbor interpolation and bilinear interpolation. In the
$Z$-transform notation, the nearest neighbor interpolation corresponds
to the filter
\begin{equation}
\label{eq:nearest}
Z^s \approx N(Z) = 1
\end{equation}
while linear interpolation corresponds to the filter
\begin{equation}
\label{eq:linear}
Z^s \approx L(Z) = 1-s + s\,Z\;.
\end{equation}
To test the accuracy of different methods, we can rotate the original
data in small increments and then compare the result of rotating to
$360^{\circ}$ with the original data. Figure~\ref{fig:nearest,linear}
compares the error of the nearest-neighbor and bilinear interpolations
after rotating the original slice in increments of $20^{\circ}$. The
accuracy is comparatively low for small discontinuous features like
microfracture channels.

To improve the accuracy further, one needs to employ a longer
filter. One popular choice is \emph{cubic convolution} interpolation,
invented by Robert Keys (a geophysicist, currently at ConocoPhillips).
The cubic convolution filter can be expressed as the filter
\begin{eqnarray}
\nonumber
Z^s \approx C(Z) & = & -\frac{s\,(1-s)^2}{2}\,Z^{-1} + \frac{(1-s)\,(2 + 2\,s - 3 s^2)}{2} + \\
&  & \frac{s\,(1 + 4\,s - 3\,s^2)}{2}\,Z - \frac{(1-s)\,s^2}{2}\,Z^2\;.
\label{eq:cubic}
\end{eqnarray}
and is designed to approximate the ideal sinc-function interpolator.

\lstset{language=c,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single,firstline=19]{rotate/rotate.c}

\multiplot{3}{nearest,linear}{width=0.45\textwidth}{Error of different
  interpolation methods computed after full circle rotation in
  increments of 20 degrees. (a) Nearest-neighbor interpolation. (b)
  Bi-linear interpolation.}

\lstset{language=python,numbers=left,numberstyle=\tiny,showstringspaces=false}
\lstinputlisting[frame=single]{rotate/SConstruct}

Your task:
\begin{enumerate}
\item Change directory to \verb#geo391/hw3/rotate#
\item Run 
\begin{verbatim}
scons view
\end{verbatim}
to reproduce the figures on your screen.
\item Additionally, you can run
\begin{verbatim}
scons nearest.vpl
\end{verbatim}
and
\begin{verbatim}
scons linear.vpl
\end{verbatim}
to see movies of incremental slice rotation with different methods.
\item Modify the \texttt{rotate.c} program and the \texttt{SConstruct} file to implement the cubic convolution interpolation and to compare 
its results with the two other methods.
\item \textbf{EXTRA CREDIT} for implementing an interpolation algorithm, which is more accurate than cubic convolution.
\end{enumerate}

\section{Your own data}

Your final task is to apply one of the data analysis techniques of the
previous sections to your own data:
\begin{enumerate}
\item Select a dataset suitable for interpolation by POCS or for
  coordinate transformation.
\item Apply one the algorithm of the previous two sections and choose
  appropriate parameters.
\item Include the results in your homework.
\end{enumerate}

\section{Completing the assignment}

\begin{enumerate}
\item Change directory to \verb#geo391/hw3#.
\item Edit the file \texttt{paper.tex} in your favorite editor and change the
  first line to have your name instead of Keys's.
\item Run
\begin{verbatim}
sftour scons lock
sftour scons -c
\end{verbatim}
and
\begin{verbatim}
scons pdf
\end{verbatim}
\item Submit your result (file \texttt{paper.pdf}) by printing it out
  or by e-mail.
\end{enumerate}

\nocite{keys}
\nocite{youla}

\bibliographystyle{seg}
\bibliography{hw3}
