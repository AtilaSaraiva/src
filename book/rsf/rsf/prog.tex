\title{Guide to RSF programs}
\email{sergey.fomel@beg.utexas.edu}
\author{Sergey Fomel}
\lefthead{Fomel}
\righthead{RSF programs}

\maketitle

\begin{abstract}

This guide introduces some of the most used RSF programs and illustrates their
usage with examples.

\end{abstract}

\section{Main programs}

The source files for these programs can be found under
\href{http://egl.beg.utexas.edu/viewcvs/trunk/filt/main/}{filt/main}
in the RSF distribution.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfadd}
}}

\texttt{sfadd} is useful for combining (adding, dividing, or
multiplying) several datasets. What if you want to subtract two
datasets? Easy. Use the \texttt{scale} parameter as follows:
\begin{verbatim}
bash$ sfadd data1.rsf data2.rsf scale=1,-1 > diff.rsf
\end{verbatim}
or
\begin{verbatim}
bash$ sfadd < data1.rsf data2.rsf scale=1,-1 > diff.rsf
\end{verbatim}
The same task can be accomplished with the more general \texttt{sfmath} program:
\begin{verbatim}
bash$ sfmath one=data1.rsf two=data2.rsf output='one-two' > diff.rsf
\end{verbatim}
or
\begin{verbatim}
bash$ sfmath < data1.rsf two=data2.rsf output='input-two' > diff.rsf
\end{verbatim}
In both cases, the size and shape of \texttt{data1.rsf} and
\texttt{data2.rsf} hypercubes should be the same, and a warning
message is printed out if the the axis sampling parameters (such as
\texttt{o1} or \texttt{d1}) in these files are different.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfattr}
}}

\texttt{sfattr} is a useful diagnostic program. It reports certain statistical
values for an RSF dataset: RMS (root-mean-square) amplitude, mean value, norm
value, maximum and minimum values, number of nonzero samples, and the total
number of samples. If we denote data values as $d_i$ for $i=0,1,2,\ldots,n$,
then the RMS value is $\sqrt{\frac{1}{n}\,\sum\limits_{i=0}^n d_i^2}$, the
mean value is $\frac{1}{n}\,\sum\limits_{i=0}^n d_i$, and the $L_2$-norm value
is $\sum\limits_{i=0}^n d_i^2$. Using \texttt{sfattr} is a quick way to see
the distribution of data values and check it for errors.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcat}
}}

\texttt{sfcat} and \texttt{sfmerge} concatenate two or more files
together along a particular axis. It is the same program, only
\texttt{sfcat} has the default \texttt{space=n} and \texttt{sfmerge}
has the default \texttt{space=y}.

Example of \texttt{sfcat}:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time (s)"
    n2=3           d2=0.1         o2=0          label2="Distance (km)"
        6 elements 24 bytes
bash$ sfcat one.rsf one.rsf axis=1 > two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=4           d1=0.004       o1=0          label1="Time (s)"
    n2=3           d2=0.1         o2=0          label2="Distance (km)"
        12 elements 48 bytes
\end{verbatim}

Example of \texttt{sfmerge}:
\begin{verbatim}
bash$ sfmerge one.rsf one.rsf axis=2 > two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time (s)"
    n2=7           d2=0.1         o2=0          label2="Distance (km)"
        14 elements 56 bytes
\end{verbatim}
In this case, an extra empty trace is inserted between the two merged files.

The axes that are not being merged are checked for consistency:
\begin{verbatim}
bash$ sfcat one.rsf two.rsf > three.rsf
sfcat: n2 mismatch: need 3
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcmplx}
}}

\texttt{sfcmplx} simply creates a complex dataset from its real and
imaginary parts. The reverse operation can be accomplished with
\texttt{sfreal} and \texttt{sfimag}.

Example of \texttt{sfcmplx}:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time (s)"
    n2=3           d2=0.1         o2=0          label2="Distance (km)"
        6 elements 24 bytes
bash$ sfcmplx one.rsf one.rsf > cmplx.rsf
bash$ sfin cmplx.rsf
cmplx.rsf:
    in="/tmp/cmplx.rsf@"
    esize=8 type=complex form=native
    n1=2           d1=0.004       o1=0          label1="Time (s)"
    n2=3           d2=0.1         o2=0          label2="Distance (km)"
        6 elements 48 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcp}
}}

The \texttt{sfcp} and \texttt{sfmv} command imitate the Unix
\texttt{cp} and \texttt{mv} commands and serve for copying and moving
RSF files. Example:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time (s)"
    n2=3           d2=0.1         o2=0          label2="Distance (km)"
        6 elements 24 bytes
bash$ sfcp one.rsf two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time (s)"
    n2=3           d2=0.1         o2=0          label2="Distance (km)"
        6 elements 24 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcut}
}}

The \texttt{sfcut} command is related to \texttt{sfwindow} and has the same
set of arguments only instead of extracting the selected window, it fills it
with zeroes. The size of the input data is preserved. 

Examples:
\begin{verbatim}
bash$ sfspike n1=5 n2=5 > in.rsf
bash$ < in.rsf sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ < in.rsf sfcut n1=2 f1=1 n2=3 f2=2 | sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            0            0            1            1
  15:             1            0            0            1            1
  20:             1            0            0            1            1
bash$ < in.rsf sfcut j1=2 | sfdisfil
   0:             0            1            0            1            0
   5:             0            1            0            1            0
  10:             0            1            0            1            0
  15:             0            1            0            1            0
  20:             0            1            0            1            0
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfdd}
}}

The \texttt{sfdd} program is used to change either the form (\texttt{ascii},
\texttt{xdr}, \texttt{native}) or the type (\texttt{complex}, \texttt{float},
\texttt{int}, \texttt{char}) of the input dataset. 

In the example below, we create a plain text (ASCII) file with numbers and
then use \texttt{sfdd} to generate an RSF file in \texttt{xdr} form with
\texttt{complex} numbers. 
\begin{verbatim}
bash$ cat test.txt
1 2 3 4 5 6
bash$ echo n1=6 data_format=ascii_int in=test.txt > test.rsf
bash$ sfin test.rsf
test.rsf:
    in="test.txt"
    esize=0 type=int form=ascii
    n1=6           d1=?           o1=?
        6 elements
bash$ sfdd < test.rsf form=xdr type=complex > test2.rsf
bash$ sfin test2.rsf
test2.rsf:
    in="/tmp/test2.rsf@"
    esize=8 type=complex form=xdr
    n1=3           d1=?           o1=?
        3 elements 24 bytes
bash$ sfdisfil < test2.rsf
   0:          1,         2i         3,         4i         5,         6i
\end{verbatim}

To learn more about the data format in RSF, consult the
\href{http://egl.beg.utexas.edu/RSF/book/rsf/rsf/format_html/}{guide to RSF
  format}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfdisfil}
}}

The \texttt{sfdisfil} program simply dumps the data contents to the standard
output in a text form. It is used mostly for debugging purposes to quickly
examine RSF files. Here is an example:
\begin{verbatim}
bash$ sfmath o1=0 d1=2 n1=12 output=x1 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            2            4            6            8
   5:            10           12           14           16           18
  10:            20           22
\end{verbatim}
The output format is easily configurable.
\begin{verbatim}
bash$ < test.rsf sfdisfil col=6 number=n format="%5.1f"
  0.0  2.0  4.0  6.0  8.0 10.0
 12.0 14.0 16.0 18.0 20.0 22.0
\end{verbatim}
Along with \texttt{sfdd}, \texttt{sfdisfil} provides a simple way to convert
RSF data to an ASCII form.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfdottest}
}}

\texttt{sfdottest} is a generic dot-product test program for testing
linear operators. Suppose there is an executable program
\texttt{<prog>} that takes an RSF file from the standard input and
produces an RSF file in the standard output. It may take any number of
additional parameters but one of them must be \texttt{adj=} that sets
the forward (\texttt{adj=0}) or adjoint (\texttt{adj=1}) operations.
The program \texttt{<prog>} is typically an RSF program but it could
be anything (a script, a multiprocessor MPI program, etc.) as long as
it implements a linear operator $\mathbf{L}$ and its adjoint
$\mathbf{L}^T$. The \texttt{sfdottest} program is testing the equality
\begin{equation}
\label{eq:dptest}
\mathbf{d}^T\,\mathbf{L}\,\mathbf{m} = \mathbf{m}^T\,\mathbf{L}^T\,\mathbf{d}
\end{equation}
by using random vectors $\mathbf{m}$ and $\mathbf{d}$. You can invoke it with
\begin{verbatim}
bash$ sfdottest <prog> [optional aruments] mod=mod.rsf dat=dat.rsf
\end{verbatim}
where \texttt{mod.rsf} and \texttt{dat.rsf} are RSF files that
represent vectors from the model and data spaces. \texttt{sfdottest}
does not create any temporary files and does not have any restrictive
limitations on the size of the vectors.

Here is an example. We first setup a vector with 100 elements using
\texttt{sfspike} and then run \texttt{sfdottest} to test the
\texttt{sfcausint} program. \texttt{sfcausint} implements a linear
operator of causal integration and its adjoint, the anti-causal
integration.
\begin{verbatim}
bash$ sfspike n1=100 > vec.rsf
bash$ sfdottest sfcausint mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=1410.2
sfdottest: L'[d]*m=1410.2
bash$ sfdottest sfcausint mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=1165.87
sfdottest: L'[d]*m=1165.87
\end{verbatim}
The numbers are different on subsequent runs because of changing
seed in the random number generator.

Here is a somewhat more complicated example. The \texttt{sfhelicon}
program implements Claerbout's multidimensional helical filtering
\cite[]{GEO63-05-15321541}. It requires a filter to be specified in
addition to the input and output vectors. We create a helical 
2-D filter using the Unix \texttt{echo} command.
\begin{verbatim}
bash$ echo 1 19 20 n1=3 n=20,20 data_format=ascii_int in=lag.rsf > lag.rsf
bash$ echo 1 1 1 a0=-3 n1=3 data_format=ascii_float in=flt.rsf > flt.rsf
\end{verbatim}
Next, we create an example 2-D model and data vector with \texttt{sfspike}.
\begin{verbatim}
bash$ sfspike n1=50 n2=50 > vec.rsf
\end{verbatim}
Now the \texttt{sfdottest} program can perform the dot product test.
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=8.97375
sfdottest: L'[d]*m=8.97375
\end{verbatim}
Here is the same program tested in the inverse filtering mode:
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf inv=y
sfdottest:  L[m]*d=15.0222
sfdottest: L'[d]*m=15.0222
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfget}
}}

The \texttt{sfget} program extracts a parameter value from an RSF file. It is
useful mostly for scripting. Here is, for example, a quick calculation of the
maximum value on the first axis in an RSF dataset (the output of
\texttt{sfspike}) using the standard Unix \texttt{bc} calculator.
\begin{verbatim}
bash$ ( sfspike n1=100 | sfget n1 d1 o1; echo "o1+(n1-1)*d1" ) | bc
.396
\end{verbatim}
See also \texttt{sfput}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheaderattr}
}}

The \texttt{sfheaderattr} examines the contents of a trace header file,
typically generated by \texttt{sfsegyread}. In the example below, we examine
trace headers in the output of \texttt{suplane}, a program from Seismic Unix.
\begin{verbatim}
bash$ suplane > plane.su
bash$ sfsegyread tape=plane.su su=y tfile=tfile.rsf > plane.rsf
bash$ sfheaderattr < tfile.rsf
*******************************************
71 headers, 32 traces
key[0]="tracl"      min[0]=1            max[31]=32          mean=16.5
key[1]="tracr"      min[0]=1            max[31]=32          mean=16.5
key[2]="fldr"       min[0]=0            max[31]=0           mean=0
key[3]="tracf"      min[0]=0            max[31]=0           mean=0
key[4]="ep"         min[0]=0            max[31]=0           mean=0
key[5]="cdp"        min[0]=0            max[31]=0           mean=0
key[6]="cdpt"       min[0]=0            max[31]=0           mean=0
key[7]="trid"       min[0]=0            max[31]=0           mean=0
key[8]="nvs"        min[0]=0            max[31]=0           mean=0
key[9]="nhs"        min[0]=0            max[31]=0           mean=0
key[10]="duse"      min[0]=0            max[31]=0           mean=0
key[11]="offset"    min[0]=400          max[31]=400         mean=400
key[12]="gelev"     min[0]=0            max[31]=0           mean=0
key[13]="selev"     min[0]=0            max[31]=0           mean=0
key[14]="sdepth"    min[0]=0            max[31]=0           mean=0
key[15]="gdel"      min[0]=0            max[31]=0           mean=0
key[16]="sdel"      min[0]=0            max[31]=0           mean=0
key[17]="swdep"     min[0]=0            max[31]=0           mean=0
key[18]="gwdep"     min[0]=0            max[31]=0           mean=0
key[19]="scalel"    min[0]=0            max[31]=0           mean=0
key[20]="scalco"    min[0]=0            max[31]=0           mean=0
key[21]="sx"        min[0]=0            max[31]=0           mean=0
key[22]="sy"        min[0]=0            max[31]=0           mean=0
key[23]="gx"        min[0]=0            max[31]=0           mean=0
key[24]="gy"        min[0]=0            max[31]=0           mean=0
key[25]="counit"    min[0]=0            max[31]=0           mean=0
key[26]="wevel"     min[0]=0            max[31]=0           mean=0
key[27]="swevel"    min[0]=0            max[31]=0           mean=0
key[28]="sut"       min[0]=0            max[31]=0           mean=0
key[29]="gut"       min[0]=0            max[31]=0           mean=0
key[30]="sstat"     min[0]=0            max[31]=0           mean=0
key[31]="gstat"     min[0]=0            max[31]=0           mean=0
key[32]="tstat"     min[0]=0            max[31]=0           mean=0
key[33]="laga"      min[0]=0            max[31]=0           mean=0
key[34]="lagb"      min[0]=0            max[31]=0           mean=0
key[35]="delrt"     min[0]=0            max[31]=0           mean=0
key[36]="muts"      min[0]=0            max[31]=0           mean=0
key[37]="mute"      min[0]=0            max[31]=0           mean=0
key[38]="ns"        min[0]=64           max[31]=64          mean=64
key[39]="dt"        min[0]=4000         max[31]=4000        mean=4000
key[40]="gain"      min[0]=0            max[31]=0           mean=0
key[41]="igc"       min[0]=0            max[31]=0           mean=0
key[42]="igi"       min[0]=0            max[31]=0           mean=0
key[43]="corr"      min[0]=0            max[31]=0           mean=0
key[44]="sfs"       min[0]=0            max[31]=0           mean=0
key[45]="sfe"       min[0]=0            max[31]=0           mean=0
key[46]="slen"      min[0]=0            max[31]=0           mean=0
key[47]="styp"      min[0]=0            max[31]=0           mean=0
key[48]="stas"      min[0]=0            max[31]=0           mean=0
key[49]="stae"      min[0]=0            max[31]=0           mean=0
key[50]="tatyp"     min[0]=0            max[31]=0           mean=0
key[51]="afilf"     min[0]=0            max[31]=0           mean=0
key[52]="afils"     min[0]=0            max[31]=0           mean=0
key[53]="nofilf"    min[0]=0            max[31]=0           mean=0
key[54]="nofils"    min[0]=0            max[31]=0           mean=0
key[55]="lcf"       min[0]=0            max[31]=0           mean=0
key[56]="hcf"       min[0]=0            max[31]=0           mean=0
key[57]="lcs"       min[0]=0            max[31]=0           mean=0
key[58]="hcs"       min[0]=0            max[31]=0           mean=0
key[59]="year"      min[0]=0            max[31]=0           mean=0
key[60]="day"       min[0]=0            max[31]=0           mean=0
key[61]="hour"      min[0]=0            max[31]=0           mean=0
key[62]="minute"    min[0]=0            max[31]=0           mean=0
key[63]="sec"       min[0]=0            max[31]=0           mean=0
key[64]="timbas"    min[0]=0            max[31]=0           mean=0
key[65]="trwf"      min[0]=0            max[31]=0           mean=0
key[66]="grnors"    min[0]=0            max[31]=0           mean=0
key[67]="grnofr"    min[0]=0            max[31]=0           mean=0
key[68]="grnlof"    min[0]=0            max[31]=0           mean=0
key[69]="gaps"      min[0]=0            max[31]=0           mean=0
key[70]="otrav"     min[0]=0            max[31]=0           mean=0
*******************************************
\end{verbatim}
For each standard keyword, a minimum, maximum, and mean values are reported.
This quick inspection can help in identifying meaningful keywords set in the
data. The input data type must be \texttt{int}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheadermath}
}}

\texttt{sfheadermath} is a versatile program for mathematical
operations on rows of the input file. If the input file is an
\texttt{n1} by \texttt{n2} matrix, the output will be a \texttt{1} by
\texttt{n2} matrix that contains one row made out of mathematical
operations on the other rows. \texttt{sfheadermath} can identify a row
by number or by a standard SEGY keyword. The latter is useful for
processing headers extracted from SEGY or SU files.

Here is an example. First, we create an SU file with \texttt{suplane} and convert it to RSF using \texttt{sfsegyread}.
\begin{verbatim}
bash$ suplane > plane.su
bash$ sfsegyread tape=plane.su su=y tfile=tfile.rsf > plane.rsf
\end{verbatim}
The trace header information is saved in \texttt{tfile.rsf}. It
contains 71 headers for 32 traces in integer format.
\begin{verbatim}
bash$ sfin tfile.rsf
tfile.rsf:
    in="/tmp/tfile.rsf@"
    esize=4 type=int form=native
    n1=71          d1=?           o1=?
    n2=32          d2=?           o2=?
        2272 elements 9088 bytes
\end{verbatim}
Next, we will convert \texttt{tfile.rsf} to a floating-point format
and run \texttt{sfheadermath} to create a new header.
\begin{verbatim}
bash$ < tfile.rsf sfdd type=float | \
sfheadermath myheader=1 output="sqrt(myheader+(2+10*offset^2))" > new.rsf
bash$ sfin new.rsf
new.rsf:
    in="/tmp/new.rsf@"
    esize=4 type=float form=native
    n1=1           d1=?           o1=?
    n2=32          d2=?           o2=?
        32 elements 128 bytes
\end{verbatim}
We defined ``myheader'' as being the row number 1 in the input (note
that numbering starts with 0) and combined it with ``offset'', which
is a standard SEGY keyword that denotes row number 11 (see the output
of \texttt{sfheaderattr} above.) A variety of mathematical expressions
can be defined in the \texttt{output=} string. The expression
processing engine is shared with \texttt{sfmath}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheadersort}
}}

\texttt{sfheadersort} is used to sort traces in the input file
according to trace header information. 

Here is an example of using
\texttt{sfheadersort} for randomly shuffling traces in the input
file. First, let us create an input file with seven traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=7 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7 
\end{verbatim}
Next, we can create a random file with seven header values using
\texttt{sfnoise}.
\begin{verbatim}
bash$ sfspike n1=7 | sfnoise rep=y type=n > random.rsf
bash$ < random.rsf sfdisfil
   0:       0.05256      -0.2879       0.1487       0.4097       0.1548
   5:        0.4501       0.2836
\end{verbatim}
If you reproduce this example, your numbers will most likely be different,
because, in the absence of \texttt{seed=} parameter, \texttt{sfnoise}
uses a random seed value to generate pseudo-random numbers. Finally, we
apply \texttt{sfheadersort} to shuffle the input traces.
\begin{verbatim}
bash$ < input.rsf sfheadersort head=random.rsf > output.rsf
bash$ < output.rsf sfdisfil
   0:             2            2            2            2            2
   5:             1            1            1            1            1
  10:             3            3            3            3            3
  15:             5            5            5            5            5
  20:             7            7            7            7            7
  25:             4            4            4            4            4
  30:             6            6            6            6            6
\end{verbatim}
As expected, the order of traces in the output file corresponds to the
order of values in the header. Thanks to the separation between
headers and data, the operation of \texttt{sfheadersort} is optimally
efficient. It first sorts the headers and only then accesses the data,
reading each data trace only once.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheaderwindow}
}}

\texttt{sfheaderwindow} is used to window traces in the input file
according to trace header information. 

Here is an example of using \texttt{sfheaderwindow} for randomly
selecting part of the traces in the input file. First, let us create
an input file with ten traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=10 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7
  35:             8            8            8            8            8
  40:             9            9            9            9            9
  45:            10           10           10           10           10
\end{verbatim}
Next, we can create a random file with ten header values using
\texttt{sfnoise}.
\begin{verbatim}
bash$ sfspike n1=10 | sfnoise rep=y type=n > random.rsf
bash$ < random.rsf sfdisfil
   0:     -0.005768      0.02258     -0.04331      -0.4129      -0.3909
   5:      -0.03582       0.4595      -0.3326        0.498      -0.3517
\end{verbatim}
If you reproduce this example, your numbers will most likely be different,
because, in the absence of \texttt{seed=} parameter, \texttt{sfnoise}
uses a random seed value to generate pseudo-random numbers. Finally,
we apply \texttt{sfheaderwindow} to window the input traces selecting
only those for which the header is greater than zero.
\begin{verbatim}
bash$ < random.rsf sfmask min=0 > mask.rsf
bash$ < mask.rsf sfdisfil
   0:    0    1    0    0    0    0    1    0    1    0
bash$ < input.rsf sfheaderwindow mask=mask.rsf > output.rsf
bash$ < output.rsf sfdisfil
   0:             2            2            2            2            2
   5:             7            7            7            7            7
  10:             9            9            9            9            9
\end{verbatim}
In this case, only three traces are selected for the output. Thanks to
the separation between headers and data, the operation of
\texttt{sfheaderwindow} is optimally efficient. 

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfin}
  }}

\texttt{sfin} is one of the most useful programs for operating with
RSF files. It produces quick information on the file hypercube
dimensions and checks the consistency of the associated data file.

Here is an example. Let us create an RSF file and examine it with \texttt{sfin}.
\begin{verbatim}
bash$ sfspike n1=100 n2=20 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/tmp/spike.rsf@"
    esize=4 type=float form=native
    n1=100         d1=0.004       o1=0          label1="Time (s)"
    n2=20          d2=0.1         o2=0          label2="Distance (km)"
        2000 elements 8000 bytes
\end{verbatim}
\texttt{sfin} reports the following information:
\begin{itemize}
\item location of the data file (\texttt{/tmp/spike.rsf\@})
\item element size (4 bytes)
\item element type (floating point)
\item element form (native)
\item hypercube dimensions (100 by 20)
\item axes scale (0.004 and 0.1)
\item axes origin (0 and 0)
\item axes labels
\item total number of elements
\item total number of bytes in the data file
\end{itemize}

Suppose that the file got corrupted by a buggy program and reports
incorrect dimensions. The \texttt{sfin} program should be able to
catch the discrepancy.
\begin{verbatim}
bash$ echo n2=100 >> spike.rsf
bash$ sfin spike.rsf > /dev/null
sfin:           Actually 8000 bytes, 20% of expected.
\end{verbatim}

\texttt{sfin} also checks the first records in the file for zeros. 
\begin{verbatim}
bash$ sfspike n1=100 n2=100 k2=99 > spike2.rsf
bash$ sfin spike2.rsf >/dev/null
sfin: The first 32768 bytes are all zeros
\end{verbatim}
The number of bytes to check is adjustable
\begin{verbatim}
bash$ sfin spike2.rsf check=0.01 >/dev/null
sfin: The first 16384 bytes are all zeros
\end{verbatim}

You can also output only the location of the data file. This is
sometimes handy in scripts.
\begin{verbatim}
bash$ sfin spike.rsf spike2.rsf info=n
/tmp/spike.rsf@ /tmp/spike2.rsf@
\end{verbatim}
An alternative is to use \texttt{sfget}, as follows:
\begin{verbatim}
bash$ sfget parform=n in < spike.rsf
/tmp/spike.rsf@
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfinterleave}
  }}

\texttt{sfinterleave} combines two or more datasets by interleaving them on one
of the axes. Here is a quick example:
\begin{verbatim}
bash$ sfspike n1=5 n2=5 > one.rsf
bash$ sfdisfil < one.rsf
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ sfscale < one.rsf dscale=2 > two.rsf
bash$ sfdisfil < two.rsf
   0:             2            2            2            2            2
   5:             2            2            2            2            2
  10:             2            2            2            2            2
  15:             2            2            2            2            2
  20:             2            2            2            2            2
bash$ sfinterleave one.rsf two.rsf axis=1 | sfdisfil
   0:             1            2            1            2            1
   5:             2            1            2            1            2
  10:             1            2            1            2            1
  15:             2            1            2            1            2
  20:             1            2            1            2            1
  25:             2            1            2            1            2
  30:             1            2            1            2            1
  35:             2            1            2            1            2
  40:             1            2            1            2            1
  45:             2            1            2            1            2
bash$ sfinterleave < one.rsf two.rsf axis=2 | sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             1            1            1            1            1
  15:             2            2            2            2            2
  20:             1            1            1            1            1
  25:             2            2            2            2            2
  30:             1            1            1            1            1
  35:             2            2            2            2            2
  40:             1            1            1            1            1
  45:             2            2            2            2            2
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfmask}
  }}

\texttt{sfmask} creates an integer output of ones and zeros comparing
the values of the input data to specified \texttt{min=} and
\texttt{max=} parameters. It is useful for \texttt{sfheaderwindow} and
in many other applications. Here is a quick example:
\begin{verbatim}
bash$ sfmath n1=10 output="sin(x1)" > sin.rsf
bash$ < sin.rsf sfdisfil
   0:             0       0.8415       0.9093       0.1411      -0.7568
   5:       -0.9589      -0.2794        0.657       0.9894       0.4121
bash$ < sin.rsf sfmask min=-0.5 max=0.5 | sfdisfil
   0:    1    0    0    1    0    0    1    0    0    1
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfmath}
  }}

\inputdir{sfmath}

\texttt{sfmath} is a versatile program for mathematical operations
with RSF files. It can operate with several input file, all of the
same dimensions and data type. The data type can be real (floating
point) or complex. Here is an example that demonstrates several
features of \texttt{sfmath}.
\begin{verbatim}
bash$ sfmath n1=600 d1=0.01 o1=0 n2=40 d2=1 o2=5 \
output="x2*(8+sin(6*x1+x2/10))" > rad.rsf
bash$ < rad.rsf sfrtoc | sfmath output="input*exp(I*x1)" > rose.rsf
bash$ < rose.rsf sfgraph title=Rose screenratio=1 wantaxis=n | xtpen
\end{verbatim}

The first line creates a 2-D dataset that consists of 40 traces 600
samples each. The values of the data are computed with the formula
\verb#"x2*(8+sin(6*x1+x2/10))"#, where \texttt{x1} refers to the
coordinate on the first axis, and \texttt{x2} is the coordinate of the
second axis. In the second line, we convert the data from real to
complex using \texttt{sfrtoc} and produce a complex dataset using
formula \verb#"input*exp(I*x1)"#, where \texttt{input} refers to the
input file. Finally, we plot the complex data as a collection of
parametric curves using \texttt{sfgraph} and display the result using
\texttt{xtpen}.  The plot appearing on your screen should look similar
to Figure~\ref{fig:rose}.

\plot{rose}{width=0.6\textwidth}{This figure was created with \texttt{sfmath}.}

One possible alternative to the second line above is
\begin{verbatim}
bash$ < rad.rsf sfmath output=x1 > ang.rsf
bash$ sfmath r=rad.rsf a=ang.rsf output="r*cos(a)" > cos.rsf
bash$ sfmath r=rad.rsf a=ang.rsf output="r*sin(a)" > sin.rsf
bash$ sfcmplx cos.rsf sin.rsf > rose.rsf
\end{verbatim}
Here we refer to input files by names (\texttt{r} and \texttt{a}) and combine the names in a formula.

\bibliographystyle{seg}
\bibliography{SEG}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
