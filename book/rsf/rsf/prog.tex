\title{Guide to RSF programs}
\email{sergey.fomel@beg.utexas.edu}
\author{Sergey Fomel}
\lefthead{Fomel}
\righthead{RSF programs}

\maketitle

\begin{abstract}

This guide introduces some of the most used RSF programs and illustrates their
usage with examples.

\end{abstract}

\section{Main programs}

The source files for these programs can be found under
\href{http://svn.sourceforge.net/viewcvs.cgi/rsf/trunk/filt/main/}{filt/main}
in the RSF distribution.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfadd}
}}

\texttt{sfadd} is useful for combining (adding, dividing, or
multiplying) several datasets. What if you want to subtract two
datasets? Easy. Use the \texttt{scale} parameter as follows:
\begin{verbatim}
bash$ sfadd data1.rsf data2.rsf scale=1,-1 > diff.rsf
\end{verbatim}
or
\begin{verbatim}
bash$ sfadd < data1.rsf data2.rsf scale=1,-1 > diff.rsf
\end{verbatim}
The same task can be accomplished with the more general \texttt{sfmath} program:
\begin{verbatim}
bash$ sfmath one=data1.rsf two=data2.rsf output='one-two' > diff.rsf
\end{verbatim}
or
\begin{verbatim}
bash$ sfmath < data1.rsf two=data2.rsf output='input-two' > diff.rsf
\end{verbatim}
In both cases, the size and shape of \texttt{data1.rsf} and
\texttt{data2.rsf} hypercubes should be the same, and a warning
message is printed out if the the axis sampling parameters (such as
\texttt{o1} or \texttt{d1}) in these files are different.

\subsubsection{Implementation: \href{http://svn.sourceforge.net/viewcvs.cgi/rsf/trunk/filt/main/add.c?view=markup}{filt/main/add.c}}

The first input file is either in the list or in the standard input.
\moddex{add}{add}{101}{108}{filt/main}

Collect input files in the \texttt{in} array from all command-line
parameters that don't contain an ``\texttt{=}'' sign. The total number
of input files in \texttt{nin}.
\moddex{add}{add}{110}{116}{filt/main}

A helper function \texttt{check\_compat} checks the compatibility of
input files.
\moddex{add}{add}{412}{450}{filt/main}

Finally, we enter the main loop, where input data are getting read
buffer by buffer and combined in the total product depending on the
data type.
\moddex{add}{add}{173}{194}{filt/main}

The data combination program for floating point numbers is
\texttt{add\_float}.  
\moddex{add}{add}{253}{294}{filt/main}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfattr}
}}

\texttt{sfattr} is a useful diagnostic program. It reports certain
statistical values for an RSF dataset: RMS (root-mean-square)
amplitude, mean value, norm value, variance, standard deviation,
maximum and minimum values, number of nonzero samples, and the total
number of samples.

If we denote data values as $d_i$ for $i=0,1,2,\ldots,n$, then the RMS
value is $\sqrt{\frac{1}{n}\,\sum\limits_{i=0}^n d_i^2}$, the mean
value is $\frac{1}{n}\,\sum\limits_{i=0}^n d_i$, the $L_2$-norm value
is $\sqrt{\sum\limits_{i=0}^n d_i^2}$, the variance is
$\frac{1}{n-1}\,\left[\sum\limits_{i=0}^n d_i^2 - \frac{1}{n}\left(\sum\limits_{i=0}^n d_i\right)^2\right]$, and the standard
deviation is the square root of the variance. Using \texttt{sfattr}
is a quick way to see the distribution of data values and check it for
anomalies.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcat}
}}

\texttt{sfcat} and \texttt{sfmerge} concatenate two or more files
together along a particular axis. It is the same program, only
\texttt{sfcat} has the default \texttt{space=n} and \texttt{sfmerge}
has the default \texttt{space=y}.

Example of \texttt{sfcat}:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
bash$ sfcat one.rsf one.rsf axis=1 > two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=4           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        12 elements 48 bytes
\end{verbatim}

Example of \texttt{sfmerge}:
\begin{verbatim}
bash$ sfmerge one.rsf one.rsf axis=2 > two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=7           d2=0.1         o2=0          label2="Distance" unit2="km"
        14 elements 56 bytes
\end{verbatim}
In this case, an extra empty trace is inserted between the two merged files.

The axes that are not being merged are checked for consistency:
\begin{verbatim}
bash$ sfcat one.rsf two.rsf > three.rsf
sfcat: n2 mismatch: need 3
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcmplx}
}}

\texttt{sfcmplx} simply creates a complex dataset from its real and
imaginary parts. The reverse operation can be accomplished with
\texttt{sfreal} and \texttt{sfimag}.

Example of \texttt{sfcmplx}:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
bash$ sfcmplx one.rsf one.rsf > cmplx.rsf
bash$ sfin cmplx.rsf
cmplx.rsf:
    in="/tmp/cmplx.rsf@"
    esize=8 type=complex form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 48 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfconjgrad}
}}

\texttt{sfconjgrad} is a generic program for least-squares linear
inversion with the conjugate-gradient method. Suppose you have an
executable program \texttt{<prog>} that takes an RSF file from the
standard input and produces an RSF file in the standard output. It may
take any number of additional parameters but one of them must be
\texttt{adj=} that sets the forward (\texttt{adj=0}) or adjoint
(\texttt{adj=1}) operations.  The program \texttt{<prog>} is typically
an RSF program but it could be anything (a script, a multiprocessor
MPI program, etc.) as long as it implements a linear operator
$\mathbf{L}$ and its adjoint. There are no restrictions on the data
size or shape. You can easily test the adjointness with
\texttt{sfdottest}. The \texttt{sfconjgrad} program searches for a
vector $\mathbf{m}$ that minimizes the least-square misfit 
$\|\mathbf{d - L\,m}\|^2$ for the given input data vector $\mathbf{d}$.

Here is an example. The \texttt{sfhelicon}
program implements Claerbout's multidimensional helical filtering
\cite[]{GEO63-05-15321541}. It requires a filter to be specified in
addition to the input and output vectors. We create a helical 
2-D filter using the Unix \texttt{echo} command.
\begin{verbatim}
bash$ echo 1 19 20 n1=3 n=20,20 data_format=ascii_int in=lag.rsf > lag.rsf
bash$ echo 1 1 1 a0=-3 n1=3 data_format=ascii_float in=flt.rsf > flt.rsf
\end{verbatim}
Next, we create an example 2-D model and data vector with \texttt{sfspike}.
\begin{verbatim}
bash$ sfspike n1=50 n2=50 > vec.rsf
\end{verbatim}
The \texttt{sfdottest} program can perform the dot product test to
check that the adjoint mode works correctly.
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=5.28394
sfdottest: L'[d]*m=5.28394
\end{verbatim}
Your numbers may be different because \texttt{sfdottest} generates new
random input on each run.
Next, let us make some random data with \texttt{sfnoise}.
\begin{verbatim}
bash$ sfnoise seed=2005 rep=y < vec.rsf > dat.rsf
\end{verbatim}
and try to invert the filtering operation using \texttt{sfconjgrad}:
\begin{verbatim}
bash$ sfconjgrad sfhelicon filt=flt.rsf lag=lag.rsf \
mod=vec.rsf < dat.rsf > mod.rsf niter=10
sfconjgrad: iter 1 of 10
sfconjgrad: grad=3253.65
sfconjgrad: iter 2 of 10
sfconjgrad: grad=289.421
sfconjgrad: iter 3 of 10
sfconjgrad: grad=92.3481
sfconjgrad: iter 4 of 10
sfconjgrad: grad=36.9417
sfconjgrad: iter 5 of 10
sfconjgrad: grad=18.7228
sfconjgrad: iter 6 of 10
sfconjgrad: grad=11.1794
sfconjgrad: iter 7 of 10
sfconjgrad: grad=7.26941
sfconjgrad: iter 8 of 10
sfconjgrad: grad=5.15945
sfconjgrad: iter 9 of 10
sfconjgrad: grad=4.23055
sfconjgrad: iter 10 of 10
sfconjgrad: grad=3.57495
\end{verbatim}
The output shows that, in 10 iterations, the norm of the gradient vector decreases by almost 1000. 
We can check the residual misfit before
\begin{verbatim}
bash$ < dat.rsf sfattr want=norm
norm value = 49.7801
\end{verbatim}
and after
\begin{verbatim}
bash$ sfhelicon filt=flt.rsf lag=lag.rsf < mod.rsf | \
sfadd scale=1,-1 dat.rsf | sfattr want=norm
norm value = 5.73563
\end{verbatim}
In 10 iterations, the misfit decreased by an order of magnitude. The
result can be improved by running the program for more iterations.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcp}
}}

The \texttt{sfcp} and \texttt{sfmv} command imitate the Unix
\texttt{cp} and \texttt{mv} commands and serve for copying and moving
RSF files. Example:
\begin{verbatim}
bash$ sfspike n1=2 n2=3 > one.rsf
bash$ sfin one.rsf
one.rsf:
    in="/tmp/one.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
bash$ sfcp one.rsf two.rsf
bash$ sfin two.rsf
two.rsf:
    in="/tmp/two.rsf@"
    esize=4 type=float form=native
    n1=2           d1=0.004       o1=0          label1="Time" unit1="s"
    n2=3           d2=0.1         o2=0          label2="Distance" unit2="km"
        6 elements 24 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfcut}
}}

The \texttt{sfcut} command is related to \texttt{sfwindow} and has the same
set of arguments only instead of extracting the selected window, it fills it
with zeroes. The size of the input data is preserved. 

Examples:
\begin{verbatim}
bash$ sfspike n1=5 n2=5 > in.rsf
bash$ < in.rsf sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ < in.rsf sfcut n1=2 f1=1 n2=3 f2=2 | sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            0            0            1            1
  15:             1            0            0            1            1
  20:             1            0            0            1            1
bash$ < in.rsf sfcut j1=2 | sfdisfil
   0:             0            1            0            1            0
   5:             0            1            0            1            0
  10:             0            1            0            1            0
  15:             0            1            0            1            0
  20:             0            1            0            1            0
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfdd}
}}

The \texttt{sfdd} program is used to change either the form (\texttt{ascii},
\texttt{xdr}, \texttt{native}) or the type (\texttt{complex}, \texttt{float},
\texttt{int}, \texttt{char}) of the input dataset. 

In the example below, we create a plain text (ASCII) file with numbers and
then use \texttt{sfdd} to generate an RSF file in \texttt{xdr} form with
\texttt{complex} numbers. 
\begin{verbatim}
bash$ cat test.txt
1 2 3 4 5 6
bash$ echo n1=6 data_format=ascii_int in=test.txt > test.rsf
bash$ sfin test.rsf
test.rsf:
    in="test.txt"
    esize=0 type=int form=ascii
    n1=6           d1=?           o1=?
        6 elements
bash$ sfdd < test.rsf form=xdr type=complex > test2.rsf
bash$ sfin test2.rsf
test2.rsf:
    in="/tmp/test2.rsf@"
    esize=8 type=complex form=xdr
    n1=3           d1=?           o1=?
        3 elements 24 bytes
bash$ sfdisfil < test2.rsf
   0:          1,         2i         3,         4i         5,         6i
\end{verbatim}

To learn more about the data format in RSF, consult the
\href{http://egl.beg.utexas.edu/RSF/book/rsf/rsf/format_html/}{guide to RSF
  format}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfdisfil}
}}

The \texttt{sfdisfil} program simply dumps the data contents to the standard
output in a text form. It is used mostly for debugging purposes to quickly
examine RSF files. Here is an example:
\begin{verbatim}
bash$ sfmath o1=0 d1=2 n1=12 output=x1 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            2            4            6            8
   5:            10           12           14           16           18
  10:            20           22
\end{verbatim}
The output format is easily configurable.
\begin{verbatim}
bash$ < test.rsf sfdisfil col=6 number=n format="%5.1f"
  0.0  2.0  4.0  6.0  8.0 10.0
 12.0 14.0 16.0 18.0 20.0 22.0
\end{verbatim}
Along with \texttt{sfdd}, \texttt{sfdisfil} provides a simple way to convert
RSF data to an ASCII form.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfdottest}
}}

\texttt{sfdottest} is a generic dot-product test program for testing
linear operators. Suppose there is an executable program
\texttt{<prog>} that takes an RSF file from the standard input and
produces an RSF file in the standard output. It may take any number of
additional parameters but one of them must be \texttt{adj=} that sets
the forward (\texttt{adj=0}) or adjoint (\texttt{adj=1}) operations.
The program \texttt{<prog>} is typically an RSF program but it could
be anything (a script, a multiprocessor MPI program, etc.) as long as
it implements a linear operator $\mathbf{L}$ and its adjoint
$\mathbf{L}^T$. The \texttt{sfdottest} program is testing the equality
\begin{equation}
\label{eq:dptest}
\mathbf{d}^T\,\mathbf{L}\,\mathbf{m} = \mathbf{m}^T\,\mathbf{L}^T\,\mathbf{d}
\end{equation}
by using random vectors $\mathbf{m}$ and $\mathbf{d}$. You can invoke it with
\begin{verbatim}
bash$ sfdottest <prog> [optional aruments] mod=mod.rsf dat=dat.rsf
\end{verbatim}
where \texttt{mod.rsf} and \texttt{dat.rsf} are RSF files that
represent vectors from the model and data spaces. \texttt{sfdottest}
does not create any temporary files and does not have any restrictive
limitations on the size of the vectors.

Here is an example. We first setup a vector with 100 elements using
\texttt{sfspike} and then run \texttt{sfdottest} to test the
\texttt{sfcausint} program. \texttt{sfcausint} implements a linear
operator of causal integration and its adjoint, the anti-causal
integration.
\begin{verbatim}
bash$ sfspike n1=100 > vec.rsf
bash$ sfdottest sfcausint mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=1410.2
sfdottest: L'[d]*m=1410.2
bash$ sfdottest sfcausint mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=1165.87
sfdottest: L'[d]*m=1165.87
\end{verbatim}
The numbers are different on subsequent runs because of changing
seed in the random number generator.

Here is a somewhat more complicated example. The \texttt{sfhelicon}
program implements Claerbout's multidimensional helical filtering
\cite[]{GEO63-05-15321541}. It requires a filter to be specified in
addition to the input and output vectors. We create a helical 
2-D filter using the Unix \texttt{echo} command.
\begin{verbatim}
bash$ echo 1 19 20 n1=3 n=20,20 data_format=ascii_int in=lag.rsf > lag.rsf
bash$ echo 1 1 1 a0=-3 n1=3 data_format=ascii_float in=flt.rsf > flt.rsf
\end{verbatim}
Next, we create an example 2-D model and data vector with \texttt{sfspike}.
\begin{verbatim}
bash$ sfspike n1=50 n2=50 > vec.rsf
\end{verbatim}
Now the \texttt{sfdottest} program can perform the dot product test.
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf
sfdottest:  L[m]*d=8.97375
sfdottest: L'[d]*m=8.97375
\end{verbatim}
Here is the same program tested in the inverse filtering mode:
\begin{verbatim}
bash$ sfdottest sfhelicon filt=flt.rsf lag=lag.rsf \
> mod=vec.rsf dat=vec.rsf inv=y
sfdottest:  L[m]*d=15.0222
sfdottest: L'[d]*m=15.0222
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfget}
}}

The \texttt{sfget} program extracts a parameter value from an RSF file. It is
useful mostly for scripting. Here is, for example, a quick calculation of the
maximum value on the first axis in an RSF dataset (the output of
\texttt{sfspike}) using the standard Unix \texttt{bc} calculator.
\begin{verbatim}
bash$ ( sfspike n1=100 | sfget n1 d1 o1; echo "o1+(n1-1)*d1" ) | bc
.396
\end{verbatim}
See also \texttt{sfput}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheaderattr}
}}

The \texttt{sfheaderattr} examines the contents of a trace header file,
typically generated by \texttt{sfsegyread}. In the example below, we examine
trace headers in the output of \texttt{suplane}, a program from Seismic Unix.
\begin{verbatim}
bash$ suplane > plane.su
bash$ sfsegyread tape=plane.su su=y tfile=tfile.rsf > plane.rsf
bash$ sfheaderattr < tfile.rsf
*******************************************
71 headers, 32 traces
key[0]="tracl"      min[0]=1            max[31]=32          mean=16.5
key[1]="tracr"      min[0]=1            max[31]=32          mean=16.5
key[11]="offset"    min[0]=400          max[31]=400         mean=400
key[38]="ns"        min[0]=64           max[31]=64          mean=64
key[39]="dt"        min[0]=4000         max[31]=4000        mean=4000
*******************************************
\end{verbatim}
For different standard keywords, a minimum, maximum, and mean values
are reported unless they are identically zero.  This quick inspection
can help in identifying meaningful keywords set in the data. The input
data type must be \texttt{int}.


\noindent\doublebox{\parbox{\textwidth}{
    \input{sfheadercut}
  }}

\texttt{sfheadercut} is close to \texttt{sfheaderwindow} but instead
of windowing the dataset, it fills the traces specified by the header
mask with zeroes. The size of the input data is preserved.

Here is an example of using \texttt{sfheaderwindow} for 
zeroing every other trace in the input file. First, let us create
an input file with ten traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=10 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7
  35:             8            8            8            8            8
  40:             9            9            9            9            9
  45:            10           10           10           10           10
\end{verbatim}
Next, we can create a mask with alternating ones and zeros using
\texttt{sfinterleave}.
\begin{verbatim}
bash$ sfspike n1=5 mag=1 | sfdd type=int > ones.rsf
bash$ sfspike n1=5 mag=0 | sfdd type=int > zeros.rsf
bash$ sfinterleave axis=1 ones.rsf zeros.rsf > mask.rsf
bash$ sfdisfil < mask.rsf
   0:    1    0    1    0    1    0    1    0    1    0
\end{verbatim}
Finally, \texttt{sfheadercut} zeros the input traces.
\begin{verbatim}
bash$ sfheadercut < input.rsf mask=mask.rsf > output.rsf
bash$ sfdisfil < output.rsf 
   0:             1            1            1            1            1
   5:             0            0            0            0            0
  10:             3            3            3            3            3
  15:             0            0            0            0            0
  20:             5            5            5            5            5
  25:             0            0            0            0            0
  30:             7            7            7            7            7
  35:             0            0            0            0            0
  40:             9            9            9            9            9
  45:             0            0            0            0            0
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheadermath}
}}

\texttt{sfheadermath} is a versatile program for mathematical
operations on rows of the input file. If the input file is an
\texttt{n1} by \texttt{n2} matrix, the output will be a \texttt{1} by
\texttt{n2} matrix that contains one row made out of mathematical
operations on the other rows. \texttt{sfheadermath} can identify a row
by number or by a standard SEGY keyword. The latter is useful for
processing headers extracted from SEGY or SU files.

Here is an example. First, we create an SU file with \texttt{suplane} and convert it to RSF using \texttt{sfsegyread}.
\begin{verbatim}
bash$ suplane > plane.su
bash$ sfsegyread tape=plane.su su=y tfile=tfile.rsf > plane.rsf
\end{verbatim}
The trace header information is saved in \texttt{tfile.rsf}. It
contains 71 headers for 32 traces in integer format.
\begin{verbatim}
bash$ sfin tfile.rsf
tfile.rsf:
    in="/tmp/tfile.rsf@"
    esize=4 type=int form=native
    n1=71          d1=?           o1=?
    n2=32          d2=?           o2=?
        2272 elements 9088 bytes
\end{verbatim}
Next, we will convert \texttt{tfile.rsf} to a floating-point format
and run \texttt{sfheadermath} to create a new header.
\begin{verbatim}
bash$ < tfile.rsf sfdd type=float | \
sfheadermath myheader=1 output="sqrt(myheader+(2+10*offset^2))" > new.rsf
bash$ sfin new.rsf
new.rsf:
    in="/tmp/new.rsf@"
    esize=4 type=float form=native
    n1=1           d1=?           o1=?
    n2=32          d2=?           o2=?
        32 elements 128 bytes
\end{verbatim}
We defined ``myheader'' as being the row number 1 in the input (note
that numbering starts with 0) and combined it with ``offset'', which
is a standard SEGY keyword that denotes row number 11 (see the output
of \texttt{sfheaderattr} above.) A variety of mathematical expressions
can be defined in the \texttt{output=} string. The expression
processing engine is shared with \texttt{sfmath}.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheadersort}
}}

\texttt{sfheadersort} is used to sort traces in the input file
according to trace header information. 

Here is an example of using
\texttt{sfheadersort} for randomly shuffling traces in the input
file. First, let us create an input file with seven traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=7 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7 
\end{verbatim}
Next, we can create a random file with seven header values using
\texttt{sfnoise}.
\begin{verbatim}
bash$ sfspike n1=7 | sfnoise rep=y type=n > random.rsf
bash$ < random.rsf sfdisfil
   0:       0.05256      -0.2879       0.1487       0.4097       0.1548
   5:        0.4501       0.2836
\end{verbatim}
If you reproduce this example, your numbers will most likely be different,
because, in the absence of \texttt{seed=} parameter, \texttt{sfnoise}
uses a random seed value to generate pseudo-random numbers. Finally, we
apply \texttt{sfheadersort} to shuffle the input traces.
\begin{verbatim}
bash$ < input.rsf sfheadersort head=random.rsf > output.rsf
bash$ < output.rsf sfdisfil
   0:             2            2            2            2            2
   5:             1            1            1            1            1
  10:             3            3            3            3            3
  15:             5            5            5            5            5
  20:             7            7            7            7            7
  25:             4            4            4            4            4
  30:             6            6            6            6            6
\end{verbatim}
As expected, the order of traces in the output file corresponds to the
order of values in the header. Thanks to the separation between
headers and data, the operation of \texttt{sfheadersort} is optimally
efficient. It first sorts the headers and only then accesses the data,
reading each data trace only once.

\noindent\doublebox{\parbox{\textwidth}{
\input{sfheaderwindow}
}}

\texttt{sfheaderwindow} is used to window traces in the input file
according to trace header information. 

Here is an example of using \texttt{sfheaderwindow} for randomly
selecting part of the traces in the input file. First, let us create
an input file with ten traces:
\begin{verbatim}
bash$ sfmath n1=5 n2=10 output=x2+1 > input.rsf
bash$ < input.rsf sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             3            3            3            3            3
  15:             4            4            4            4            4
  20:             5            5            5            5            5
  25:             6            6            6            6            6
  30:             7            7            7            7            7
  35:             8            8            8            8            8
  40:             9            9            9            9            9
  45:            10           10           10           10           10
\end{verbatim}
Next, we can create a random file with ten header values using
\texttt{sfnoise}.
\begin{verbatim}
bash$ sfspike n1=10 | sfnoise rep=y type=n > random.rsf
bash$ < random.rsf sfdisfil
   0:     -0.005768      0.02258     -0.04331      -0.4129      -0.3909
   5:      -0.03582       0.4595      -0.3326        0.498      -0.3517
\end{verbatim}
If you reproduce this example, your numbers will most likely be different,
because, in the absence of \texttt{seed=} parameter, \texttt{sfnoise}
uses a random seed value to generate pseudo-random numbers. Finally,
we apply \texttt{sfheaderwindow} to window the input traces selecting
only those for which the header is greater than zero.
\begin{verbatim}
bash$ < random.rsf sfmask min=0 > mask.rsf
bash$ < mask.rsf sfdisfil
   0:    0    1    0    0    0    0    1    0    1    0
bash$ < input.rsf sfheaderwindow mask=mask.rsf > output.rsf
bash$ < output.rsf sfdisfil
   0:             2            2            2            2            2
   5:             7            7            7            7            7
  10:             9            9            9            9            9
\end{verbatim}
In this case, only three traces are selected for the output. Thanks to
the separation between headers and data, the operation of
\texttt{sfheaderwindow} is optimally efficient. 

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfin}
  }}

\texttt{sfin} is one of the most useful programs for operating with
RSF files. It produces quick information on the file hypercube
dimensions and checks the consistency of the associated data file.

Here is an example. Let us create an RSF file and examine it with \texttt{sfin}.
\begin{verbatim}
bash$ sfspike n1=100 n2=20 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/tmp/spike.rsf@"
    esize=4 type=float form=native
    n1=100         d1=0.004       o1=0          label1="Time" unit1="s"
    n2=20          d2=0.1         o2=0          label2="Distance" unit2="km"
        2000 elements 8000 bytes
\end{verbatim}
\texttt{sfin} reports the following information:
\begin{itemize}
\item location of the data file (\texttt{/tmp/spike.rsf\@})
\item element size (4 bytes)
\item element type (floating point)
\item element form (native)
\item hypercube dimensions (100 by 20)
\item axes scale (0.004 and 0.1)
\item axes origin (0 and 0)
\item axes labels
\item axes units
\item total number of elements
\item total number of bytes in the data file
\end{itemize}

Suppose that the file got corrupted by a buggy program and reports
incorrect dimensions. The \texttt{sfin} program should be able to
catch the discrepancy.
\begin{verbatim}
bash$ echo n2=100 >> spike.rsf
bash$ sfin spike.rsf > /dev/null
sfin:           Actually 8000 bytes, 20% of expected.
\end{verbatim}

\texttt{sfin} also checks the first records in the file for zeros. 
\begin{verbatim}
bash$ sfspike n1=100 n2=100 k2=99 > spike2.rsf
bash$ sfin spike2.rsf >/dev/null
sfin: The first 32768 bytes are all zeros
\end{verbatim}
The number of bytes to check is adjustable
\begin{verbatim}
bash$ sfin spike2.rsf check=0.01 >/dev/null
sfin: The first 16384 bytes are all zeros
\end{verbatim}

You can also output only the location of the data file. This is
sometimes handy in scripts.
\begin{verbatim}
bash$ sfin spike.rsf spike2.rsf info=n
/tmp/spike.rsf@ /tmp/spike2.rsf@
\end{verbatim}
An alternative is to use \texttt{sfget}, as follows:
\begin{verbatim}
bash$ sfget parform=n in < spike.rsf
/tmp/spike.rsf@
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfinterleave}
  }}

\texttt{sfinterleave} combines two or more datasets by interleaving them on one
of the axes. Here is a quick example:
\begin{verbatim}
bash$ sfspike n1=5 n2=5 > one.rsf
bash$ sfdisfil < one.rsf
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ sfscale < one.rsf dscale=2 > two.rsf
bash$ sfdisfil < two.rsf
   0:             2            2            2            2            2
   5:             2            2            2            2            2
  10:             2            2            2            2            2
  15:             2            2            2            2            2
  20:             2            2            2            2            2
bash$ sfinterleave one.rsf two.rsf axis=1 | sfdisfil
   0:             1            2            1            2            1
   5:             2            1            2            1            2
  10:             1            2            1            2            1
  15:             2            1            2            1            2
  20:             1            2            1            2            1
  25:             2            1            2            1            2
  30:             1            2            1            2            1
  35:             2            1            2            1            2
  40:             1            2            1            2            1
  45:             2            1            2            1            2
bash$ sfinterleave < one.rsf two.rsf axis=2 | sfdisfil
   0:             1            1            1            1            1
   5:             2            2            2            2            2
  10:             1            1            1            1            1
  15:             2            2            2            2            2
  20:             1            1            1            1            1
  25:             2            2            2            2            2
  30:             1            1            1            1            1
  35:             2            2            2            2            2
  40:             1            1            1            1            1
  45:             2            2            2            2            2
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfmask}
  }}

\texttt{sfmask} creates an integer output of ones and zeros comparing
the values of the input data to specified \texttt{min=} and
\texttt{max=} parameters. It is useful for \texttt{sfheaderwindow} and
in many other applications. Here is a quick example:
\begin{verbatim}
bash$ sfmath n1=10 output="sin(x1)" > sin.rsf
bash$ < sin.rsf sfdisfil
   0:             0       0.8415       0.9093       0.1411      -0.7568
   5:       -0.9589      -0.2794        0.657       0.9894       0.4121
bash$ < sin.rsf sfmask min=-0.5 max=0.5 | sfdisfil
   0:    1    0    0    1    0    0    1    0    0    1
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfmath}
  }}

\inputdir{sfmath}

\texttt{sfmath} is a versatile program for mathematical operations
with RSF files. It can operate with several input file, all of the
same dimensions and data type. The data type can be real (floating
point) or complex. Here is an example that demonstrates several
features of \texttt{sfmath}.
\begin{verbatim}
bash$ sfmath n1=600 d1=0.01 o1=0 n2=40 d2=1 o2=5 \
output="x2*(8+sin(6*x1+x2/10))" > rad.rsf
bash$ < rad.rsf sfrtoc | sfmath output="input*exp(I*x1)" > rose.rsf
bash$ < rose.rsf sfgraph title=Rose screenratio=1 wantaxis=n | xtpen
\end{verbatim}

The first line creates a 2-D dataset that consists of 40 traces 600
samples each. The values of the data are computed with the formula
\verb#"x2*(8+sin(6*x1+x2/10))"#, where \texttt{x1} refers to the
coordinate on the first axis, and \texttt{x2} is the coordinate of the
second axis. In the second line, we convert the data from real to
complex using \texttt{sfrtoc} and produce a complex dataset using
formula \verb#"input*exp(I*x1)"#, where \texttt{input} refers to the
input file. Finally, we plot the complex data as a collection of
parametric curves using \texttt{sfgraph} and display the result using
\texttt{xtpen}.  The plot appearing on your screen should look similar
to Figure~\ref{fig:rose}.

\plot{rose}{width=0.6\textwidth}{This figure was created with \texttt{sfmath}.}

One possible alternative to the second line above is
\begin{verbatim}
bash$ < rad.rsf sfmath output=x1 > ang.rsf
bash$ sfmath r=rad.rsf a=ang.rsf output="r*cos(a)" > cos.rsf
bash$ sfmath r=rad.rsf a=ang.rsf output="r*sin(a)" > sin.rsf
bash$ sfcmplx cos.rsf sin.rsf > rose.rsf
\end{verbatim}
Here we refer to input files by names (\texttt{r} and \texttt{a}) and combine the names in a formula.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfpad}
  }}

\texttt{pad} increases the dimensions of the input dataset by padding
the data with zeroes. Here are some simple examples.

\begin{verbatim}
bash$ sfspike n1=5 n2=3 > one.rsf
bash$ sfdisfil < one.rsf
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
bash$ < one.rsf sfpad n2=5 | sfdisfil
   0:             1            1            1            1            1
   5:             1            1            1            1            1
  10:             1            1            1            1            1
  15:             0            0            0            0            0
  20:             0            0            0            0            0
bash$ < one.rsf sfpad beg2=2 | sfdisfil
   0:             0            0            0            0            0
   5:             0            0            0            0            0
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ < one.rsf sfpad beg2=1 end2=1 | sfdisfil
   0:             0            0            0            0            0
   5:             0            0            0            0            0
  10:             1            1            1            1            1
  15:             1            1            1            1            1
  20:             1            1            1            1            1
bash$ < one.rsf sfwindow n1=3 | sfpad n1=5 n2=5 beg1=1 beg2=1 | sfdisfil
   0:             0            0            0            0            0
   5:             0            1            1            1            0
  10:             0            1            1            1            0
  15:             0            1            1            1            0
  20:             0            0            0            0            0
\end{verbatim}
You can use \texttt{sfcat} to pad data with values other than zeroes.

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfput}
  }}

\texttt{sfput} is a very simple program. It simply appends parameters
from the command line to the output RSF file. One can achieve similar
results with editing by hand or with standard Unix utilities like
\texttt{sed} and \texttt{echo}. \texttt{sfput} is sometimes more
convenient because it handles input/output operations similarly to
other regular RSF programs.

\begin{verbatim}
bash$ sfspike n1=10 > spike.rsf
bash$ sfin spike.rsf
spike.rsf:
    in="/tmp/spike.rsf@"
    esize=4 type=float form=native
    n1=10          d1=0.004       o1=0          label1="Time" unit1="s"
        10 elements 40 bytes
bash$ sfput < spike.rsf d1=25 label1=Depth unit1=m > spike2.rsf
bash$ sfin spike2.rsf
spike2.rsf:
    in="/tmp/spike2.rsf@"
    esize=4 type=float form=native
    n1=10          d1=25          o1=0          label1="Depth" unit1="m"
        10 elements 40 bytes
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfreal}
  }}

\texttt{sfreal} extracts the real part of a complex type dataset. The
imaginary part can be extracted with \texttt{sfimag}, an the real
and imaginary part can be combined together with \texttt{sfcmplx}.


Here is a simple example. Let us first create a complex dataset 
with \texttt{sfmath}
\begin{verbatim}
bash$ sfmath n1=10 type=complex output="(2+I)*x1" > cmplx.rsf
bash$ fdisfil < cmplx.rsf
   0:          0,         0i         2,         1i         4,         2i
   3:          6,         3i         8,         4i        10,         5i
   6:         12,         6i        14,         7i        16,         8i
   9:         18,         9i
\end{verbatim}
Extracting the real part with \texttt{sfreal}:
\begin{verbatim}
bash$ sfreal < cmplx.rsf | sfdisfil
   0:             0            2            4            6            8
   5:            10           12           14           16           18
\end{verbatim}
Extracting the imaginary part with \texttt{sfimag}:
\begin{verbatim}
bash$ sfimag < cmplx.rsf | sfdisfil
   0:             0            1            2            3            4
   5:             5            6            7            8            9
\end{verbatim}

\noindent\doublebox{\parbox{\textwidth}{
    \input{sfreverse}
  }}

Here is an example of using \texttt{sfreverse}. First, let us create a
2-D dataset.
\begin{verbatim}
bash$ sfmath n1=5 d1=1 n2=3 d2=1 output=x1+x2 > test.rsf
bash$ < test.rsf sfdisfil
   0:             0            1            2            3            4
   5:             1            2            3            4            5
  10:             2            3            4            5            6
\end{verbatim}
Reversing the first axis:
\begin{verbatim}
bash$ < test.rsf sfreverse which=1 | sfdisfil
   0:             4            3            2            1            0
   5:             5            4            3            2            1
  10:             6            5            4            3            2
\end{verbatim}
Reversing the second axis:
\begin{verbatim}
bash$ < test.rsf sfreverse which=2 | sfdisfil
   0:             2            3            4            5            6
   5:             1            2            3            4            5
  10:             0            1            2            3            4
\end{verbatim}
Reversing both the first and the second axis:
\begin{verbatim}
bash$ < test.rsf sfreverse which=3 | sfdisfil
   0:             2            3            4            5            6
   5:             1            2            3            4            5
  10:             0            1            2            3            4
\end{verbatim}
As you can see, the \texttt{which=} parameter controls the axes that are
being reversed by encoding them into one number.

When an axis is reversed, what happens with its axis origin and
sampling parameters? This behavior is controlled by \texttt{opt=}. In
our example,
\begin{verbatim}
bash$ < test.rsf sfget n1 o1 d1
n1=5
o1=0
d1=1
bash$ < test.rsf sfreverse which=1 | sfget o1 d1
o1=4
d1=-1
\end{verbatim}
The default behavior (equivalent to \texttt{opt=y}) puts the origin
\texttt{o1} at the end of the axis and reverses the sampling parameter
\texttt{d1}.  Using \texttt{opt=n} preserves the sampling but reverses
the origin.
\begin{verbatim}
bash$ < test.rsf sfreverse which=1 opt=n | sfget o1 d1
o1=-4
d1=1
\end{verbatim}
Using \texttt{opt=i} preserves both the sampling and the origin while
reversing the axis.
\begin{verbatim}
bash$ < test.rsf sfreverse which=1 opt=i | sfget o1 d1
o1=0
d1=1
\end{verbatim}
One of the three possible behaviors may be desirable depending on the
application.

\bibliographystyle{seg}
\bibliography{SEG}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
