/* 2-D One-way nonstationary phase-shift PSDM using low-rank approximation

   Copyright (C) 2013 Tongji University, Shanghai, China 
   Authors: Jiubing Cheng
     
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
             
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
                   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#include <rsf.hh>
#include <assert.h>

/* low rank decomposition  */
#include "vecmatop.hh"
#include "serialize.hh"

using namespace std;

/* prepared head files by myself */
#include "_cjb.h"

/*#include "_fd.h" 
 * when _fd.h has declared "m", we met compiling error at "m2=mid.m()";
 * "expected unqualified-id before numeric constant" 
*/
/* head files aumatically produced from C programs */
extern "C"{
#include "zero.h"
#include "ricker.h"
#include "kykxkztaper.h"
#include "onewaypsdmlowrank.h"
}

static std::valarray<float> vp,wvp2;

static std::valarray<double> kx2;

/* dual-domain phase shift one-way wave propagator based on low-rank decomp. */
int sampleup(vector<int>& rs, vector<int>& cs, CpxNumMat& resx, int iz, int iw, int nxw, int nx);
int sampledo(vector<int>& rs, vector<int>& cs, CpxNumMat& resx, int iz, int iw, int nxw, int nx);

static void map2d1d(sf_complex *d, CpxNumMat mat, int m, int n);
/*****************************************************************************************/
int main(int argc, char* argv[])
{
   sf_init(argc,argv);

   clock_t t1, t2, t3, t4, t5, t44;
   float   timespent;

   t1=clock();

   iRSF par(0);
   int seed;
   par.get("seed",seed,time(NULL)); // seed for random number generator
   srand48(seed);

   float eps;
   par.get("eps",eps,1.e-6); // tolerance
       
   int npk;
   par.get("npk",npk,20); // maximum rank

   int   ns;
   float dt, f1, f2;

   par.get("ns",ns);
   par.get("dt",dt);
   par.get("f1",f1);
   par.get("f2",f2);

   sf_warning("ns=%d dt=%f",ns,dt);
   sf_warning("npk=%d ",npk);
   sf_warning("eps=%f",eps);
   sf_warning("read velocity model parameters");

   float dw=2.0*PI/(ns*dt);
   float fw=2.0*PI*f1;
   float ew=2.0*PI*f2;

   int   nw=(ew-fw)/dw+1;
   sf_warning("nw=%d dw=%f",nw,dw);
   
   /* setup I files */
   iRSF vp0;

   /* Read/Write axes */
   int nxv, nzv;
   vp0.get("n1",nzv);
   vp0.get("n2",nxv);

   float az, ax;
   vp0.get("o1",az);
   vp0.get("o2",ax);

   float fx, fz;
   fx=ax*1000.0;
   fz=az*1000.0;

   float dx, dz;
   vp0.get("d1",az);
   vp0.get("d2",ax);
   dz = az*1000.0;
   dx = ax*1000.0;

   /* wave modeling space */
   int nx, nz, nxz, nxzw;
   nx=nxv;
   nz=nzv;
   nxz=nx*nz;
   nxzw=nx*nz*nw;

   vp.resize(nxz);
   wvp2.resize(nxzw);
 
   vp0>>vp;

   /* Fourier spectra demension */
   int nk;
   nk = nx;

   float dkx,kx0;

   dkx=2*PI/dx/nx;
   kx0=-PI/dx;

   kx2.resize(nk);

   double kx, w, w2;
   int    i=0, j=0, k=0, ix, iz, ixz, iw;
   
   j=0;
   for(iz=0; iz < nz; iz++)
   for(iw=0; iw < nw; iw++)
   {
      w = fw + iw*dw;
      w2= w*w; 
      for(ix=0; ix < nx; ix++)
      {
         ixz=ix*nz+iz;
         //wvp2[j] = w2/(vp[ixz]*vp[ixz]);  //prestack
         wvp2[j] = w2/(0.25*vp[ixz]*vp[ixz]); // poststack
         j++;
      }
   }

   for(ix=0; ix < nk; ix++)
   {
       kx = kx0+ix*dkx;
       kx2[ix] = kx*kx;
   }

   t2=clock();
   timespent=(float)(t2-t1)/CLOCKS_PER_SEC;
   sf_warning("CPU time for prereparing for low-rank decomp: %f(second)",timespent);

   /* setup I/O files */
   oRSF Mig("out");
   Mig.put("n1",nz);
   Mig.put("n2",nx);
   Mig.put("d1",dz/1000);
   Mig.put("d2",dx/1000);
   Mig.put("o1",fz/1000);
   Mig.put("o2",fx/1000);

   vector<int> md(nxz), nd(nk);
   for (k=0; k < nx; k++)  md[k] = k;
   for (k=0; k < nk; k++)  nd[k] = k;

   vector<int> lid, rid;
   CpxNumMat mid, mat;

   int *ijkx = sf_intalloc(nk);
   ikx(ijkx, nk);

   // set surface receiver gathers
   sf_complex **u, *u1;
   u = sf_complexalloc2(nx,nw);
   u1 = sf_complexalloc(nx);

   // set image
   float **mig;
   mig = sf_floatalloc2(nz, nx);
 
   // impulse time
   float time=1.0;
   for(iw=0;iw<nw;iw++){
      w=fw+iw*dw;
      u[iw][nx/2] = sf_cmplx(0.0, -w*time);
   }
      
   for(iz=0;iz<nz;iz++)
   {
       for(ix=0;ix<nx;ix++)
          mig[ix][iz] = 0.0;
       
     for(iw=0;iw<nw;iw++)
     {
       /********* low rank approximation of one-way phase-shift operator **********/
       int   m2up, n2up, m2do, n2do;
       sf_complex *ldataup, *fmidup, *rdataup;
       sf_complex *ldatado, *fmiddo, *rdatado;

       iC( lowrankcjb(nx,nk,sampleup,eps,npk,lid,rid,mid) );
       m2up=mid.m();
       n2up=mid.n();
       sf_warning("m2up=%d n2up=%d",m2up, n2up);

       fmidup  = sf_complexalloc(m2up*n2up);
       ldataup = sf_complexalloc(nx*m2up);
       rdataup = sf_complexalloc(n2up*nk);

       map2d1dc(fmidup, mid, m2up, n2up);

       iC ( sampleup(md,lid,mat,iz,iw,nxw,nx) );
       map2d1d(ldataup, mat, nxz, m2up);

       iC ( sampleup(rid,nd,mat,iz,iw,nxw,nx) );
       map2d1d(rdataup, mat, n2up, nk);

       for(ix=0;ix<nx;ix++) u1[ix]=u[iw][ix];

       psuplowrank2d(ldataup,rdataup,fmidup,u1,ijkx,nx,nk,m2up,n2up);

       // imaging condition
       for(ix=0;ix<nx;ix++){
          u[iw][ix]= u1[ix];
          mig[ix][iz] += u1[ix];
       }

       free(ldataup);
       free(ldatado);
       free(rdataup);
       free(rdatado);
       free(fmidup);
       free(fmiddo);
     }// iw
   }//iz
 
   /****************End of Calculating Projection Deviation Operator****************/
   t3=clock();
   timespent=(float)(t3-t2)/CLOCKS_PER_SEC;
   sf_warning("CPU time for low-rank decomp: %f(second)",timespent);

   free(ijkx);
   free(*u);
   free(u1);
   free(*mig);
exit(0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/* one-way upward phase shift operator */
int sampleup(vector<int>& rs, vector<int>& cs, CpxNumMat& resx, int iz, int iw, int nxw, int nx)
{
    int nr = rs.size();
    int nc = cs.size();

    resx.resize(nr,nc);

    setvalue(resx,1.0);

    for(int a=0; a<nr; a++) 
    {
        int i=rs[a];
        int ii=iz*nxw+iw*nx;
        double wvp2 = wvp2[ii+i];

        for(int b=0; b<nc; b++)
        {
            double  k2=kx2[cs[b]];

            double tmp=wvp2-k2;
            if(tmp>=0.0)
               resx(a,b) = cexp(cmplx(0.0, -dz*sqrt(tmp)));
            else
               resx(a,b) = cexp(-dz*sqrt(-tmp));
              
         }// b loop
    }// a loop

    return 0;
}

/* one-way downward phase shift operator */
int sampledo(vector<int>& rs, vector<int>& cs, CpxNumMat& resx, int iz, int iw, int nxw, int nx)
{
    int nr = rs.size();
    int nc = cs.size();

    resx.resize(nr,nc);

    setvalue(resx,1.0);

    for(int a=0; a<nr; a++) 
    {
        int i=rs[a];
        int ii=iz*nxw+iw*nx;
        double wvp2 = wvp2[ii+i];

        for(int b=0; b<nc; b++)
        {
            double  k2=kx2[cs[b]];

            double tmp=wvp2-k2;
            if(tmp>=0.0)
               resx(a,b) = cexp(cmplx(0.0, dz*sqrt(tmp)));
            else
               resx(a,b) = cexp(-dz*sqrt(-tmp));
              
         }// b loop
    }// a loop

    return 0;
}

static void map2d1dc(sf_complex *d, CpxNumMat mat, int m, int n)
{
   int i, j, k;
   k=0;
   for (i=0; i < m; i++)
   for (j=0; j < n; j++)
   {
        d[k] = mat(i,j);
        k++;
   }

}
