#!/usr/bin/env python
# next steps:
# does lock block second task?
# add change back to not running at end of task
# write code in myproj to build hosts.txt
# run test on stampede

import fcntl, os, string, sys

class Hosts(object):
    def __init__(self,hosts_file=None):
        if not hosts_file:
            hosts_file=os.environ.get('RSF_HOSTS','hosts.txt') # use RSFROOT default
        try:
            self.hosts_fd=open(hosts_file,'r+')
        except:
            sys.stderr.write('Trouble opening hosts file "%s"\n' % hosts_file)
            sys.exit(1)

        #hosts.txt file contains:
        # line 1 is "numnodes" space and number nodes in i4 format with leading 0's
        # line 2 is headers "host" and "state"
        # line 3 through numnodes+2 is host names (40 char long blank padded) and
        #        either notrunning or running.  record is padded to 80 characters 
        # fields are fixed length so when state changes the file size does not change

        self.host = None

    def start(self):
        'lock hosts.txt, get notrunning node, mark it running, unlock hosts.txt'
        
        fcntl.lockf(self.hosts_fd,fcntl.LOCK_EX)

        # get notrunning node, mark it running
        hosts_txt=self.hosts_fd.readlines()
        self.numnodes=int(string.split(hosts_txt[0])[1])

        idle_node=-1
        for node in range(self.numnodes):
            if(string.split(hosts_txt[2+node])[1]=='notrunning'):
                idle_node=node
                break
            
        if -1==idle_node:
            sys.stderr.write('sfnode: Looking for an idle node in hosts.txt,\n'
                             'but all %d nodes are running.' % self.numnodes) 
            sys.exit(1)
    
        self.host=string.split(hosts_txt[2+idle_node])[0]
        hosts_txt[2+idle_node]=string.ljust(self.host,40)+string.ljust("running",10)+"\n"

        self.hosts_fd.seek(0)   
        for line in hosts_txt:
            self.hosts_fd.write(line)
        self.hosts_fd.flush()   # need to do this or file does not change

        fcntl.lockf(self.hosts_fd,fcntl.LOCK_UN)
        #print "hosts_fd.txt unlocked"

    def run(self,command):
        'runs command on the available host'
        
        if not self.host:
            sys.stderr.write('Need to run start first\n')
            sys.exit(3)
            
        print 'runonnode: running command on %s' % self.host
        
        task="ssh "+self.host+' \"'+command+' \"'

        os.system('date')
        return os.system(task)

    def stop(self):
        'lock hosts.txt, mark the node notrunning, unlock hosts.txt'

        if not self.host:
            sys.stderr.write('Need to run start first\n')
            sys.exit(3)
        
        fcntl.lockf(self.hosts_fd,fcntl.LOCK_EX)
        self.hosts_fd.seek(0)   
        hosts_txt=self.hosts_fd.readlines()
        hosts_txt[2+idle_node]=string.ljust(self.host,40)+string.ljust("notrunning",10)+"\n"

        self.hosts_fd.seek(0)   
        for line in hosts_txt:
            self.hosts_fd.write(line)
        self.hosts_fd.flush()   # this will actually mode buffer to output file

        fcntl.lockf(self.hosts_fd,fcntl.LOCK_UN)

    def __del__(self):
        self.hosts_fd.close()

if __name__ == "__main__":
    hosts = Hosts(sys.argv[1])

    hosts.start()
    retcode = hosts.run(' '.join(sys.argv[2:]))
    hosts.stop()

    sys.exit(retcode)

