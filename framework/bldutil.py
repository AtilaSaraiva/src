import glob, os, re, string, py_compile
import configure

# The following adds all SCons SConscript API to the globals of this module.
import SCons
version = map(int,string.split(SCons.__version__,'.')[:3])
if version[0] == 1  or \
   version[1] >= 97 or \
   (version[1] == 96 and version[2] >= 90):
    from SCons.Script import *
else:  # old style
    import SCons.Script.SConscript
    globals().update(SCons.Script.SConscript.BuildDefaultGlobals())

################################################################################

# Constants used in multiple functions. Internal to module.

__py_success = 0 # user-defined
__include = re.compile(r'#include\s*\"([^\"]+)\.h\"')
__local_include = re.compile(r'\s*\#include\s*\"([^\"]+)')

################################################################################

def __includes(list,file):
    global __local_include
    fd = open(file,'r')
    for line in fd.readlines():
         match = __local_include.match(line)
         if match:
             other = os.path.join(os.path.dirname(file),match.group(1))
             if not other in list:
                 __includes(list,other)
    list.append(file)
    fd.close()

def merge(target=None,source=None,env=None):
    global __local_include
    sources = map(str,source)
    incs = []
    for src in sources:
        if not src in incs:
            __includes(incs,src)
    out = open(str(target[0]),'w')
    for src in incs:
        inp = open(src,'r')
        for line in inp.readlines():
            if not __local_include.match(line):
                out.write(line)
        inp.close()
    out.close()
    return __py_success

################################################################################

def __included(node,env,path):
    file = os.path.basename(str(node))
    file = re.sub('\.[^\.]+$','',file)
    contents = node.get_contents()
    includes = __include.findall(contents)
    if file in includes:
        includes.remove(file)
    return map(lambda x: x + '.h',includes)

Include = Scanner(name='Include', function=__included, skeys=['.c'])

################################################################################

def __header(target=None,source=None,env=None):
    'generate a header file'
    inp = open(str(source[0]),'r')
    text = string.join(inp.readlines(),'')
    inp.close()
    file = str(target[0])
    prefix = env.get('prefix','')
    define = prefix + string.translate(os.path.basename(file),
                                       string.maketrans('.','_'))
    out = open(file,'w')
    out.write('/* This file is automatically generated. DO NOT EDIT! */\n\n')
    out.write('#ifndef _' + define + '\n')
    out.write('#define _' + define + '\n\n')
    toheader = re.compile(r'\n((?:\n[^\n]+)+)\n'                     
                      '\s*\/\*(\^|\<(?:[^>]|\>[^*]|\>\*[^/])*\>)\*\/')
    kandr = re.compile(r'\s*\{?\s*$') # K&R style function defs end with {
    for extract in toheader.findall(text):
        if extract[1] == '^':
            out.write(extract[0]+'\n\n')
        else:
            function = kandr.sub('',extract[0])
            out.write(function+';\n')
            out.write('/*'+extract[1]+'*/\n\n')
    out.write('#endif\n')
    out.close()
    return __py_success

Header = Builder (action = Action(__header,varlist=['prefix']),
                  src_suffix='.c',suffix='.h')

################################################################################

def __docmerge(target=None,source=None,env=None):
    outfile = target[0].abspath
    out = open(outfile,'w')
    out.write('import rsf.doc\n\n')
    for src in map(str,source):
        inp = open(src,'r')
        for line in inp.readlines():
                out.write(line)
        inp.close()
    alias = env.get('alias',{})
    for prog in alias.keys():
        out.write("rsf.doc.progs['%s']=%s\n" % (prog,alias[prog]))
    out.close()
    print outfile
    py_compile.compile(outfile,outfile+'c')
    return __py_success

def __pycompile_emit(target, source, env):
    target.append(str(target[0])+'c')
    return target,source 

Docmerge = Builder(action=Action(__docmerge,varlist=['alias']),
                   emitter=__pycompile_emit)

################################################################################

def __placeholder(target=None,source=None,env=None):
    filename = str(target[0])
    out = open(filename,'w')
    var = env.get('var')
    out.write('#!/usr/bin/env python\n')
    out.write('import sys\n\n')
    out.write('sys.stderr.write(\'\'\'\n%s is not installed.\n')
    if var:
        out.write('Check $RSFROOT/etc/madagascar/config.py for ' + var)
        out.write('\nand reinstall if necessary.')
    message = env.get('message')
    if message:
        out.write(message)
    package = env.get('package')
    if package:
        out.write('\nPossible missing packages: ' + package)
    out.write('\n\'\'\' % sys.argv[0])\nsys.exit(1)\n')
    out.close()
    os.chmod(filename,0775)
    return __py_success

Place = Builder (action = Action(__placeholder,varlist=['var','package']))

################################################################################

def __pycompile(target, source, env):
    "convert py to pyc "
    for i in range(0,len(source)):
        py_compile.compile(source[i].abspath,target[i].abspath)
    return __py_success

Pycompile = Builder(action=__pycompile)

################################################################################

def Debug():
    'Environment for debugging'
    env = Environment()
    srcroot = os.environ.get('RSFSRC', '../..')
    opts = configure.options(os.path.join(srcroot,'config.py'))
    opts.Update(env)
    env['CCFLAGS'] = env.get('CCFLAGS','').replace('-O2','-g')
    if  env['PLATFORM'] == 'sunos':
        env['CCFLAGS'] = string.replace(env.get('CCFLAGS',''),'-xO2','-g')
    env['F90FLAGS'] = string.replace(env.get('F90FLAGS',''),'-O2','-g')
    env.SConsignFile(None)
    env.Append(BUILDERS={'RSF_Include':Header,
                         'RSF_Place':Place},
               SCANNERS=[Include])
    return env

################################################################################

def depends(env,list,file):
    'Find dependencies for C'
    filename = env.File(file+'.c').abspath
    # replace last occurence of build/
    last = filename.rfind('build/')
    if last >= 0:
        filename = filename[:last] + filename[last+6:]
    fd = open(filename,'r')
    for line in fd.readlines():
        for inc in __include.findall(line):
            if inc not in list and inc[0] != '_':
                list.append(inc)
                depends(env,list,inc)
    fd.close()

################################################################################

def depends90(env,list,file):
    'Find dependencies for Fortran-90'

    include90 = re.compile(r'^[^!]*use\s+(\S+)')
    filename = env.File(file+'.f90').abspath
    # replace last occurence of build/
    last = filename.rfind('build/')
    if last >= 0:
        filename = filename[:last] + filename[last+6:]
    fd = open(filename,'r')
    for line in fd.readlines():
        for inc in include90.findall(line):
            if inc not in list and inc != 'rsf':
                list.append(inc)
                depends90(env,list,inc)
    fd.close()

################################################################################

def chk_exists(prog, ext='c', mainprog=True):
    'Check if file corresponding to program name exists'

    ext = ext.lstrip('.') # In case the user put a dot
    prognm = prog + '.' + ext
    if mainprog:
        prognm = 'M' + prognm
    try:
        assert os.path.isfile(prognm)
    except:
        msg = 'Missing file: ' + os.path.join(os.getcwd(),prognm)
        configure.stderr_write(msg,'yellow_on_red')
        sys.exit(configure.unix_failure)

################################################################################

def build_install_c(env, progs_c, bindir, glob_build, bldroot):
    'Build and install C programs'

    env.Prepend(CPPPATH=[os.path.join(bldroot,'include')],
            LIBPATH=[os.path.join(bldroot,'lib')],
            LIBS=['rsf'])

    if glob_build:
        dir = string.replace(os.getcwd(),'/build','') # aka RSFSRC/user/$USER
        src = map(os.path.basename,glob.glob(os.path.join(dir,'[a-z]*.c')))
    else:
        src = glob.glob('[a-z]*.c')

    for source in src:
        inc = env.RSF_Include(source,prefix='')
        obj = env.StaticObject(source)
        env.Depends(obj,inc)

    mains_c = Split(progs_c)
    for prog in mains_c:
        if not glob_build:
            chk_exists(prog)
        sources = ['M' + prog]
        depends(env, sources, 'M'+prog)
        prog = env.Program(prog, map(lambda x: x + '.c',sources))
        if glob_build:
            env.Install(bindir,prog)

    if glob_build:
        docs_c = map(lambda prog: env.Doc(prog,'M'+prog),mains_c)
    else:
        docs_c = None

    return docs_c

################################################################################

def build_install_f90(env, progs_f90, bindir, api, bldroot, glob_build):
    'Build and install Fortran90 programs'

    mains_f90 = Split(progs_f90)

    if 'f90' in api:

        F90 = env.get('F90')
        assert F90 != None # The configure step should have found the compiler
        F90base = os.path.basename(F90)
        if F90base[:8] == 'gfortran' or F90base[:3] == 'gfc':
            env.Append(F90FLAGS=' -J${SOURCE.dir}')
        elif F90base == 'ifort':
            env.Append(F90FLAGS=' -module ${SOURCE.dir}')

        env.Prepend(LIBS='rsff90', # order matters when linking
                    F90PATH=os.path.join(bldroot,'include'))

        for prog in mains_f90:
            if not glob_build:
                chk_exists(prog, 'f90')
            obj_dep = []
            sources = ['M' + prog]
            depends90(env,sources,'M'+prog)
            for f90_src in sources:
                obj = env.StaticObject(f90_src+'.f90')
                # SCons mistakenly treats ".mod" files as ".o" files, and
                # tries to build them the same way (which fails). So we
                # explicitly keep just the ".o" files as dependencies:
                for fname in obj:
                    if os.path.splitext(fname.__str__())[1] == '.o':
                        obj_dep.append(fname)
            # Using obj_dep instead of the list of sources because when two
            # mains used the same module, object files for the module were 
            # created in both places, hence endless "double-define" warnings
            prog = env.Program(prog, obj_dep, LINK=F90)
            if glob_build:
                env.Install(bindir,prog)

    else: # Put in a placeholder
        for prog in mains_f90:
            prog = env.RSF_Place('sf'+prog,None,package='Fortran90+API=F90')
        if glob_build:
            env.Install(bindir,prog)

    if glob_build:
        docs_f90 = map(lambda prog: env.Doc(prog,'M'+prog+'.f90',lang='f90'),
               mains_f90)
    else:
        docs_f90 = None

    return docs_f90

################################################################################

def install_py_mains(env, progs_py, bindir):
    'Copy Python programs to bindir, generate list of self-doc files'

    mains_py = Split(progs_py)
    for prog in mains_py:
        env.InstallAs(os.path.join(bindir,'sf'+prog),'M'+prog+'.py')

    # Self-doc
    user = os.path.basename(os.getcwd())
    main = 'sf%s.py' % user
    docs_py = map(lambda prog: env.Doc(prog,'M'+prog+'.py',lang='python'),
           mains_py)

    return docs_py

################################################################################

def install_py_modules(env, py_modules, pkgdir):
    'Compile Python modules and install to pkgdir/user'

    rsfuser = os.path.join(pkgdir,'user')
    for module in Split(py_modules):
        env.RSF_Pycompile(module+'.pyc',module+'.py')
        env.Install(rsfuser,[module+'.py',module+'.pyc'])

################################################################################

def py_install(src, env, targetdir):
    'Compile and install py module'

    [filenm, ext] = os.path.splitext(src)

    if ext == '.py':
        source = filenm
    elif ext == '':
        source = src

    py = source+'.py'
    pyc = py+'c'
    env.RSF_Pycompile(pyc,py)
    env.Install(targetdir,[py,pyc])

################################################################################

def install_self_doc(env, libdir, docs_c=None, docs_py=None, docs_f90=None):

    docs = []
    if docs_c != None:
        docs += docs_c
    if docs_py != None:
        docs += docs_py
    if docs_f90 != None:
        docs += docs_f90

    env.Depends(docs,'#/framework/rsf/doc.py')	

    user = os.path.basename(os.getcwd())
    main = 'sf%s.py' % user
    doc = env.RSF_Docmerge(main,docs)
    env.Install(libdir,doc)

################################################################################

def add_ext_static_lib(env, libnm, root=None):

    if not root:
        root = env.get('RSFROOT',os.environ.get('RSFROOT'))
    env['LIBS'].append(File(os.path.join(root,'lib','lib'+libnm+'.a')))
    env['CPPPATH'].append(os.path.join(root,'include'))
