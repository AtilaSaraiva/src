/* Interface to standard C i/o. */
/*************************************************************************

Copyright Rice University, 2008.
All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, provided that the above copyright notice(s) and this
permission notice appear in all copies of the Software and that both the
above copyright notice(s) and this permission notice appear in supporting
documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder shall
not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization of the
copyright holder.

**************************************************************************/

/** @page fopen IWAVE File Management Functions 

Interface to standard C i/o. Creates database of filenames and
associated FILE*s. ALWAYS use in place of fopen in all iwave
apps. Associates file pointers to file names for the life of the
process. Since many file types are structured after prototypes, also
records prototype information. The fopen interface \ref iwave_fopen searches for file in list of
already-opened files for given name, mode, prototype, and temp status,
returns pointer assigned to file if found, otherwise opens file and
returns file pointer with appropriate mode set.

Files are either temp or archival. Temp files treated differently from
archival files. Temp files may be re-used or overwritten when current
use is finished, for which purpose the database flags temp
status. Indicate temp status by setting *name=NULL on call to \ref
iwave_fopen - in that case, on (successful) return, reassigns this
pointer to a copy of a character string generated by mkstemp. Passing
a non-NULL char * indicates archival status of the file - the string
passed is the name of the file opened, either in the current call to
iwave_fopen or cached in a previous call. In either case, memory
allocated for filename storage must be managed by the calling unit.

The calling app should NOT close files or reset file pointers. Once
opened, files remain open until closed in the "destructor"
iwave_fdestroy, which should be called only once on exit from an app
process. The utility iwave_fclose marks temporary files for possible
re-use, but has no effect on archival files. A temp file marked for
re-use by iwave_fclose may be returned for use by another call to
iwave_fopen with any access mode. However the access mode will be
ignored, as iwave_fopen opens all temp files with access mode
"w+". Unlike fopen, the file is truncated only on being opened the
first time by iwave_fopen. Subsequent calls which return pointers to
the same file (switching from inuse=0 to inuse=1, for temp files) do
not truncate the existing file.

*/

#include "iwave_fopen.h"

#include "utils.h"
/*^*/


/** if set, unlink temporary files in iwave_fdestroy */
#define UNLINK_TMPS
/*^*/

#define NLEN 16
#define BLEN 1000

static char buf[BLEN];

static struct filestat {
  struct filestat *nextfpr;         /* linked list pointer */
  FILE * fp;                        /* FILE */
  char * nm;                        /* NAME */
  char * pr;                        /* PROTO */
  char * md;                        /* MODE */
  int istmp;                        /* temp flag */
  int inuse;                        /* availability flag */
} * filestatlist = (struct filestat *)NULL;

static struct filestat *fpr, **oldfpr;

FILE * iwave_fopen(char ** name, 
		   const char * mode, 
		   const char * proto,
		   FILE * stream) 
/*< Organized to behave exactly as fopen does with respect to
    mode:

    ``r''   Open text file for reading.  The stream is positioned at the
    beginning of the file.

    ``r+''  Open for reading and writing.  The stream is positioned at the
    beginning of the file.

    ``w''   Truncate file to zero length or create text file for writing.
    The stream is positioned at the beginning of the file.

    ``w+''  Open for reading and writing.  The file is created if it does not
    exist, otherwise it is truncated.  The stream is positioned at
    the beginning of the file.

    No use of the "a" modes is expected in IWAVE, though these should also 
    work the same way.

    @param name pointer to name (char *) of file to be opened. If
    *name != NULL on call, then used as target filename and treated as
    const. If NULL on call, then assigned to a string generated by
    mkstemp, either new if no suitable temp file available, or name of
    an existing temp file if one with same prototype is not in use, on
    return.  @param mode access mode, exactly as in fopen @param proto
    name of prototype file - NULL if no prototype exists; if assigned,
    guarantees that file has same internal structure as prototype. On
    opening a new file with an existing prototype in w or w+ mode,
    iwave_fopen performs byte-level copy of prototype onto target,
    which enforces guarantee. For r or r+ access mode, only file
    length is checked against prototype, as iwave_fopen has no access
    to any other information about internal file structure.  @param
    stream verbose output unit

    @return either valid file pointer, or NULL if none could be found or allocated
>*/
{
  
  FILE * retfp = (FILE *)NULL; /* return value */
  FILE * fph   = (FILE *)NULL; /* proto file pointer */
  int fd;                      /* file descr for return from mkstemp */
  int nr;                      /* #words read/written in copy of proto */
  int chunk;                   /* size of buffer read in copy of proto */
  off_t plen;                  /* size of prototype file */   
  
  /* sanity check: if proto file given, then previously opened for read */
  if (proto) {
    /*    fprintf(stderr,"begin proto - search for %s\n",proto);*/
    oldfpr=&filestatlist;
    for (fpr=filestatlist; fpr != ((struct filestat *)NULL); 
	 fpr = fpr->nextfpr) {
      if (!(strcmp(proto,fpr->nm)) &&
	  (fpr->istmp==0) &&
	  (fpr->md[0]=='r')) break;
      oldfpr=&fpr->nextfpr;
    }

    if (fpr==((struct filestat *)NULL)) {
      /* didn't find it */
      fprintf(stream,"Error: iwave_fopen\n");
      fprintf(stream,"requested proto file %s not in database\n",proto);
      iwave_fprintall(stream);
      return retfp;
    }      

    /* successful search for proto file; assign pointer */
    fph=fpr->fp;
    /*    fprintf(stderr,"found proto file %s\n",fpr->nm);*/
  }

  /* CASE I - request for temp file

  if name==NULL, then a temp file is being requested. Co-conditions:
  - a prototype file exists - this must be a previously-opened archival 
  file, and proto!=NULL with file permission permitting read
  - w(+) file permissiion being requested
  if these conditions hold, then check for existing filename with same
  proto and temp status - if you find one not in use, return its FILE*,
  else open a new file, copy the prototype file to it, and return the 
  pointer.
  */

  if (*name==NULL) {

    /*    fprintf(stderr,"begin temp\n");*/
    
    /* sanity check: access mode = w+ */
    if (strcmp(mode,"w+")) {
      fprintf(stream,"Error: iwave_fopen\n");
      fprintf(stream,"the only legal permission for a temp file is w+\n");
      return retfp;
    }

    /* sanity check: prototype file legal */
    if (proto==NULL || fph==NULL) {
      fprintf(stream,"Error: iwave_fopen\n");
      fprintf(stream,"cannot request temp file without file prototype\n");
      return retfp;
    }
      
    /*    fprintf(stream,"  proto file %s\n",proto);*/
    /*    iwave_fprintall(stream);*/
    /* having found legal prototype file, search database for unused
       temp file modeled on same proto */

    oldfpr=&filestatlist;
    for (fpr=filestatlist; fpr != ((struct filestat *)NULL);fpr = fpr->nextfpr) {

      /* break if (1) prototypes match, (2) filestat has tmp status, and
	 (3) associated file not in use */
      /*      fprintf(stream,"-- check filename=%s\n",fpr->nm);*/
      if ((fpr->pr) && 
	  !(strcmp(proto,fpr->pr)) &&
	  (fpr->istmp==1) &&
	  (fpr->inuse==0)) break;
      /*      fprintf(stream,"-- next\n");*/
      oldfpr=&(fpr->nextfpr);
    }

    /*    fprintf(stream,"  search finished\n");*/
    /* CASE IA: no existing temp file available, open new one */

    if (fpr==((struct filestat *)NULL)) {

      /*      fprintf(stream,"new temp file construction\n");*/
      /* first, generate name - NOTE: THIS IS MEMORY THAT
	 MUST BE MANAGED BY THE CALLING UNIT */
      *name = (char *)malloc(NLEN*sizeof(char));
      strcpy(*name,"./tmp.XXXXXX");

      fd=mkstemp(*name);
      if (fd<0) {
	fprintf(stream,"Error: iwave_fopen\n");
	fprintf(stream,"failed to open temp file - error from mkstemp\n");
	return retfp;
      }

      /*      fprintf(stream,"  temp file name = %s\n",*name);*/

      /* open stream - always in w+ mode */
      if (!(retfp=fdopen(fd,"w+"))) {
	fprintf(stream,"Error: iwave_fopen\n");
	fprintf(stream,"failed to open stream - error from fdopen\n");
	return retfp;
      }

      /* set filestat struct params */
      *oldfpr = (struct filestat *)malloc(sizeof(struct filestat));
      fpr=*oldfpr;
      fpr->fp = retfp;
      fpr->nm = (char *)malloc((strlen(*name)+1)*sizeof(char));
      strcpy(fpr->nm,*name);
      fpr->pr = (char *)malloc((strlen(proto)+1)*sizeof(char));
      strcpy(fpr->pr,proto);
      fpr->md = (char *)malloc(3*sizeof(char));
      strcpy(fpr->md,"w+");
      fpr->istmp=1;
      fpr->inuse=1;
      fpr->nextfpr = (struct filestat *)NULL;

      /* determine length of proto file */
      fseeko(fph,0L,SEEK_END);
      plen=ftello(fph);

      /* now copy prototype file onto temp file */
      fseeko(fpr->fp,0L,SEEK_SET);
      fseeko(fph,0L,SEEK_SET);

      chunk=iwave_min(BLEN,plen);
      while (chunk>0) {

	/*	fprintf(stderr,"t loop chunk=%d\n",chunk);*/

	nr=fread(&(buf[0]),sizeof(char),chunk,fph);
	if (nr!=chunk) {
	  fprintf(stream,"Error: iwave_fopen\n");
	  fprintf(stream,"in initialization of temp file %s\n",fpr->nm);
	  fprintf(stream,"failed to read %d chars from proto file %s\n",chunk,fpr->pr);
	  return NULL;
	}
	nr=fwrite(&(buf[0]),sizeof(char),chunk,fpr->fp);
	if (nr!=chunk) {
	  fprintf(stream,"Error: iwave_fopen\n");
	  fprintf(stream,"in initialization of temp file %s\n",fpr->nm);
	  fprintf(stream,"failed to write %d chars to temp file %s\n",chunk,fpr->nm);
	  return NULL;
	}
	/* having read chunk words, there are plen-chunk left to read - update
	   plen, recompute chunk */
	plen=plen-chunk;
	chunk=iwave_min(BLEN,plen);
      }
    
      /* reset to begin-of-file to emulate w+ behaviour */
      fseeko(fpr->fp,0L,SEEK_SET);
      fseeko(fph,0L,SEEK_SET);
      
    }

    /* CASE IB: found unused temp file with matching prototype, 
       return its pointer, update name */
    
    else {
      /* found suitable unused temp file modeled on same proto. set 
	 inuse flag, copy pointer to return value, copy name to arg. */
      fpr->inuse=1;
      retfp=fpr->fp;
      /* MEMORY WHICH MUST BE MANAGED BY CALLING UNIT */
      *name=(char *)malloc((strlen(fpr->nm)+1)*sizeof(char));
      strcpy(*name,fpr->nm);
    }

    /* in either case, return file pointer */
    return retfp;

    /*    fprintf(stderr,"end temp case\n");*/
  }

  /* CASE II: archival file requested */

  else {

    /*    fprintf(stderr,"begin archival case, name = %s\n",*name);*/

    /* match if 
       - filenames match, and
       - modes match, and
       - either no prototypes, or prototypes match. and
       - inuse flag unset
    */
    oldfpr=&filestatlist;
    for (fpr=filestatlist; fpr != (struct filestat *)NULL; 
	 fpr = fpr->nextfpr) {
      /* break if filenames match */
      if (!(strcmp(*name,fpr->nm)) &&
	  !(strcmp(mode,fpr->md)) &&
	  (
	   (
	    (proto) && (fpr->pr) &&
	    !(strcmp(proto,fpr->pr))
	    ) 
	   ||
	   (
	    (!proto) && (!(fpr->pr))
	    )
	   ) &&
	  (!fpr->inuse)
	  )
	break;
      oldfpr=&fpr->nextfpr;
    }
    
    /*    fprintf(stderr,"begin new archival file\n");*/
    
    /* CASE IIA didn't find one -have to build a new one */
    
    if (fpr==((struct filestat *)NULL)) {
      
      /* open stream */
      if (!(retfp=fopen(*name,mode))) {
	/* NOT NECESSARILY AN ERROR 
	*/
	fprintf(stream,"NOTE: iwave_fopen\n");
	fprintf(stream,"-- failed to open stream on file %s mode %s\n",*name,mode);
	return retfp;
      }
      
      /* CASE IIA-1: if r mode, check against length of existing file */
      
      /* if r mode, check that file has same length as prototype - no
	 other tests make sense at this level. */
      /* 31.03.10: no error checking at this level for r access - defer
	 to DC classes */
      /*
	if (mode[0]=='r' && proto && fph) {
	
	fseeko(fph,0L,SEEK_END);
	plen=ftello(fph);
	fseeko(retfp,0L,SEEK_END);
	if (plen!=ftello(retfp)) {
	fprintf(stream,"Error: file %s does not have same length \n",*name);
	fprintf(stream,"as proto file %s\n",proto);
	fclose(retfp);
	  retfp=NULL;
	  return retfp;
	}
	fpr->inuse=1;
	

	}
      */

      /* CASE IIA-2: (write mode) copy prototype file to claim disk space,
         if a prototype is provided */
      /* note that this is done ONLY to claim disk space. The contents
	 of this file may be modified by users eg. DC classes */

      if (mode[0]=='w' && proto && fph) {

	/*fprintf(stderr,"old file case with prototype\n");*/

	/* determine length of proto file */
	fseeko(fph,0L,SEEK_END);
	plen=ftello(fph);

	fseeko(retfp,0L,SEEK_SET);
	fseeko(fph,0L,SEEK_SET);

	chunk=iwave_min(BLEN,plen);
	while (chunk>0) {

	  /*	  fprintf(stderr,"chunk=%d\n",chunk);*/

	  nr=fread(&(buf[0]),sizeof(char),chunk,fph);

	  if (nr!=chunk) {
	    fprintf(stream,"Error: iwave_fopen\n");
	    fprintf(stream,"in initialization of new archival file %s\n",fpr->nm);
	    fprintf(stream,"failed to read %d chars from proto file %s\n",chunk,fpr->pr);
	    fclose(retfp);
	    retfp=NULL;
	    return retfp;
	  }
	  nr=fwrite(&(buf[0]),sizeof(char),chunk,retfp);
	  if (nr!=chunk) {
	    fprintf(stream,"Error: iwave_fopen\n");
	    fprintf(stream,"in initialization of new archival file %s\n",fpr->nm);
	    fprintf(stream,"failed to write %d chars to temp file %s\n",chunk,fpr->nm);
	    fclose(retfp);
	    retfp=NULL;
	    return retfp;
	  }

	  /* having read chunk words, there are plen-chunk left to read - update
	     plen, recompute chunk */
	  plen=plen-chunk;
	  chunk=iwave_min(BLEN,plen);
	}

      }
	
      /* reset to begin-of-file to emulate fopen behaviour */
      fseeko(retfp,0L,SEEK_SET);
      if (fph) fseeko(fph,0L,SEEK_SET);

      /* set filestat struct params */
      *oldfpr = (struct filestat *)malloc(sizeof(struct filestat));
      fpr=*oldfpr;
      fpr->fp = retfp;
      fpr->nm = (char *)malloc((strlen(*name)+1)*sizeof(char));
      strcpy(fpr->nm,*name);
      if (proto) {
	fpr->pr = (char *)malloc((strlen(proto)+1)*sizeof(char));
	strcpy(fpr->pr,proto);
      }
      else {
	fpr->pr = NULL;
      }
      fpr->md = (char *)malloc((strlen(mode)+1)*sizeof(char));
      strcpy(fpr->md,mode);
      fpr->istmp=0;
      fpr->inuse=1;
      fpr->nextfpr = (struct filestat *)NULL;
    }

    else {

      /* CASE IIB: found already-opened archival file */
      /* return to start-of-file, to imitate setup with freshly opened
	 file. */
      /* no, don't - very useful for the behaviour of iwave_fopen to be
	 DIFFERENT from that of fopen! if the file is already opened, 
	 simply return the pointer, at whatever position it was last
	 left, and leave any further positioning decisions to the calling
	 unit. For a sequential read-by-chunks through a file, that's 
	 exactly what is needed. If there is any risk that the pointer 
	 has moved since the last access by the unit in question, then 
	 of course that unit must possess overall positioning information.
	 Otherwise, no need! This way, the file pointers act like a 
	 static array.
      if ((fpr->md[0]=='w')||(fpr->md[0]=='r')) fseeko(fpr->fp,0L,SEEK_SET);
      */
      /* furthermore, if open for write, reopen/truncate */
      /* not clear that this is a good idea - hold off
	 if (fpr->md[0]=='w') fpr->fp=freopen(fpr->nm,fpr->md,fpr->fp);
      */

      /* UPSHOT: set in-use flag, simply pass the pointer back!!! */
      fpr->inuse=1;
      retfp = fpr->fp;

    }
  }

  /*
  if (retfp)
    fprintf(stderr,"opening fp=%x name=%s mode=%s istmp=%d inuse=%d\n",
      retfp,fpr->nm,fpr->md,fpr->istmp,fpr->inuse);
  */

  return retfp;

}

FILE * iwave_const_fopen(const char * name, 
			 const char * mode, 
			 const char * proto,
			 FILE * stream) 
/*<
** const filename version of iwave_fopen. Returns non-null FILE* only
if name is non-null string, naming existing file meeting other
criteria (for example, matching prototype, if one is
given). Arguments, function otherwise identical to iwave_fopen. >*/
{
  char * tmpname;
  FILE * fp = NULL;
  if (!name) {
    fprintf(stream,"Error: iwave_const_fopen\n");
    fprintf(stream,"called with null filename\n");
  }
  else {
    tmpname=(char *)malloc((1+strlen(name))*sizeof(char));
    strcpy(tmpname,name);
    fp=iwave_fopen(&tmpname,mode,proto,stream);
    free(tmpname);
  }
  /*
  if (!fp) {
    fprintf(stream,"NOTE: returning from iwave_const_fopen with null ptr\n");
    fprintf(stream,"NOTE: state of file system:\n");
    iwave_fprintall(stream);
  }
  */
  return fp;
}

/* close merely resets the in-use flag */
void iwave_fclose(FILE * fp) 
/*< 
** If file has temp status, flags file as not in use (does not
    actually close or unlink). Temp files on which iwave_fclose has
    been called may be reused as out-of-core workspace with the same
    prototype later in an application. No-op for archival file. 
>*/ 
{
  if (!fp) return;

  for (fpr=filestatlist; fpr != ((struct filestat *)NULL); 
       fpr = fpr->nextfpr) {
    if (fp==fpr->fp) break;
  }
  if (fpr!=((struct filestat *)NULL)) {
    fpr->inuse=0;
    /*
    fprintf(stderr,"closing fp=%x name=%s mode=%s istmp=%d inuse=%d\n",
      fp,fpr->nm,fpr->md,fpr->istmp,fpr->inuse);
    */
  }
}

void iwave_fprintall(FILE * stream) 
/*< ** prints the data of the file management struct >*/
{

  int iptr=0; int istmp=0; int inuse=0;

  fprintf(stream,"IWAVE file manager database\n");
  
  for (fpr=filestatlist; fpr != ((struct filestat *)NULL); fpr = fpr->nextfpr) {
    fprintf(stream,"FILE*=%p ",(void *)fpr->fp);
    if (fpr->nm) fprintf(stream,"name=%s ",fpr->nm);
    else fprintf(stream,"name=NULL ");
    if (fpr->md) fprintf(stream,"mode=%s ",fpr->md);
    else fprintf(stream,"mode=(none) ");
    if (fpr->pr) fprintf(stream,"proto=%s ",fpr->pr);
    else fprintf(stream,"proto=NULL ");
    fprintf(stream,"istmp = %d inuse = %d\n",fpr->istmp,fpr->inuse);
    if (fpr->istmp) istmp++;
    if (fpr->inuse) inuse++;
    iptr++;
  }
  fprintf(stream,"-- total FILE * = %d, open as tmp = %d, in use = %d\n",
	  iptr,istmp,inuse);
}

/* destructor */
void iwave_fdestroy() 
/*<
** closes all files, unlinks those flagged as temporary, deallocates
all memory allocated in the buildup of the file database. call
only once per application, on exit from the application
process. >*/
{
  /* workspace to hold temp copy of next pointer */
  struct filestat * tmpnext = filestatlist->nextfpr;

  for (fpr=filestatlist; fpr != ((struct filestat *)NULL); 
       fpr = tmpnext) {
    if (fpr->fp)  { fclose(fpr->fp); fpr->fp=NULL; }
#ifdef UNLINK_TMPS
    if (fpr->istmp && fpr->nm) unlink(fpr->nm);
#endif
    if (fpr->nm) { free(fpr->nm); fpr->nm=NULL; }
    if (fpr->pr) { free(fpr->pr); fpr->pr=NULL; }
    free(fpr->md); fpr->md=NULL;
    fpr->istmp=0;
    fpr->inuse=0;
    tmpnext=fpr->nextfpr;
    free(fpr);
    fpr=(struct filestat *)NULL;
  }
  filestatlist=(struct filestat *)NULL;
}
