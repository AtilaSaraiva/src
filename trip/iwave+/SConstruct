# SConstruct to build C++ image of iwave - files are copied and
# renamed, so that default choices for compiler build with C++ instead
# of C 
import os 
import shutil 
import fnmatch 
import string 

def cpsrc(target,source,env):
    tgt = str(target[0]);
    src = str(source[0]);
    shutil.copyfile(src,tgt);

thispath = os.getcwd()
thisname = os.path.basename(thispath)

f = open('hsubpath','r')
sublist = (f.read().strip('\n')).split(':')
f.close() 

# if master config file installed, use it, else defaults
thisconfigfile=os.path.join(thispath,'../config.py')
if os.path.exists(thisconfigfile):
    vars=Variables(thisconfigfile)
else:
    vars=Variables()

vars.Add('CC','path or alias for C compiler','gcc')
vars.Add('CFLAGS','flags passed to C compiler only (not C++)','-std=c99')
vars.Add('CCFLAGS','flags passed to C/C++ compiler','-g -pedantic -Wunused -Wimplicit -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_GNU_SOURCE')
vars.Add('CXX','path or alias for C++ compiler','g++')
vars.Add('CXXFLAGS','flags passed to C++ compiler only (not C)','')
vars.Add('LINKFLAGS','flags passed only to linker','')
vars.Add('AR','static library (object archive) creation','ar')

# initialize build environment
env = Environment(variables = vars,
                  CC={'CC' : '${CC}'},
		  CFLAGS={'CFLAGS' : '${CFLAGS}'},
                  CCFLAGS={'CCFLAGS' : '${CCFLAGS}'},
                  CXX={'CXX' : '${CXX}'},
	          CXXFLAGS={'CXXFLAGS' : '${CXXFLAGS}'},
		  LINKFLAGS={'LINKFLAGS' : '${LINKFLAGS}'},
		  AR={'AR' : '${AR}'})
Help(vars.GenerateHelpText(env))

testflag = 'no'
docflag = 'no'

# generate,

# all other opts recursive over subpackages - build each one 
# from matching iwave package
for pkg in sublist:
    if not os.path.exists(pkg):
        os.mkdir(pkg)
    if not os.path.exists(pkg + '/lib'):
        os.mkdir(pkg + '/lib')
    if not os.path.exists(pkg + '/include'):
        os.mkdir(pkg + '/include')
    if os.path.exists(os.path.join('../iwave',pkg,'hclasspath')):
        shutil.copyfile(os.path.join('../iwave',pkg,'hclasspath'),os.path.join(pkg,'hclasspath.orig'))
        os.system('cat ' + pkg + '/hclasspath.orig | sed s#"../sucore"#"../../iwave/sucore"# > ' + pkg + '/hclasspath')
    shutil.copyfile(os.path.join('../iwave',pkg,'SConstruct'),os.path.join(pkg,'SConstruct'))
    shutil.copyfile(os.path.join('../iwave',pkg,'SConscript'),os.path.join(pkg,'SConscript'))
    shutil.copyfile(os.path.join('../iwave',pkg,'lib/SConscript'),os.path.join(pkg,'lib/SConscript'))
    lib = os.listdir(os.path.join('../iwave',pkg,'lib'))
    for src in lib:
        if fnmatch.fnmatch(src,'*.c'):
            t = env.Command([pkg + '/lib/' + os.path.splitext(src)[0] + '.cc'],['../iwave/' + pkg + '/lib/' + src], cpsrc)
            Clean(t,pkg + '/lib/' + os.path.splitext(src)[0] + '.cc')
    inc = os.listdir(os.path.join('../iwave',pkg,'include'))
    for hdr in inc:
        if fnmatch.fnmatch(hdr,'*.h'):
            t = env.Command([pkg + '/include/' + hdr],['../iwave/' + pkg + '/include/' + hdr], cpsrc)
            Clean(t,pkg + '/include/' + hdr)

    Export('vars', 'testflag', 'docflag')
    SConscript(pkg+'/SConscript')
