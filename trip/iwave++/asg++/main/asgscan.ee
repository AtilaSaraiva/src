/** \file asginv.cc
 * Driver for least-squares waveform inversion 
 * 
 * Usage: 
 *        ./asginv.x par=test.par
 *
 * accormodates both standard and extended inversion modes
 *  
 * \author William W. Symes and Dong Sun   
 * May, 2011
 */
/*================================================================================*/

#include "asginv_selfdoc.hh"
#include "asg_gfdm.h"
#include "asg_sampler.hh"
#include "seamx_headers.hh"
#include "iwop.hh"
#include "state.hh"
#include "samp.hh"
#include "ls.hh"
#include "blockop.hh"
#include "sim.hh"
#include "pol.hh"

#include "CPsim.hh"

#include "gridpp_top.hh"
#include "gridops.hh"
#include "griddiffops.hh"

#ifdef IWAVE_USE_MPI
#include "mpisegypp.hh"
#else
#include "segypp.hh"
#endif
#include "segyops.hh"

#include "LBFGSBT.hh"

using namespace RVLUmin;
using namespace RVLAlg;
using namespace TSOpt;
using namespace RVL;

namespace ASG {

  /* Sampler Policies */
  /** FwdSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveState,ASGSampler> ASGSamplerPolicy;
  /** LinSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGLinSampler> ASGLinSamplerPolicy;
  /** AdjSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGAdjSampler> ASGAdjSamplerPolicy;
 
  /* Sim Policies */  
  /** FwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdSim<IWaveState> > StdIWavePolicy;
  /** LinFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdRCSim<IWaveState> > StdRCIWavePolicy; 
  /** AdjFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, CPSim<IWaveState,TSIndex> > FwdCPSimPolicy;
  /** LinSimPolicy and AdjSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > LinSimPolicy;
 
 //typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > AdjSimPolicy;
   
  /* dummy sim policies to fill in the rest of the list */
  //class LinFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  //class LinSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};
  //class AdjFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  class AdjSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};

} 

void paramreader(PARARRAY pars, 
		 string const & key, 
		 string & val, 
		 bool warn,
		 FILE * stream) {
  try {
    char * cbuf = NULL;
    ps_ffcstring(pars,key.c_str(),&cbuf);
    if (!cbuf) {
      if (warn) {
	fprintf(stream,"NOTE: failed to read value for key = %s\n",key.c_str());
	fprintf(stream,"NOTE: returning empty value string\n");
	val="";
      }
      else {
	RVLException e;
	e<<"Error: asgfwd\n";
	e<<"failed to extract value for key="<<key<<" from param table\n";
	throw e;
      }
    }
    else {
      val=cbuf;
      free(cbuf);
      cbuf=NULL;
    }
  }
  catch (RVLException & e) {
    e<<"\ncalled from paramreader\n";
    throw e;
  }
}

int main(int argc, char ** argv) {
  xargc=argc;
  xargv=argv;

  using namespace ASG;
  try { 

    if (argc<2) { 
      RVLException e;
      e<<"asginv: least squares inversion\n";
      e<<"usage: asginv.x par=<par file>\n";
      throw e;
    }

    int rk = 0;

    /* set up execution environment */
#ifdef IWAVE_USE_MPI
    MPI_Init(&argc,&argv);
#endif

    PARARRAY pars;
    FILE * stream;
    IWaveEnvironment(argc,argv,&pars,&stream);
      
#ifdef IWAVE_USE_MPI
    if (retrieveGroupID() == MPI_UNDEFINED) {
      fprintf(stream,"NOTE: finalize MPI, cleanup, exit\n");
    }
    else {
      rk = retrieveGlobalRank();
#endif
      if (rk==0) requestdoc(1);

      /////////////////////////////////////////////////////
      //                     INPUT                       //
      /////////////////////////////////////////////////////
      
      /* file reading section - basic inputs */

      // major switch - invert for bulk modulus only, or for bulk modulus and buoyancy
      int bulkonly=0;
      ps_ffint(pars,"bulkonly",&bulkonly);

      //main input and output data files

      // scan log 
      string scanlogfn = "";
      paramreader(pars,"scan_outfile",scanlogfn,true,stream);
      int nscan = 1;
      ps_ffint(pars,"nscan",&nscan);
      ireal h0 = ScalarFieldTraits<ireal>::Zero();
      ireal h1 = ScalarFieldTraits<ireal>::One();
      ps_fffloat(pars,"scan_beg",&h0);
      ps_fffloat(pars,"scal_end",&h1);

      // initial model - mandatory
      string initbulkname;
      string initbuoyname;
      paramreader(pars,"init_bulkmod",initbulkname,false,stream);
      if (!bulkonly)
	paramreader(pars,"init_buoyancy",initbuoyname,false,stream);

      // final model
      string finalbulkname;
      string finalbuoyname;
      paramreader(pars,"final_bulkmod",finalbulkname,false,stream);
      paramreader(pars,"final_buoyancy",finalbuoyname,false,stream);

      // input data file
      string dataname;
      paramreader(pars,"datafile",dataname,false,stream);

      /* mute */
      float s=0.0f;
      float w=0.0f;
      float tm=0.0f;
      // internal flag
      int muteflag = 0;
      // mute_slope serves as flag for mute
      if (!ps_fffloat(pars,"mute_slope",&s) ||
	  !ps_fffloat(pars,"mute_zotime",&tm) ||
	  !ps_fffloat(pars,"mute_width",&w)) {
	muteflag = 1;
      }
	
      /////////////////////////////////////////////////////
      //              PREPROCESSING                      //
      /////////////////////////////////////////////////////
      
      /************ SPACES, VECTORS *****************/
      
#ifdef IWAVE_USE_MPI
      MPIGridSpace<float> m1sp(finalbulkname);
      MPIGridSpace<float> m2sp(finalbuoyname);
#else
      GridSpace<float> m1sp(finalbulkname);
      GridSpace<float> m2sp(finalbuoyname);
#endif
      StdProductSpace<float> msp(m1sp,m2sp);    
      
      //xf stores final (target) model, x0 initial model
      Vector<float> xf(msp);
      Components<float> cxf(xf);
      Vector<ireal> x0(msp);
      Components<ireal> cx0(x0);
      
      /* make SEGY space and vector */
#ifdef IWAVE_USE_MPI
      MPISEGYSpace tsp(dataname);
#else
      SEGYSpace tsp(dataname);
#endif
      // y stores data;
      Vector<float> y(tsp);
      
      /* assign model, data files */
      AssignFilename m1fn(finalbulkname);
      AssignFilename m2fn(finalbuoyname);
      cxf[0].eval(m1fn);
      cxf[1].eval(m2fn);
      
      AssignFilename m1fn0(initbulkname);
      AssignFilename m2fn0(initbuoyname);
      cx0[0].eval(m1fn0);
      cx0[1].eval(m2fn0);

      AssignFilename tfn(dataname);
      y.eval(tfn);
      
      /***************** OPERATORS ******************/ 
      /* composite simulation operator, evaluation vector -
         zero if affine window, input model else */
      /* window option */
      
      OpComp<ireal> op;

      /* simulator */
      IWaveOp<
      ASGSamplerPolicy,
	ASGLinSamplerPolicy,
	ASGAdjSamplerPolicy,
	StdIWavePolicy,
	StdRCIWavePolicy,
	LinSimPolicy,
	FwdCPSimPolicy,
	AdjSimPolicy
	> 
	iwop(msp,tsp,pars,stream,asg_gfdm);

      op.setNext(iwop);

      SEGYLinMute mute(s,tm,w);
      LinearOpFO<float> mop(tsp,tsp,mute,mute);
      op.setNext(mop);

      StdLeastSquaresFcnlGN<ireal> f(op,y);

      /////////////////////////////////////////////////////
      //                      SCAN                       //
      /////////////////////////////////////////////////////
      
      // create test vector, direction vector, functional evaluation
      Vector<ireal> x(f.getDomain());
      FunctionalEvaluation<ireal> feval(f,x);

      Vector<ireal> dx(f.getDomain());
      dx.copy(xf);
      dx.linComb(-ScalarFieldTraits<ireal>::One(),x0);

      if (scanlogfn.size()<1 || rk != 0)
	scanlogfn = "/dev/null";

      ofstream scanlogstream(scanlogfn.c_str());

      ireal dh = h1-h0;
      if (nscan > 1) dh = (h1-h0)/((ireal)nscan);
      for (int n=0;n<nscan;n++) {
	x.copy(x0);
	ireal h = h0 + ((ireal)n)*dh;
	x.linComb(h,dx);
	ireal val = feval.getValue();
	if (rk==0) {
	  cerr<<h<<" "<<val<<endl;
	  if (scanlogfn != "/dev/null") {
	    scanlogstream<<h<<" "<<val<<endl;
	    scanlogstream.flush();
	  }
	}
      }
      if (scanlogfn != "/dev/null" && rk == 0)
	scanlogstream.close();

      iwave_fdestroy();

#ifdef IWAVE_USE_MPI
    }
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
#endif
  }
  catch (RVLException & e) {
    e<<"asginv.x: ABORT\n";
    e.write(cerr);
#ifdef IWAVE_USE_MPI
    MPI_Abort(MPI_COMM_WORLD,0);
#endif
    exit(1);
  }
}
