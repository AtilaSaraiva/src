/** \file asginv.cc
 * Driver for least-squares waveform inversion 
 * 
 * Usage: 
 *        ./asginv.x par=test.par
 *
 * accormodates both standard and extended inversion modes
 *  
 * \author William W. Symes and Dong Sun   
 * May, 2011
 */
/*================================================================================*/

#include "asginv_selfdoc.hh"
#include "asg_gfdm.h"
#include "asg_sampler.hh"
#include "seamx_headers.hh"
#include "iwop.hh"
#include "state.hh"
#include "samp.hh"
#include "ls.hh"
#include "blockop.hh"
#include "sim.hh"
#include "pol.hh"

#include "CPsim.hh"

#include "gridpp_top.hh"
#include "gridops.hh"
#include "griddiffops.hh"

#ifdef IWAVE_USE_MPI
#include "mpisegypp.hh"
#else
#include "segypp.hh"
#endif
#include "segyops.hh"

#include "LBFGSBT.hh"

using namespace RVLUmin;
using namespace RVLAlg;
using namespace TSOpt;
using namespace RVL;

namespace ASG {

  /* Sampler Policies */
  /** FwdSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveState,ASGSampler> ASGSamplerPolicy;
  /** LinSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGLinSampler> ASGLinSamplerPolicy;
  /** AdjSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGAdjSampler> ASGAdjSamplerPolicy;
 
  /* Sim Policies */  
  /** FwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdSim<IWaveState> > StdIWavePolicy;
  /** LinFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdRCSim<IWaveState> > StdRCIWavePolicy; 
  /** AdjFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, CPSim<IWaveState,TSIndex> > FwdCPSimPolicy;
  /** LinSimPolicy and AdjSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > LinSimPolicy;
 
 //typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > AdjSimPolicy;
   
  /* dummy sim policies to fill in the rest of the list */
  //class LinFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  //class LinSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};
  //class AdjFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  class AdjSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};

} 

void paramreader(PARARRAY pars, 
		 string const & key, 
		 string & val, 
		 bool warn,
		 FILE * stream) {
  try {
    char * cbuf = NULL;
    ps_ffcstring(pars,key.c_str(),&cbuf);
    if (!cbuf) {
      if (warn) {
	fprintf(stream,"NOTE: failed to read value for key = %s\n",key.c_str());
	fprintf(stream,"NOTE: returning empty value string\n");
	val="";
      }
      else {
	RVLException e;
	e<<"Error: asgfwd\n";
	e<<"failed to extract value for key="<<key<<" from param table\n";
	throw e;
      }
    }
    else {
      val=cbuf;
      free(cbuf);
      cbuf=NULL;
    }
  }
  catch (RVLException & e) {
    e<<"\ncalled from paramreader\n";
    throw e;
  }
}

int main(int argc, char ** argv) {
  xargc=argc;
  xargv=argv;

  using namespace ASG;
  try { 

    if (argc<2) { 
      RVLException e;
      e<<"asginv: least squares inversion\n";
      e<<"usage: asginv.x par=<par file>\n";
      throw e;
    }

    int rk = 0;

    /* set up execution environment */
#ifdef IWAVE_USE_MPI
    MPI_Init(&argc,&argv);
#endif

    PARARRAY pars;
    FILE * stream;
    IWaveEnvironment(argc,argv,&pars,&stream);
      
#ifdef IWAVE_USE_MPI
    if (retrieveGroupID() == MPI_UNDEFINED) {
      fprintf(stream,"NOTE: finalize MPI, cleanup, exit\n");
    }
    else {
      rk = retrieveGlobalRank();
#endif
      if (rk==0) requestdoc(1);

      /////////////////////////////////////////////////////
      //                     INPUT                       //
      /////////////////////////////////////////////////////
      
      /* file reading section - basic inputs */

      // major switch - invert for bulk modulus only, or for bulk modulus and buoyancy
      int bulkonly=0;
      ps_ffint(pars,"bulkonly",&bulkonly);
      // another major switch - if set, compute gradient, record, and exit
      int gradonly=0;
      ps_ffint(pars,"gradonly",&gradonly);

      //main input and output data files

      // inversion log - optional
      string invlogfn = "";
      paramreader(pars,"inv_logfile",invlogfn,true,stream);

      // optimization parameters - mandatory
      string uminparname;
      paramreader(pars,"uminpar",uminparname,false,stream);

      // initial model - mandatory
      string initbulkname;
      string initbuoyname;
      paramreader(pars,"init_bulkmod",initbulkname,false,stream);
      paramreader(pars,"init_buoyancy",initbuoyname,false,stream);

      // gradient at initial model - optional
      string initgradbulkname="";
      string initgradbuoyname="";
      paramreader(pars,"init_bulkmod_grad",initgradbulkname,true,stream);
      if (!bulkonly) 
	paramreader(pars,"init_buoyancy_grad",initgradbuoyname,true,stream);

      // final model
      string finalbulkname;
      string finalbuoyname;
      paramreader(pars,"final_bulkmod",finalbulkname,false,stream);
      if (!bulkonly)
	paramreader(pars,"final_buoyancy",finalbuoyname,false,stream);

      // gradient at final model - optional
      string finalgradbulkname="";
      string finalgradbuoyname="";
      paramreader(pars,"final_bulkmod_grad",finalgradbulkname,true,stream);
      if (!bulkonly)
	paramreader(pars,"final_buoyancy_grad",finalgradbuoyname,true,stream);

      // input data file
      string dataname;
      paramreader(pars,"datafile",dataname,false,stream);

      // final predicted data - optional
      string finaldataname;
      paramreader(pars,"finaldatafile",finaldataname,true,stream);

      // inversion window parameters
      string wgn;
      paramreader(pars,"window_grid",wgn,false,stream);
      float ww=0.0f;
      ps_fffloat(pars,"window_width",&ww);
	
      /* file reading section - upper and lower bounds
	 first try to read filename
	 if that fails, try to read const value for bound
	 if both fail throw exception 
	 key pattern:
	 for file, key = [b]_[param name]
	 for const, key = [filename]_val
	 here [b]     = ub or lb
	 [n]     = 1  or 2
	 [param_name] = M[n]   
	 
      */
      
      int NPAR = 2;
      if (bulkonly) NPAR=1;

      std::vector<string> b(2);
      b[0]="lb_";
      b[1]="ub_";
      //      std::vector<string> p(NPAR);
      std::vector<string> p(2);
      p[0]="bulk";
      //      if (!bulkonly) 
	p[1]="buoy";
      
	//      std::vector<string> bfn(2*NPAR);
      std::vector<string> bfn(4);
      //      std::vector<float> bv(2*NPAR);
      std::vector<float> bv(4);
    
      for (int ib=0; ib<2; ib++) {
	for (int ip=0; ip<NPAR; ip++) {
	  bfn[ip+2*ib]="";
	  // try to read file name
	  paramreader(pars,b[ib]+p[ip],bfn[ip+2*ib],true,stream);
	  // if no file, read value
	  if (bfn[ip+2*ib].size()==0) {
	    if (ps_fffloat(pars,(b[ib]+p[ip]+"_val").c_str(),&(bv[ip+NPAR*ib]))) {
	      RVLException e;
	      e<<"Error: asgfwd\n";
	      e<<"failed to extract values for keys "<<b[ib]+p[ip]+"_val"
	       <<" and "<<b[ib]+p[ip]<<" from param table\n";
	      throw e;
	    }
	  }
	}
      }

      /* mute option */

      float s=0.0f;
      float w=0.0f;
      float tm=0.0f;
      // internal flag
      int muteflag = 0;
      // mute_slope serves as flag for mute
      if (!ps_fffloat(pars,"mute_slope",&s) ||
	  !ps_fffloat(pars,"mute_zotime",&tm) ||
	  !ps_fffloat(pars,"mute_width",&w)) {
	muteflag = 1;
      }
	
      /////////////////////////////////////////////////////
      //              PREPROCESSING                      //
      /////////////////////////////////////////////////////
      
      /************ SPACES, VECTORS *****************/
      
#ifdef IWAVE_USE_MPI
      MPIGridSpace<float> m1sp(initbulkname);
      MPIGridSpace<float> m2sp(initbuoyname);
#else
      GridSpace<float> m1sp(initbulkname);
      GridSpace<float> m2sp(initbuoyname);
#endif
      StdProductSpace<float> msp(m1sp,m2sp);    
      
      //x0 stores initial model 
      Vector<float> x0(msp); 
      Components<float> cx0(x0);
      
      /* make SEGY space and vector */
#ifdef IWAVE_USE_MPI
      MPISEGYSpace tsp(dataname);
#else
      SEGYSpace tsp(dataname);
#endif
      // y stores data;
      Vector<float> y(tsp);
      
      /* assign model, data files */
      AssignFilename m1fn(initbulkname);
      AssignFilename m2fn(initbuoyname);
      cx0[0].eval(m1fn);
      cx0[1].eval(m2fn);
      AssignFilename tfn(dataname);
      y.eval(tfn);
      
      /***************** OPERATORS ******************/ 
      /* composite simulation operator, evaluation vector -
         zero if affine window, input model else */
      /* window option */
      
      OpComp<ireal> op;

      if (bulkonly) {
	InjectOp<float> inj(x0,0);
	op.setNext(inj);
      }
      
      /* simulator */
      IWaveOp<
      ASGSamplerPolicy,
	ASGLinSamplerPolicy,
	ASGAdjSamplerPolicy,
	StdIWavePolicy,
	StdRCIWavePolicy,
	LinSimPolicy,
	FwdCPSimPolicy,
	AdjSimPolicy
	> 
	iwop(msp,tsp,pars,stream,asg_gfdm);

      op.setNext(iwop);

      if (muteflag) {
	SEGYLinMute mute(s,tm,w);
	LinearOpFO<float> mop(tsp,tsp,mute,mute);
	op.setNext(mop);
      }

      /* load bound vectors - cannot do this until op is defined */
      Vector<float> ub(op.getDomain());
      Vector<float> lb(op.getDomain());
      Components<float> cub(ub);
      Components<float> clb(lb);
      
      for (int ip=0;ip<NPAR;ip++) {
	// lower bounds
	if (bfn[ip].size()) {
	  AssignFilename af(bfn[ip]);
	  clb[ip].eval(af);
	}
	else {
	  RVLAssignConst<float> ac(bv[ip]);
	  clb[ip].eval(ac);
	}
	
	// upper bounds
	if (bfn[ip+NPAR].size()) {
	  AssignFilename af(bfn[ip+NPAR]);
	  cub[ip].eval(af);
	}
	else {
	  RVLAssignConst<float> ac(bv[ip+NPAR]);
	  cub[ip].eval(ac);
	}
      }

      StdLeastSquaresFcnlGN<ireal> fls(op,y);

      RVLMin<float> mn;
#ifdef IWAVE_USE_MPI
      MPISerialFunctionObjectRedn<float,float> mpimn(mn);
      ULBoundsTest<float> ultest(lb,ub,mpimn);
#else
      ULBoundsTest<float> ultest(lb,ub,mn);
#endif
   
      FunctionalBd<float> fbd(fls,ultest);

      // finally, tack on window at front. There is no choice
      // here: a window operator is mandatory!

      Grid<float> wgrid;
      wgrid.readFile(wgn);
	
      // use OpComp here as a handle
      OpComp<ireal> preop;
      if (bulkonly) {
	GridWindowOp<float> wop(cx0[0],wgrid,ww);
	preop.setNext(wop);
      }
      else {
	GridWindowOp<float> wop(x0,wgrid,ww);
	preop.setNext(wop);
      }
	
      // build final operator
      FcnlOpComp<ireal> f(fbd,preop);
      //      f.write(cerr);
    
      /////////////////////////////////////////////////////
      //                OPTIMIZATION                     //
      /////////////////////////////////////////////////////
      
      // create solution vector, windowed/shifted to initial zero
      Vector<ireal> x(f.getDomain());
      x.zero();

      // optional gradient output
      if (initgradbulkname.size() || initgradbuoyname.size()) {
	Vector<ireal> g(f.getDomain());
	Components<ireal> cg(g);
	if (initgradbulkname.size()) {
	  AssignFilename afgbm(initgradbulkname);
	  cg[0].eval(afgbm);	
	}
	if (initgradbuoyname.size() && !bulkonly) {
	  AssignFilename afgby(initgradbuoyname);
	  cg[1].eval(afgby);	
	}
	 
	FunctionalEvaluation<ireal> feval(f,x);
	g.copy(feval.getGradient());

	if (gradonly) 
	  cout<<"value of LS function = "<<feval.getValue()<<endl;
      
      } 

      //      cerr<<"gradonly="<<gradonly<<endl;
      if (!gradonly) {

	Table uminpar(uminparname);

	Algorithm * umin;
	
	// if no log file specified, junk output by default
	if (invlogfn.size()<1 || rk > 0) 
	  invlogfn = "/dev/null";
	ofstream invlogstream(invlogfn.c_str());

        if (rk==0 && invlogfn=="/dev/null") {
	  cout<<"---- LS inversion, building LBFGSBT object -----------"<<endl;	
	  umin = new LBFGSBT<ireal>(f,x,uminpar,cout);
	  cout<<"----LS inversion, starts --------------"<<endl;
	}
	else {
	  invlogstream<<"---- LS inversion, building LBFGSBT object -----------"<<endl;	
	  umin = new LBFGSBT<ireal>(f,x,uminpar,invlogstream);
	  invlogstream<<"----LS inversion, starts --------------"<<endl;
	}

	umin->run();

	if (rk==0 && invlogfn=="/dev/null") 
	  cout<<"----LS inversion, ended --------------"<<endl;
	else 
	  invlogstream<<"----LS inversion, ended --------------"<<endl;

	delete umin;

	/****************************************************
	 *                    OUTPUT                        *
	 ****************************************************/
      
	Vector<ireal> xf(preop.getRange());

	Components<ireal> cxf(xf);

	if (finalbulkname.size()) {
	  AssignFilename bminv(finalbulkname);
	  cxf[0].eval(bminv);
	}
	if (finalbuoyname.size() && !bulkonly) { 
	  AssignFilename byinv(finalbuoyname);
	  cxf[1].eval(byinv);
	}

	OperatorEvaluation<ireal> preopeval(preop,x);
	xf.copy(preopeval.getValue());

	// produce final data if requested

	if (finaldataname.size()) {
	  Vector<float> yf(tsp);
	  AssignFilename fda(finaldataname);
	  yf.eval(fda);
	  OperatorEvaluation<float> final_opeval(op,xf);
	  yf.copy(final_opeval.getValue());
	}

	Vector<float> gf(preop.getRange());
	Components<float> cgf(gf);
	if (finalgradbulkname.size()) {
	  AssignFilename gbminv(finalgradbulkname);
	  cgf[0].eval(gbminv);
	}
	if (finalgradbuoyname.size() && !bulkonly) {
	  AssignFilename gbyinv(finalgradbuoyname);
	  cgf[1].eval(gbyinv);
	}

	// clean up temporary files
	iwave_fdestroy();
#ifdef IWAVE_USE_MPI
      } /* end nontriv comm branch */
    }
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
#endif
  }
  catch (RVLException & e) {
    e<<"asginv.x: ABORT\n";
    e.write(cerr);
#ifdef IWAVE_USE_MPI
    MPI_Abort(MPI_COMM_WORLD,0);
#endif
    exit(1);
  }
}
