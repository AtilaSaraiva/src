lib/pointsrc.c:	tr->srcin_flag = 0;
lib/pointsrc.c:		tr->srcin_flag = 1;
lib/pointsrc.c:	IASN(tr->is,IPNT_0);
lib/pointsrc.c:	RASN(tr->rs,RPNT_0);
lib/pointsrc.c:	tr->is[0]=tg->is[0]; tr->rs[0]=tg->rs[0]; tis[0]=tr->is[0];
lib/pointsrc.c:	if (ndim > 1) { tr->is[1]=tg->is[1]; tr->rs[1]=tg->rs[1]; tis[1]=tr->is[1]; }
lib/pointsrc.c:	if (ndim > 2) { tr->is[2]=tg->is[2]; tr->rs[2]=tg->rs[2]; tis[2]=tr->is[2]; } 
lib/pointsrc.c:	tr->order = 0;
lib/pointsrc.c:	ps_ffint(*par, "sampord", &(tr->order));
lib/pointsrc.c:	tr->fpsrc = NULL;
lib/pointsrc.c:	tr->fpdbg = NULL;
lib/pointsrc.c:		if ( (tr->is[i] < gs[i]) && (tr->is[i]+1 > gs[i]-1) ) tis[i]++;
lib/pointsrc.c:		if ( (tr->is[i] > ge[i]) && (tr->is[i]-1 < ge[i]+1) ) tis[i]--;
lib/pointsrc.c:		tis[i] = tr->is[i];
lib/pointsrc.c:		if ( (tr->is[i] < gs[i]) && (tr->is[i]+1 > gs[i]-1) ) tis[i]++;
lib/pointsrc.c:		if ( (tr->is[i] > ge[i]) && (tr->is[i]-1 < ge[i]+1) ) tis[i]--;
lib/pointsrc.c:	RASN( tr->src_d, RPNT_0);
lib/pointsrc.c:	if (tr->srcin_flag) {
lib/pointsrc.c:		tr->src_d[0] = REAL_ONE;
lib/pointsrc.c:		if (!(tr->fpsrc = iwave_const_fopen(srcfile, "r",NULL,stream))) {
lib/pointsrc.c:		if (fseek(tr->fpsrc,0L,SEEK_SET)) {
lib/pointsrc.c:		if (!fgettr(tr->fpsrc, &trsrc)) {
lib/pointsrc.c:		iwave_fclose(tr->fpsrc);
lib/pointsrc.c:		tr->istart = (int)(tmpt0/((m->tsind).dt));
lib/pointsrc.c:		t0 = (m->tsind).dt * tr->istart;
lib/pointsrc.c:		/*    tr->n = (int)(tmpnt*tmpdt/((m->tsind).dt))+1;*/
lib/pointsrc.c:		tr->n = (int)(tmax/((m->tsind).dt)) + 1;
lib/pointsrc.c:		tr->w = (ireal *)usermalloc_(sizeof(ireal)*(tr->n));
lib/pointsrc.c:		lnt  = (int)(tr->n * ((m->tsind).dt) / tmpdt) + 1;
lib/pointsrc.c:			if ((err=cubic_(&tmpt0, &tmpdt, resc, &lnt, &t0, &(tdt), tr->w, &(tr->n), &iend,wk,&wl))) {
lib/pointsrc.c:			if ((err=cubic_(&tmpt0, &tmpdt, resc, &lnt, &t0, &(tdt), tr->w,&(tr->n),&iend,wk,&wl))) {
lib/pointsrc.c:		if (tr->srcin_flag) {
lib/pointsrc.c:			tr->w = getrick( &iw, (m->tsind).dt, fpeak );
lib/pointsrc.c:			tr->n = 2 * iw+1;
lib/pointsrc.c:			tr->w = igetdgauss(&iw, (m->tsind).dt, fpeak);
lib/pointsrc.c:			tr->n = 2 * iw+1;
lib/pointsrc.c:		tr->istart = -iw;
lib/pointsrc.c:				tr->istart = -iw;
lib/pointsrc.c:				tr->istart = 0;
lib/pointsrc.c:/*			else if (!strcmp(wp,"anticausal")) tr->istart=-2*iw;*/
lib/pointsrc.c:		tr->idbg = 0;
lib/pointsrc.c:		ps_ffint(*par, "dump_wavelet", &(tr->idbg));
lib/pointsrc.c:		if (tr->idbg) {
lib/pointsrc.c:			memcpy(trdbg.data,tr->w,tr->n*sizeof(ireal));
lib/pointsrc.c:			val.h=tr->n;
lib/pointsrc.c:			val.h=((m->tsind).dt)*tr->istart;
lib/pointsrc.c:			if (!(tr->fpdbg=iwave_const_fopen("wavelet.debug","w",NULL,stream))) {
lib/pointsrc.c:			fputtr(tr->fpdbg,&trdbg);
lib/pointsrc.c:			fflush(tr->fpdbg);
lib/pointsrc.c:			iwave_fclose(tr->fpdbg);
lib/pointsrc.c:		if (tr->srcin_flag){
lib/pointsrc.c:				tr->scramp = refbou * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c:				tr->scramp = refbou * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c:				tr->scramp =  4.0 * 3.1415927 * refvel * refvel * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c:				tr->scramp =  refkappa * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c:		if (tr->srcin_flag){
lib/pointsrc.c:				tr->scramp = refbou * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c:				tr->scramp =  4.0 * 3.1415927 * refvel * refvel * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c:  	if (tr->w) userfree_(&(tr->w)); 
lib/pointsrc.c:  	if ( tr->fpsrc ) iwave_fclose(tr->fpsrc);
lib/pointsrc.c:  	if ( tr->fpdbg ) iwave_fclose(tr->fpdbg);
lib/pointsrc.c:	fprintf(stderr,"     evaluating source for iv = %d, it = %d, and istart = %d\n",(m->tsind).iv,(m->tsind).it,tr->istart);
lib/pointsrc.c:	if (tr->srcin_flag){
lib/pointsrc.c://		if ( ((m->tsind).it < tr->n_comp) && ((m->tsind).iv == 1 ) ){
lib/pointsrc.c:		if ( ((m->tsind).it >= tr->istart) &&
lib/pointsrc.c:		     ((m->tsind).it <  tr->istart + tr->n) && 
lib/pointsrc.c:      				pointsource( tr->is,
lib/pointsrc.c:		  		             tr->rs,
lib/pointsrc.c:		  		             tr->order,
lib/pointsrc.c:		  		             tr->scramp,
lib/pointsrc.c:		  		             tr->src_d[i] * (tr->w)[ (m->tsind).it - tr->istart ],
lib/pointsrc.c:// 		if ( ((m->tsind).it < tr->n_comp) && ((m->tsind).iv == 0 ) ){
lib/pointsrc.c:		if ( ((m->tsind).it >= tr->istart) &&
lib/pointsrc.c:		     ((m->tsind).it <  tr->istart + tr->n) && 
lib/pointsrc.c:      				pointsource( tr->is,
lib/pointsrc.c:		  		             tr->rs,
lib/pointsrc.c:		  		             tr->order,
lib/pointsrc.c:		  		             tr->scramp,
lib/pointsrc.c:		  		             (tr->w)[ (m->tsind).it - tr->istart ],
lib/pointsrc.c:	fprintf(fp,"srcin_flag   = %d\n",tr->srcin_flag);
lib/pointsrc.c:	fprintf(fp,"pulse length = %d\n",tr->n);
lib/pointsrc.c:  	fprintf(fp,"istart       = %d\n",tr->istart);
lib/pointsrc.c:  	fprintf(fp,"order        = %d\n",tr->order);
lib/pointsrc.c:	fprintf(fp,"scramp       = %e\n",tr->scramp);
lib/pointsrc.c:      		fprintf(fp,"is[%d]=%d rs[%d]=%e src_d[%d]=%e\n", i, tr->is[i], i, tr->rs[i],i,tr->src_d[i]);
lib/pointsrc.c.bak:  IASN(tr->is,IPNT_0);
lib/pointsrc.c.bak:  RASN(tr->rs,RPNT_0);
lib/pointsrc.c.bak:  tr->is[0]=tg->is[0]; tr->rs[0]=tg->rs[0]; tis[0]=tr->is[0];
lib/pointsrc.c.bak:  if (ndim > 1) { tr->is[1]=tg->is[1]; tr->rs[1]=tg->rs[1]; tis[1]=tr->is[1]; }
lib/pointsrc.c.bak:  if (ndim > 2) { tr->is[2]=tg->is[2]; tr->rs[2]=tg->rs[2]; tis[2]=tr->is[2]; } 
lib/pointsrc.c.bak:  tr->order = 0;
lib/pointsrc.c.bak:  ps_ffint(*par, "sampord", &(tr->order));
lib/pointsrc.c.bak:  tr->fpsrc = NULL;
lib/pointsrc.c.bak:  tr->fpdbg = NULL;
lib/pointsrc.c.bak:    if ( (tr->is[i] < gs[i]) && (tr->is[i]+1 > gs[i]-1) ) tis[i]++;
lib/pointsrc.c.bak:    if ( (tr->is[i] > ge[i]) && (tr->is[i]-1 < ge[i]+1) ) tis[i]--;
lib/pointsrc.c.bak:    tis[i] = tr->is[i];
lib/pointsrc.c.bak:    if ( (tr->is[i] < gs[i]) && (tr->is[i]+1 > gs[i]-1) ) tis[i]++;
lib/pointsrc.c.bak:    if ( (tr->is[i] > ge[i]) && (tr->is[i]-1 < ge[i]+1) ) tis[i]--;
lib/pointsrc.c.bak:    tr->scramp =  4.0 * 3.1415927 * refvel * refvel * 
lib/pointsrc.c.bak:    tr->scramp =  refkappa * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c.bak:    if (!(tr->fpsrc = iwave_const_fopen(srcfile, "r",NULL,stream))) {
lib/pointsrc.c.bak:    if (fseek(tr->fpsrc,0L,SEEK_SET)) {
lib/pointsrc.c.bak:    if (!fgettr(tr->fpsrc, &trsrc)) {
lib/pointsrc.c.bak:    iwave_fclose(tr->fpsrc);
lib/pointsrc.c.bak:    tr->istart = (int)(tmpt0/((m->tsind).dt));
lib/pointsrc.c.bak:    t0 = (m->tsind).dt * tr->istart;
lib/pointsrc.c.bak:    /*    tr->n = (int)(tmpnt*tmpdt/((m->tsind).dt))+1;*/
lib/pointsrc.c.bak:    tr->n = (int)(tmax/((m->tsind).dt)) + 1 - tr->istart;
lib/pointsrc.c.bak:    tr->w = (ireal *)malloc(sizeof(ireal)*(tr->n));
lib/pointsrc.c.bak:    lnt  = (int)(tr->n * ((m->tsind).dt) / tmpdt) + 1;
lib/pointsrc.c.bak:      if ((err=cubic_(&tmpt0, &tmpdt, resc, &lnt, &t0, &(tdt), tr->w, &(tr->n), &iend,wk,&wl))) {
lib/pointsrc.c.bak:      if ((err=cubic_(&tmpt0, &tmpdt, resc, &lnt, &t0, &(tdt), tr->w,&(tr->n),&iend,wk,&wl))) {
lib/pointsrc.c.bak:    tr->w = igetdgauss(&iw, (m->tsind).dt, fpeak);
lib/pointsrc.c.bak:    tr->n = 2 * iw+1;
lib/pointsrc.c.bak:    tr->istart = -iw;
lib/pointsrc.c.bak:      if (!strcmp(wp,"zerophase")) tr->istart=-iw;
lib/pointsrc.c.bak:      else if (!strcmp(wp,"causal")) tr->istart=0;
lib/pointsrc.c.bak:      else if (!strcmp(wp,"anticausal")) tr->istart=-2*iw;
lib/pointsrc.c.bak:  tr->idbg = 0;
lib/pointsrc.c.bak:  ps_ffint(*par, "dump_wavelet", &(tr->idbg));
lib/pointsrc.c.bak:  if (tr->idbg) {
lib/pointsrc.c.bak:    memcpy(trdbg.data,tr->w,tr->n*sizeof(ireal));
lib/pointsrc.c.bak:    val.h=tr->n;
lib/pointsrc.c.bak:    val.h=((m->tsind).dt)*tr->istart;
lib/pointsrc.c.bak:    if (!(tr->fpdbg=iwave_const_fopen("wavelet.debug","w",NULL,stream))) {
lib/pointsrc.c.bak:    fputtr(tr->fpdbg,&trdbg);
lib/pointsrc.c.bak:    fflush(tr->fpdbg);
lib/pointsrc.c.bak:    iwave_fclose(tr->fpdbg);
lib/pointsrc.c.bak:  if (tr->w)       free(tr->w); 
lib/pointsrc.c.bak:  if ( tr->fpsrc ) iwave_fclose(tr->fpsrc);
lib/pointsrc.c.bak:  if ( tr->fpdbg ) iwave_fclose(tr->fpdbg);
lib/pointsrc.c.bak:  if ( ((m->tsind).it >= tr->istart) && 
lib/pointsrc.c.bak:       ((m->tsind).it < tr->istart + tr->n) &&
lib/pointsrc.c.bak:      pointsource(tr->is,
lib/pointsrc.c.bak:		  tr->rs,
lib/pointsrc.c.bak:		  tr->order,
lib/pointsrc.c.bak:		  tr->scramp,
lib/pointsrc.c.bak:		  (tr->w)[(m->tsind).it-tr->istart],
lib/pointsrc.c.bak:  fprintf(fp,"pulse length = %d\n",tr->n);
lib/pointsrc.c.bak:  fprintf(fp,"istart       = %d\n",tr->istart);
lib/pointsrc.c.bak:  fprintf(fp,"order        = %d\n",tr->order);
lib/pointsrc.c.bak:      fprintf(fp,"is[%d]=%d rs[%d]=%e\n", i, tr->is[i], i, tr->rs[i]);
lib/smooth_pointsrc.c:		x = x * d[i] - tr->xs[i];
lib/smooth_pointsrc.c:  if (r < tr->rad)  return 0.0;
lib/smooth_pointsrc.c:  gradphi = -compdgauss(r - tr->rad,  tr->phipeak )
lib/smooth_pointsrc.c:          * (2.0 * pi * pi * tr->phipeak * tr->phipeak)  * xd / r;
lib/smooth_pointsrc.c:	if (tr->tmpflag == 3) /* Option Ia */
lib/smooth_pointsrc.c:		p = cubic_interp( t - r / tr->c, tr->dt, tr->w, tr->n, tr->t0)/ r;
lib/smooth_pointsrc.c:  else if (tr->tmpflag == 2) /* Option Ib */
lib/smooth_pointsrc.c:    p = cubic_interp(t - r / tr->c, tr->dt, tr->w1, tr->n, tr->t0)/ r;
lib/smooth_pointsrc.c:	else if (tr->tmpflag == 1)  /* Ricker */
lib/smooth_pointsrc.c:		p = comprick(t + tr->istart * dt - r / tr->c, tr->fpeak) / r;
lib/smooth_pointsrc.c:		x = ((ireal)(ind[i])) * d[i] - tr->xs[i];
lib/smooth_pointsrc.c:  if (r < tr->rad)  return 0.0;
lib/smooth_pointsrc.c:  gradphi = -compdgauss(r - tr->rad,  tr->phipeak)
lib/smooth_pointsrc.c:          * (2.0 * pi * pi * tr->phipeak * tr->phipeak) / r;
lib/smooth_pointsrc.c:	if (tr->tmpflag == 3)  /* Option Ia */
lib/smooth_pointsrc.c:		f0 = cubic_interp( t - r / tr->c, tr->dt, tr->w, tr->n, tr->t0) / tr->c;
lib/smooth_pointsrc.c:		f1 = cubic_interp( t - r / tr->c, tr->dt, tr->w1, tr->n, tr->t0) / r;
lib/smooth_pointsrc.c:  else if (tr->tmpflag == 2)  /* Option Ib */
lib/smooth_pointsrc.c:    f0 = cubic_interp( t - r / tr->c, tr->dt, tr->w1, tr->n, tr->t0) / tr->c;
lib/smooth_pointsrc.c:		f1 = cubic_interp( t - r / tr->c, tr->dt, tr->w, tr->n, tr->t0) / r;
lib/smooth_pointsrc.c:	else if (tr->tmpflag == 1) /* Ricker */
lib/smooth_pointsrc.c:		f0 = comprick( t + tr->istart * dt - r / tr->c, tr->fpeak) / tr->c;
lib/smooth_pointsrc.c:		f1 = compdgauss( t + tr->istart * dt - r / tr->c, tr->fpeak) / r;
lib/smooth_pointsrc.c:	return tr->bou * ( f0 + f1) * gradphi;;
lib/smooth_pointsrc.c:  tr->fpeak = FPEAK_DEF;  
lib/smooth_pointsrc.c:  tr->phipeak = FPEAK_DEF;        
lib/smooth_pointsrc.c:  RASN(tr->xs, RPNT_0);
lib/smooth_pointsrc.c:  for (i = 0; i < ndim; i++) tr->xs[i] = ( (float)(tg->is[i]) + tg->rs[i] ) * d[i];
lib/smooth_pointsrc.c:	tr->c = refvel;
lib/smooth_pointsrc.c:	tr->bou = refbou;
lib/smooth_pointsrc.c:	if (ps_ffreal(*par, "cutoff_peak", &(tr->phipeak)))
lib/smooth_pointsrc.c:    fprintf(stream,"parameter for the cutoff function (cutoff_width) = %e\n", tr->phipeak);
lib/smooth_pointsrc.c:  tr->rad = 1.4 / tr->phipeak; 
lib/smooth_pointsrc.c:  if (ps_ffreal(*par, "cutoff_rad", &(tr->rad)))
lib/smooth_pointsrc.c:    fprintf(stream, "rad of the flat area in the cutoff function = %e\n", tr->rad);
lib/smooth_pointsrc.c:  IASN(tr->ixs, IPNT_0);
lib/smooth_pointsrc.c:  IASN(tr->ixe, IPNT_0);
lib/smooth_pointsrc.c:		phiw[i] = 1 + (int)(floor( (tr->rad +  1.4 / tr->phipeak) / d[i] + 0.1));  
lib/smooth_pointsrc.c:		tr->ixs[i] = is[i] - phiw[i];
lib/smooth_pointsrc.c:		tr->ixe[i] = is[i] + phiw[i];    
lib/smooth_pointsrc.c:    tr->scramp = refamp * refdist * m->tsind.dt;
lib/smooth_pointsrc.c:    tr->scramp = m->tsind.dt;
lib/smooth_pointsrc.c:    if (!(tr->fpsrc = fopen(srcfile, "r"))) {
lib/smooth_pointsrc.c:    if (!fgettr(tr->fpsrc, &trsrc)) {
lib/smooth_pointsrc.c:    tr->n = vtoi(hdtype("ns"), val);
lib/smooth_pointsrc.c:    tr->dt = 0.001 * vtof(hdtype("dt"), val);
lib/smooth_pointsrc.c:    tr->istart = (int)(floor(tmpt0 / m->tsind.dt));
lib/smooth_pointsrc.c:    tr->t0 = (m->tsind).dt * tr->istart;
lib/smooth_pointsrc.c:    tr->w = (ireal *)malloc(sizeof(ireal)*(tr->n));
lib/smooth_pointsrc.c:		tr->w1 = (ireal *)malloc(sizeof(ireal)*(tr->n));
lib/smooth_pointsrc.c:    for (i = 0; i < tr->n; i++)  tr->w[i] = trsrc.data[i];
lib/smooth_pointsrc.c:			tr->tmpflag = 3;
lib/smooth_pointsrc.c:      tr->w1[0] = 0.0;
lib/smooth_pointsrc.c:      for (i = 1; i < tr->n; i++) 
lib/smooth_pointsrc.c:				q += 0.5 * tr->dt * (tr->w[i] + tr->w[i - 1]);
lib/smooth_pointsrc.c:				tr->w1[i] = q;
lib/smooth_pointsrc.c:      tr->tmpflag = 2;
lib/smooth_pointsrc.c:      tr->w1[0] = 0.0;
lib/smooth_pointsrc.c:      for (i = 1; i < tr->n - 1; i++) 
lib/smooth_pointsrc.c:				tr->w1[i] = (tr->w[i + 1] - tr->w[i - 1]) / (2.0 *  tr->dt);
lib/smooth_pointsrc.c:      tr->w1[tr->n- 1] = 0.0;
lib/smooth_pointsrc.c:		tr->tmpflag = 1;
lib/smooth_pointsrc.c:		if (ps_ffreal(*par,"fpeak", &(tr->fpeak))) 
lib/smooth_pointsrc.c:			fprintf(stream,"peak frequency (fpeak) = %e\n", tr->fpeak);
lib/smooth_pointsrc.c:    tr->w = getrick(&iw, (m->tsind).dt, tr->fpeak);
lib/smooth_pointsrc.c:    tr->w1 = getdgauss(&iw, (m->tsind).dt, tr->fpeak);
lib/smooth_pointsrc.c:		tr->istart = -iw;
lib/smooth_pointsrc.c:		tr->n = 2 * iw + 1;
lib/smooth_pointsrc.c:    tr->dt = m->tsind.dt;
lib/smooth_pointsrc.c:			if (!strcmp(wp,"zerophase")) tr->istart = -iw;
lib/smooth_pointsrc.c:			else if (!strcmp(wp,"causal")) tr->istart = 0;
lib/smooth_pointsrc.c:			else if (!strcmp(wp,"anticausal")) tr->istart = -2 * iw;
lib/smooth_pointsrc.c:  tr->sn = (int)((tr->rad + 1.4 / tr->phipeak) / tr->c / m->tsind.dt) + 1 + tr->n;
lib/smooth_pointsrc.c:  tr->idbg = 0;
lib/smooth_pointsrc.c:  ps_ffint(*par, "dump_wavelet", &(tr->idbg));
lib/smooth_pointsrc.c:  if ( (tr->idbg) && (rk==0) )
lib/smooth_pointsrc.c:    if (tr->idbg == 1)  memcpy(trdbg.data, tr->w, tr->n * sizeof(ireal));
lib/smooth_pointsrc.c:		if (tr->idbg == 2)  memcpy(trdbg.data, tr->w1, tr->n * sizeof(ireal));
lib/smooth_pointsrc.c:    val.u=1000.0*(tr->dt);
lib/smooth_pointsrc.c:    val.h=tr->n;
lib/smooth_pointsrc.c:    val.h=tr->dt * tr->istart;
lib/smooth_pointsrc.c:    if (!(tr->fpdbg=fopen("wavelet.debug","w"))) {
lib/smooth_pointsrc.c:    fputtr(tr->fpdbg,&trdbg);
lib/smooth_pointsrc.c:    fflush(tr->fpdbg);
lib/smooth_pointsrc.c:  if ( (m->tsind.it >= tr->istart) &&  (m->tsind.it <= tr->istart + tr->sn) )
lib/smooth_pointsrc.c:      for (ix[2] = iwave_max(tr->ixs[2], gs[2]); ix[2] < iwave_min(tr->ixe[2] + 1, ge[2] + 1); ix[2]++) 
lib/smooth_pointsrc.c:          for (ix[1] = iwave_max(tr->ixs[1], gs[1]); ix[1] < iwave_min(tr->ixe[1] + 1, ge[1] + 1); ix[1]++) 
lib/smooth_pointsrc.c:              for (ix[0] = iwave_max(tr->ixs[0], gs[0]); ix[0] < iwave_min(tr->ixe[0] + 1, ge[0] + 1); ix[0]++) 
lib/smooth_pointsrc.c:                  ps = bm * tr->scramp * vfun(ix, d, ndim, tr, t + 0.5 * m->tsind.dt, m->tsind.dt);
lib/smooth_pointsrc.c:        for (ix[2] = iwave_max(tr->ixs[2], gs[2]); ix[2] < iwave_min(tr->ixe[2] + ((i==2) ? 0 : 1), ge[2] + 1); ix[2]++) 
lib/smooth_pointsrc.c:            for (ix[1] = iwave_max(tr->ixs[1], gs[1]); ix[1] < iwave_min(tr->ixe[1] + ((i==1) ? 0 : 1), ge[1] + 1); ix[1]++) 
lib/smooth_pointsrc.c:                for (ix[0] = iwave_max(tr->ixs[0], gs[0]); ix[0] < iwave_min(tr->ixe[0] + ((i==0) ? 0 : 1), ge[0] + 1); ix[0]++) 
lib/smooth_pointsrc.c:                      ps = bou * tr->scramp * pfun(ix, d, ndim, tr, t + m->tsind.dt, i, m->tsind.dt);
lib/smooth_pointsrc.c:  fprintf(fp,"source sound vel = %f\n",tr->c);
lib/smooth_pointsrc.c:	fprintf(fp,"source bou       = %f\n", tr->bou);
lib/smooth_pointsrc.c:  fprintf(fp,"istart           = %d\n", tr->istart);
lib/smooth_pointsrc.c:	fprintf(fp,"n                = %d\n", tr->n);
lib/smooth_pointsrc.c:  fprintf(fp,"dt                = %f\n", tr->dt);
lib/smooth_pointsrc.c:  fprintf(fp,"sn               = %d\n", tr->sn);
lib/smooth_pointsrc.c:  fprintf(fp,"fpeak            = %f\n", tr->fpeak);
lib/smooth_pointsrc.c:	fprintf(fp,"phipeak          = %f\n", tr->phipeak);
lib/smooth_pointsrc.c:    fprintf(fp,"xs[%d]=%f\n", i, tr->xs[i]);
lib/smooth_pointsrc.c:    fprintf(fp,"ixs[%d]=%d ixe[%d]=%d\n", i, tr->ixs[i], i, tr->ixe[i]);
lib/pointsrc.c~:	tr->srcin_flag = 0;
lib/pointsrc.c~:		tr->srcin_flag = 1;
lib/pointsrc.c~:	IASN(tr->is,IPNT_0);
lib/pointsrc.c~:	RASN(tr->rs,RPNT_0);
lib/pointsrc.c~:	tr->is[0]=tg->is[0]; tr->rs[0]=tg->rs[0]; tis[0]=tr->is[0];
lib/pointsrc.c~:	if (ndim > 1) { tr->is[1]=tg->is[1]; tr->rs[1]=tg->rs[1]; tis[1]=tr->is[1]; }
lib/pointsrc.c~:	if (ndim > 2) { tr->is[2]=tg->is[2]; tr->rs[2]=tg->rs[2]; tis[2]=tr->is[2]; } 
lib/pointsrc.c~:	tr->order = 0;
lib/pointsrc.c~:	ps_ffint(*par, "sampord", &(tr->order));
lib/pointsrc.c~:	tr->fpsrc = NULL;
lib/pointsrc.c~:	tr->fpdbg = NULL;
lib/pointsrc.c~:		if ( (tr->is[i] < gs[i]) && (tr->is[i]+1 > gs[i]-1) ) tis[i]++;
lib/pointsrc.c~:		if ( (tr->is[i] > ge[i]) && (tr->is[i]-1 < ge[i]+1) ) tis[i]--;
lib/pointsrc.c~:		tis[i] = tr->is[i];
lib/pointsrc.c~:		if ( (tr->is[i] < gs[i]) && (tr->is[i]+1 > gs[i]-1) ) tis[i]++;
lib/pointsrc.c~:		if ( (tr->is[i] > ge[i]) && (tr->is[i]-1 < ge[i]+1) ) tis[i]--;
lib/pointsrc.c~:	RASN( tr->src_d, RPNT_0);
lib/pointsrc.c~:	if (tr->srcin_flag) {
lib/pointsrc.c~:		tr->src_d[0] = REAL_ONE;
lib/pointsrc.c~:		if (!(tr->fpsrc = iwave_const_fopen(srcfile, "r",NULL,stream))) {
lib/pointsrc.c~:		if (fseek(tr->fpsrc,0L,SEEK_SET)) {
lib/pointsrc.c~:		if (!fgettr(tr->fpsrc, &trsrc)) {
lib/pointsrc.c~:		iwave_fclose(tr->fpsrc);
lib/pointsrc.c~:		tr->istart = (int)(tmpt0/((m->tsind).dt));
lib/pointsrc.c~:		t0 = (m->tsind).dt * tr->istart;
lib/pointsrc.c~:		/*    tr->n = (int)(tmpnt*tmpdt/((m->tsind).dt))+1;*/
lib/pointsrc.c~:		tr->n = (int)(tmax/((m->tsind).dt)) + 1;
lib/pointsrc.c~:		tr->w = (ireal *)usermalloc_(sizeof(ireal)*(tr->n));
lib/pointsrc.c~:		lnt  = (int)(tr->n * ((m->tsind).dt) / tmpdt) + 1;
lib/pointsrc.c~:			if ((err=cubic_(&tmpt0, &tmpdt, resc, &lnt, &t0, &(tdt), tr->w, &(tr->n), &iend,wk,&wl))) {
lib/pointsrc.c~:			if ((err=cubic_(&tmpt0, &tmpdt, resc, &lnt, &t0, &(tdt), tr->w,&(tr->n),&iend,wk,&wl))) {
lib/pointsrc.c~:		if (tr->srcin_flag) {
lib/pointsrc.c~:			tr->w = getrick( &iw, (m->tsind).dt, fpeak );
lib/pointsrc.c~:			tr->n = 2 * iw+1;
lib/pointsrc.c~:			tr->w = igetdgauss(&iw, (m->tsind).dt, fpeak);
lib/pointsrc.c~:			tr->n = 2 * iw+1;
lib/pointsrc.c~:		tr->istart = -iw;
lib/pointsrc.c~:				tr->istart = -iw;
lib/pointsrc.c~:				tr->istart = 0;
lib/pointsrc.c~:/*			else if (!strcmp(wp,"anticausal")) tr->istart=-2*iw;*/
lib/pointsrc.c~:		tr->idbg = 0;
lib/pointsrc.c~:		ps_ffint(*par, "dump_wavelet", &(tr->idbg));
lib/pointsrc.c~:		if (tr->idbg) {
lib/pointsrc.c~:			memcpy(trdbg.data,tr->w,tr->n*sizeof(ireal));
lib/pointsrc.c~:			val.h=tr->n;
lib/pointsrc.c~:			val.h=((m->tsind).dt)*tr->istart;
lib/pointsrc.c~:			if (!(tr->fpdbg=iwave_const_fopen("wavelet.debug","w",NULL,stream))) {
lib/pointsrc.c~:			fputtr(tr->fpdbg,&trdbg);
lib/pointsrc.c~:			fflush(tr->fpdbg);
lib/pointsrc.c~:			iwave_fclose(tr->fpdbg);
lib/pointsrc.c~:		if (tr->srcin_flag){
lib/pointsrc.c~:				tr->scramp = refbou * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c~:				tr->scramp = refbou * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c~:				tr->scramp =  4.0 * 3.1415927 * refvel * refvel * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c~:				tr->scramp =  refkappa * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c~:		if (tr->srcin_flag){
lib/pointsrc.c~:				tr->scramp = refbou * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c~:				tr->scramp =  4.0 * 3.1415927 * refvel * refvel * refdist * refamp * ((m->tsind).dt) / prod_d;
lib/pointsrc.c~:  	if (tr->w) userfree_(&(tr->w)); 
lib/pointsrc.c~:  	if ( tr->fpsrc ) iwave_fclose(tr->fpsrc);
lib/pointsrc.c~:  	if ( tr->fpdbg ) iwave_fclose(tr->fpdbg);
lib/pointsrc.c~:	fprintf(stderr,"     evaluating source for iv = %d, it = %d, and istart = %d\n",(m->tsind).iv,(m->tsind).it,tr->istart);
lib/pointsrc.c~:	if (tr->srcin_flag){
lib/pointsrc.c~://		if ( ((m->tsind).it < tr->n_comp) && ((m->tsind).iv == 1 ) ){
lib/pointsrc.c~:		if ( ((m->tsind).it >= tr->istart) &&
lib/pointsrc.c~:		     ((m->tsind).it <  tr->istart + tr->n) && 
lib/pointsrc.c~:      				pointsource( tr->is,
lib/pointsrc.c~:		  		             tr->rs,
lib/pointsrc.c~:		  		             tr->order,
lib/pointsrc.c~:		  		             tr->scramp,
lib/pointsrc.c~:		  		             tr->src_d[i] * (tr->w)[ (m->tsind).it - tr->istart ],
lib/pointsrc.c~:// 		if ( ((m->tsind).it < tr->n_comp) && ((m->tsind).iv == 0 ) ){
lib/pointsrc.c~:		if ( ((m->tsind).it >= tr->istart) &&
lib/pointsrc.c~:		     ((m->tsind).it <  tr->istart + tr->n) && 
lib/pointsrc.c~:      				pointsource( tr->is,
lib/pointsrc.c~:		  		             tr->rs,
lib/pointsrc.c~:		  		             tr->order,
lib/pointsrc.c~:		  		             tr->scramp,
lib/pointsrc.c~:		  		             (tr->w)[ (m->tsind).it - tr->istart ],
lib/pointsrc.c~:	fprintf(fp,"srcin_flag   = %d\n",tr->srcin_flag);
lib/pointsrc.c~:	fprintf(fp,"pulse length = %d\n",tr->n);
lib/pointsrc.c~:  	fprintf(fp,"istart       = %d\n",tr->istart);
lib/pointsrc.c~:  	fprintf(fp,"order        = %d\n",tr->order);
lib/pointsrc.c~:	fprintf(fp,"scramp       = %e\n",tr->scramp);
lib/pointsrc.c~:      		fprintf(fp,"is[%d]=%d rs[%d]=%e src_d[%d]=%e\n", i, tr->is[i], i, tr->rs[i],i,tr->src_d[i]);
