#include "asg_gfdm.h"

#include "state.hh"
#include "asg_sampler.hh"
#include "seamx_headers.hh"
#include "iwop.hh"
#include "samp.hh"
#include "sim.hh"
#include "pol.hh"

#include "adjtest.hh"
#include "CPsim.hh"
#include "functions.hh"
#include "blockop.hh"

#ifdef IWAVE_USE_MPI
#include "mpisegypp.hh"
#include "mpigridpp.hh"
#else
#include "segypp.hh"
#include "gridpp.hh"
#endif
#include "segyops.hh"
#include "gridops.hh"

// choice of inputs
#define M1 "bulkmod"
#define M2 "buoyancy"
#define N1 bulname
#define N2 buoname

using TSOpt::IWaveEnvironment;
using TSOpt::IWaveState;
using TSOpt::IWaveLinState;
using TSOpt::IWaveStep;
using TSOpt::IWaveStaticInit;
using TSOpt::IWaveDynamicInit;
using TSOpt::IWaveOp;
using TSOpt::Sampler;
using TSOpt::LinSampler;
using TSOpt::Sim;
using TSOpt::StdSim;
using TSOpt::StdRCSim;
using TSOpt::StdSimData;

using TSOpt::CPSim;

#ifdef IWAVE_USE_MPI
using TSOpt::MPIGridSpace;
using TSOpt::MPISEGYSpace;
#else
using TSOpt::GridSpace;
using TSOpt::SEGYSpace;
#endif

using TSOpt::SEGYLinMute;
using TSOpt::GridWindowOp;

using TSOpt::OpNewCreatePolicy;
using TSOpt::PolicyBase;
using RVL::StdProductSpace;
using RVL::Vector;
using RVL::Components;
using RVL::LinearOp;
using RVL::LinearOpFO;
using RVL::Operator;
using RVL::OperatorEvaluation;
using RVL::OpComp;
using RVL::OpFO;
using RVL::InjectOp;
using RVL::LNLOperator;
using RVL::DerivEvaluation;
using RVL::RVLException;
using RVL::AssignFilename;
using RVL::AssignParams;
using RVL::RVLAssignConst;
using RVL::AdjointTest;
using RVL::RVLRandomize;
using RVL::parse;

namespace ASG{

  /* dummy sampler policies to fill in the rest of the list */
  // class LinSamplerPolicy: public PolicyBase<IWaveState,LinSampler<IWaveLinState> > {};
  // class AdjSamplerPolicy: public PolicyBase<IWaveState,LinSampler<IWaveLinState> > {};
 
  /* Sampler Policies */
  /** FwdSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveState,ASGSampler> ASGSamplerPolicy;
  /** LinSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGLinSampler> ASGLinSamplerPolicy;
  /** AdjSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGAdjSampler> ASGAdjSamplerPolicy;
 
  /* Sim Policies */  
  /** FwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdSim<IWaveState> > StdIWavePolicy;
  /** LinFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdRCSim<IWaveState> > StdRCIWavePolicy; 
  /** AdjFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, CPSim<IWaveState,TSIndex> > FwdCPSimPolicy;
  /** LinSimPolicy and AdjSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > LinSimPolicy;
 
  //typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > AdjSimPolicy;
   
  /* dummy sim policies to fill in the rest of the list */
  //class LinFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  //class LinSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};
  //class AdjFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  class AdjSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};
}

char ** xargv;

int main(int argc, char ** argv) {

  using namespace ASG;
  try { 

    // put there to avoid forgetting
    if (argc<2) { 
      cerr<<"asgadjtest: adjoint test linearized fwd map\n";
      cerr<<"usage: asgadjtest.x par=<par file>\n";
      exit(0);
    }

    /* set up execution environment */
    int ts=0;
#ifdef IWAVE_USE_MPI
    MPI_Init_thread(&argc,&argv,MPI_THREAD_FUNNELED,&ts);
#endif    
    PARARRAY * pars = NULL;
    FILE * stream = NULL;
    IWaveEnvironment(argc,argv,ts,&pars,&stream);
    
#ifdef IWAVE_USE_MPI
    if (retrieveGroupID() == MPI_UNDEFINED) {
      fprintf(stream,"NOTE: finalize MPI, cleanup, exit\n");
    }
    // the rest of the code
    else {
#endif

      if (retrieveRank()==0) { cerr<<"IWAVE++::ASG adjoint test\n"; }

      /* concoct acoustic model space, vector, product vector components */
      string N1 = "";
      string N2 = "";
      string hdrname = "";
      string outfile = "";

      if (!parse<string>(*pars,M1,N1)) {
	RVLException e;
	e<<"Error: asgadj\n";
	e<<"failed to extract value for key="<<M1<<" from param table\n";
	throw e;
      }

      if (!parse<string>(*pars,M2,N2)) {
	RVLException e;
	e<<"Error: asgadj\n";
	e<<"failed to extract value for key="<<M2<<" from param table\n";
	throw e;
      }

      if (!parse<string>(*pars,"hdrfile",hdrname)) {
	RVLException e;
	e<<"Error: asgadj\n";
	e<<"failed to extract value for key=hdrfile from param table\n";
	throw e;
      }
      
#ifdef IWAVE_USE_MPI
      MPIGridSpace m1sp(N1);
      MPIGridSpace m2sp(N2);
#else
      GridSpace m1sp(N1);
      GridSpace m2sp(N2);
#endif

      StdProductSpace<float> msp(m1sp,m2sp);
      Vector<float> x(msp);
      Components<float> cm(x);
   
      /* make SEGY space and vector */
#ifdef IWAVE_USE_MPI
      MPISEGYSpace tsp(hdrname);
#else
      SEGYSpace tsp(hdrname);
#endif
    
      Vector<float> dy(tsp);

      /* assign files */
      AssignFilename m1fn(N1);
      AssignFilename m2fn(N2);
  
      cm[0].eval(m1fn);
      cm[1].eval(m2fn);

      /*-----------------------------------*/
      // either spec a window grid, or use the bulk mod grid (no windowing)
      string wgn = "";
      if (!parse<string>(*pars,"window_grid",wgn)) wgn=N1;
      float ww=0.0f;
      parse<float>(*pars,"window_width",ww);

      // makes no diff that grid will not have correct data_type
      // tag, as this is not used in window ops
      Grid<float> wgrid;
      wgrid.readFile(wgn);

      GridWindowOp<float> wop(x,wgrid,ww);
	  
      /* create operator, evaluate, copy results to output */
      IWaveOp<
      ASGSamplerPolicy,
	ASGLinSamplerPolicy,
	ASGAdjSamplerPolicy,
	StdIWavePolicy,
	StdRCIWavePolicy,
	LinSimPolicy,
	FwdCPSimPolicy,
	AdjSimPolicy
	> 
	iwop(msp,tsp,*pars,stream,asg_gfdm);

      float s=0.0f;
      float w=0.0f;
      float tm=0.0f;
      parse<float>(*pars,"mute_slope",s);
      parse<float>(*pars,"mute_zotime",tm);
      parse<float>(*pars,"mute_width",w);
      SEGYLinMute mute(s,tm,w);
      LinearOpFO<float> mop(tsp,tsp,mute,mute);
      //	op.setNext(mop);

      // create composite operator
      OpComp<float> op(wop, iwop, mop);

      Vector<float> x0(op.getDomain());
      x0.zero();
      
      OperatorEvaluation<float> opeval(op,x0);

      RVLRandomize<float> rnd(getpid(),-1.0f, 1.0f);

      std::stringstream res;
      AdjointTest(opeval.getDeriv(),rnd,res);
      if (retrieveRank() == 0) {
	if (outfile.size()>0) {
	  ofstream outf(outfile.c_str());
	  outf<<res.str();
	  outf.close();
	}
	else {
	  cout<<res.str();
	}
      }

      iwave_fdestroy();

#ifdef IWAVE_USE_MPI
    }
    // make every process wait until the active ones are
    // completed
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
    return 0;
#endif  
  }
  catch (RVLException & e) {
    e<<"asgadjtest.x: ABORT\n";
    e.write(cerr);
#ifdef IWAVE_USE_MPI
    MPI_Abort(MPI_COMM_WORLD,0);
#endif
    exit(1);
  }
}
