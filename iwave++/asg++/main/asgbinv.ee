/** \file asginv.cc
 * Driver for least-squares waveform inversion 
 * 
 * Usage: 
 *        ./asginv.x par=test.par
 *
 * accormodates both standard and extended inversion modes
 *  
 * \author William W. Symes and Dong Sun   
 * May, 2011
 */
/*================================================================================*/

#include "asginv_selfdoc.hh"
#include "asg_gfdm.h"
#include "asg_sampler.hh"
#include "seamx_headers.hh"
#include "iwop.hh"
#include "state.hh"
#include "samp.hh"
#include "ls.hh"
#include "blockop.hh"
#include "sim.hh"
#include "pol.hh"

#include "CPsim.hh"

#ifdef IWAVE_USE_MPI
#include "mpisegypp.hh"
#include "mpigridpp.hh"
#else
#include "segypp.hh"
#include "gridpp.hh"
#endif
#include "segyops.hh"
#include "gridops.hh"

#include "LBFGSBT.hh"

using namespace RVLUmin;
using namespace RVLAlg;
using namespace TSOpt;
using namespace RVL;

namespace ASG {

  /* Sampler Policies */
  /** FwdSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveState,ASGSampler> ASGSamplerPolicy;
  /** LinSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGLinSampler> ASGLinSamplerPolicy;
  /** AdjSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGAdjSampler> ASGAdjSamplerPolicy;
 
  /* Sim Policies */  
  /** FwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdSim<IWaveState> > StdIWavePolicy;
  /** LinFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdRCSim<IWaveState> > StdRCIWavePolicy; 
  /** AdjFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, CPSim<IWaveState,TSIndex> > FwdCPSimPolicy;
  /** LinSimPolicy and AdjSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > LinSimPolicy;
 
 //typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > AdjSimPolicy;
   
  /* dummy sim policies to fill in the rest of the list */
  //class LinFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  //class LinSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};
  //class AdjFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  class AdjSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};

} 

void paramreader(PARARRAY pars, 
		 string const & key, 
		 string & val, 
		 bool warn,
		 FILE * stream) {
  try {
    char * cbuf = NULL;
    ps_ffcstring(pars,key.c_str(),&cbuf);
    if (!cbuf) {
      if (warn) {
	fprintf(stream,"NOTE: failed to read value for key = %s\n",key.c_str());
	fprintf(stream,"NOTE: returning empty value string\n");
	val="";
      }
      else {
	RVLException e;
	e<<"Error: asgfwd\n";
	e<<"failed to extract value for key="<<key<<" from param table\n";
	throw e;
      }
    }
    else {
      val=cbuf;
      free(cbuf);
      cbuf=NULL;
    }
  }
  catch (RVLException & e) {
    e<<"\ncalled from paramreader\n";
    throw e;
  }
}

int main(int argc, char ** argv) {
  xargc=argc;
  xargv=argv;

  using namespace ASG;
  try { 

    if (argc<2) { 
      RVLException e;
      e<<"asginv: least squares inversion\n";
      e<<"usage: asginv.x par=<par file>\n";
      throw e;
    }

    int rk = 0;

    /* set up execution environment */
    int ts=0;
#ifdef IWAVE_USE_MPI
    MPI_Init_thread(&argc,&argv,MPI_THREAD_FUNNELED,&ts);
#endif

    PARARRAY * pars = NULL;
    FILE * stream = NULL;
    IWaveEnvironment(argc,argv,ts,&pars,&stream);
      
#ifdef IWAVE_USE_MPI
    if (retrieveGroupID() == MPI_UNDEFINED) {
      fprintf(stream,"NOTE: finalize MPI, cleanup, exit\n");
    }
    else {
      rk = retrieveGlobalRank();
#endif
      if (rk==0) requestdoc(1);

      /////////////////////////////////////////////////////
      //                     INPUT                       //
      /////////////////////////////////////////////////////
      
      /* file reading section - basic inputs */

      //main input and output data files

      // inversion log - optional
      string invlogfn = "";
      paramreader(*pars,"inv_logfile",invlogfn,true,stream);

      // optimization parameters - mandatory
      string uminparname;
      paramreader(*pars,"uminpar",uminparname,false,stream);

      // initial model - mandatory
      string initbulkname;
      string initbuoyname;
      paramreader(*pars,"init_bulkmod",initbulkname,false,stream);
      paramreader(*pars,"init_buoyancy",initbuoyname,false,stream);

      // final model
      string finalbulkname;
      paramreader(*pars,"final_bulkmod",finalbulkname,false,stream);

      // input data file
      string dataname;
      paramreader(*pars,"datafile",dataname,false,stream);

      // inversion window parameters
      string wgn;
      paramreader(*pars,"window_grid",wgn,false,stream);
      float ww=0.0f;
      parse<float>(*pars,"window_width",ww);      
	
      /* file reading section - upper and lower bounds
	 first try to read filename
	 if that fails, try to read const value for bound
	 if both fail throw exception 
	 key pattern:
	 for file, key = [b]_[param name]
	 for const, key = [filename]_val
	 here [b]     = ub or lb
	 [n]     = 1  or 2
	 [param_name] = M[n]   
	 
      */
      
      int NPAR = 1;

      std::vector<string> b(2);
      b[0]="lb_";
      b[1]="ub_";
      //      std::vector<string> p(NPAR);
      std::vector<string> p(1);
      p[0]="bulk";

      std::vector<string> bfn(2);
      std::vector<float> bv(2);
    
      for (int ib=0; ib<2; ib++) {
	for (int ip=0; ip<NPAR; ip++) {
	  bfn[ip+2*ib]="";
	  // try to read file name
	  paramreader(*pars,b[ib]+p[ip],bfn[ip+2*ib],true,stream);
	  // if no file, read value
	  if (bfn[ip+2*ib].size()==0) {
	    if (ps_fffloat(*pars,(b[ib]+p[ip]+"_val").c_str(),&(bv[ip+NPAR*ib]))) {
	      RVLException e;
	      e<<"Error: asgfwd\n";
	      e<<"failed to extract values for keys "<<b[ib]+p[ip]+"_val"
	       <<" and "<<b[ib]+p[ip]<<" from param table\n";
	      throw e;
	    }
	  }
	}
      }

      /* mute option */

      float s=0.0f;
      float w=0.0f;
      float tm=0.0f;
      parse<float>(*pars,"mute_slope",s);
      parse<float>(*pars,"mute_zotime",tm);
      parse<float>(*pars,"mute_width",w);

      /////////////////////////////////////////////////////
      //              PREPROCESSING                      //
      /////////////////////////////////////////////////////
      
      /************ SPACES, VECTORS *****************/
      
#ifdef IWAVE_USE_MPI
      MPIGridSpace m1sp(initbulkname);
      MPIGridSpace m2sp(initbuoyname);
#else
      GridSpace m1sp(initbulkname);
      GridSpace m2sp(initbuoyname);
#endif
      StdProductSpace<float> msp(m1sp,m2sp);    
      
      //x0 stores initial model 
      Vector<float> x0(msp); 
      Components<float> cx0(x0);
      
      /* make SEGY space and vector */
#ifdef IWAVE_USE_MPI
      MPISEGYSpace tsp(dataname);
#else
      SEGYSpace tsp(dataname);
#endif
      // y stores data;
      Vector<float> y(tsp);
      
      /* assign model, data files */
      AssignFilename m1fn(initbulkname);
      AssignFilename m2fn(initbuoyname);
      cx0[0].eval(m1fn);
      cx0[1].eval(m2fn);
      AssignFilename tfn(dataname);
      y.eval(tfn);
      
      /***************** OPERATORS ******************/ 
      /* composite simulation operator, evaluation vector -
         zero if affine window, input model else */
      /* window option */
      
      InjectOp<float> inj(x0,0);
      
      /* simulator */
      IWaveOp<
      ASGSamplerPolicy,
	ASGLinSamplerPolicy,
	ASGAdjSamplerPolicy,
	StdIWavePolicy,
	StdRCIWavePolicy,
	LinSimPolicy,
	FwdCPSimPolicy,
	AdjSimPolicy
	> 
	iwop(msp,tsp,*pars,stream,asg_gfdm);

      SEGYLinMute mute(s,tm,w);
      LinearOpFO<float> mop(tsp,tsp,mute,mute);

      OpComp<float> op(inj,iwop,mop);

      /* load bound vectors - cannot do this until op is defined */
      Vector<float> ub(op.getDomain());
      Vector<float> lb(op.getDomain());
      Components<float> cub(ub);
      Components<float> clb(lb);
      
      for (int ip=0;ip<NPAR;ip++) {
	// lower bounds
	if (bfn[ip].size()) {
	  AssignFilename af(bfn[ip]);
	  clb[ip].eval(af);
	}
	else {
	  RVLAssignConst<float> ac(bv[ip]);
	  clb[ip].eval(ac);
	}
	
	// upper bounds
	if (bfn[ip+NPAR].size()) {
	  AssignFilename af(bfn[ip+NPAR]);
	  cub[ip].eval(af);
	}
	else {
	  RVLAssignConst<float> ac(bv[ip+NPAR]);
	  cub[ip].eval(ac);
	}
      }

      StdLeastSquaresFcnlGN<ireal> fls(op,y);

      RVLMin<float> mn;
#ifdef IWAVE_USE_MPI
      MPISerialFunctionObjectRedn<float,float> mpimn(mn);
      ULBoundsTest<float> ultest(lb,ub,mpimn);
#else
      ULBoundsTest<float> ultest(lb,ub,mn);
#endif
   
      FunctionalBd<float> fbd(fls,ultest);

      // finally, tack on window at front. There is no choice
      // here: a window operator is mandatory!

      Grid<float> wgrid;
      wgrid.readFile(wgn);
      GridWindowOp<float> wop(cx0[0],wgrid,ww);
	
      // build final operator
      FcnlOpComp<ireal> f(fbd,wop);
      //      f.write(cerr);
    
      /////////////////////////////////////////////////////
      //                OPTIMIZATION                     //
      /////////////////////////////////////////////////////
      
      // create solution vector, windowed/shifted to initial zero
      Vector<ireal> x(f.getDomain());
      x.zero();

      Table uminpar(uminparname);

      Algorithm * umin;
      
      // if no log file specified, junk output by default
      if (invlogfn.size()<1 || rk > 0) 
	invlogfn = "/dev/null";
      ofstream invlogstream(invlogfn.c_str());

      if (rk==0 && invlogfn=="/dev/null") {
	cout<<"---- LS inversion, building LBFGSBT object -----------"<<endl;	
	umin = new LBFGSBT<ireal>(f,x,uminpar,cout);
	  cout<<"----LS inversion, starts --------------"<<endl;
      }
      else {
	invlogstream<<"---- LS inversion, building LBFGSBT object -----------"<<endl;	
	umin = new LBFGSBT<ireal>(f,x,uminpar,invlogstream);
	invlogstream<<"----LS inversion, starts --------------"<<endl;
      }
    
      umin->run();

      if (rk==0 && invlogfn=="/dev/null") 
	cout<<"----LS inversion, ended --------------"<<endl;
      else 
	invlogstream<<"----LS inversion, ended --------------"<<endl;
      
      delete umin;
      
      /****************************************************
       *                    OUTPUT                        *
       ****************************************************/
      
      Vector<ireal> xf(wop.getRange());

      AssignFilename bminv(finalbulkname);
      xf.eval(bminv);

      OperatorEvaluation<ireal> wopeval(wop,x);
      xf.copy(wopeval.getValue());

      iwave_fdestroy();
#ifdef IWAVE_USE_MPI
    } /* end nontriv comm branch */
    
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
#endif
  }
  catch (RVLException & e) {
    e<<"asginv.x: ABORT\n";
    e.write(cerr);
#ifdef IWAVE_USE_MPI
    MPI_Abort(MPI_COMM_WORLD,0);
#endif
    exit(1);
  }
}
