/** \file asginv.cc
 * Driver for least-squares waveform inversion 
 * 
 * Usage: 
 *        ./asginv.x par=test.par
 *
 * accormodates both standard and extended inversion modes
 *  
 * \author William W. Symes and Dong Sun   
 * May, 2011
 */
/*================================================================================*/

#include "asginv_selfdoc.hh"
#include "asg_gfdm.h"
#include "asg_sampler.hh"
#include "seamx_headers.hh"
#include "iwop.hh"
#include "state.hh"
#include "samp.hh"
#include "ls.hh"
#include "blockop.hh"
#include "sim.hh"
#include "CPsim.hh"

#ifdef IWAVE_USE_MPI
#include "mpisegypp.hh"
#include "mpigridpp.hh"
#else
#include "segypp.hh"
#include "gridpp.hh"
#endif
#include "segyops.hh"
#include "gridops.hh"

#include "LBFGSBT.hh"

using namespace RVLUmin;
using namespace RVLAlg;
using namespace TSOpt;
using namespace RVL;

namespace ASG {

  /* Sampler Policies */
  /** FwdSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveState,ASGSampler> ASGSamplerPolicy;
  /** LinSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGLinSampler> ASGLinSamplerPolicy;
  /** AdjSamplerPolicy */
  typedef OpNewCreatePolicy<IWaveLinState,ASGAdjSampler> ASGAdjSamplerPolicy;
 
  /* Sim Policies */  
  /** FwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdSim<IWaveState> > StdIWavePolicy;
  /** LinFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, StdRCSim<IWaveState> > StdRCIWavePolicy; 
  /** AdjFwdSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveState>, CPSim<IWaveState,TSIndex> > FwdCPSimPolicy;
  /** LinSimPolicy and AdjSimPolicy */
  typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > LinSimPolicy;
 
 //typedef OpNewCreatePolicy<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > AdjSimPolicy;
   
  /* dummy sim policies to fill in the rest of the list */
  //class LinFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  //class LinSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};
  //class AdjFwdSimPolicy: public PolicyBase<StdSimData<IWaveState>, StdSim<IWaveState> > {};
  class AdjSimPolicy: public PolicyBase<StdSimData<IWaveLinState>, StdSim<IWaveLinState> > {};

} 

void paramreader(PARARRAY pars, 
		 string const & key, 
		 string & val, 
		 bool warn,
		 FILE * stream) {
  try {
    if (!parse<string>(pars,key,val)) {
      if (warn) {
	fprintf(stream,"NOTE: failed to read value for key = %s\n",key.c_str());
	fprintf(stream,"NOTE: returning empty value string\n");
	val="";
      }
      else {
	RVLException e;
	e<<"Error: asgfwd\n";
	e<<"failed to extract value for key="<<key<<" from param table\n";
	throw e;
      }
    }
  }
  catch (RVLException & e) {
    e<<"\ncalled from paramreader\n";
    throw e;
  }
}

int main(int argc, char ** argv) {
  xargc=argc;
  xargv=argv;

  using namespace ASG;
  try { 
    /*
    if (argc<2) { 
      RVLException e;
      e<<"asginv: least squares inversion\n";
      e<<"usage: asginv.x par=<par file>\n";
      throw e;
    }
    */

    int rk = 0;

    /* set up execution environment */
    int ts=0;
#ifdef IWAVE_USE_MPI
    MPI_Init_thread(&argc,&argv,MPI_THREAD_FUNNELED,&ts);
#endif

    PARARRAY * pars = NULL;
    FILE * stream = NULL;
    IWaveEnvironment(argc,argv,ts,&pars,&stream);

#ifdef IWAVE_USE_MPI
    if (retrieveGroupID() == MPI_UNDEFINED) {
      fprintf(stream,"NOTE: finalize MPI, cleanup, exit\n");
    }
    else {
      rk = retrieveGlobalRank();
#endif
      if (rk==0) requestdoc(1);

      /////////////////////////////////////////////////////
      //           PARAMETER EXTRACTION                  //
      /////////////////////////////////////////////////////      
      
      // inversion log - optional
      string invlogfn = "";
      paramreader(*pars,"inv_logfile",invlogfn,true,stream);
      cerr<<"1\n";

      // optimization parameters - mandatory
      string uminparname;
      paramreader(*pars,"uminpar",uminparname,false,stream);

      // initial model - mandatory
      string initbulkname;
      string initbuoyname;
      paramreader(*pars,"init_bulkmod",initbulkname,false,stream);
      paramreader(*pars,"init_buoyancy",initbuoyname,false,stream);

      // final model
      string finalbulkname;
      paramreader(*pars,"final_bulkmod",finalbulkname,false,stream);

      // input data file
      string dataname;
      paramreader(*pars,"datafile",dataname,false,stream);

      // inversion window parameters
      string wgn;
      paramreader(*pars,"window_grid",wgn,false,stream);
      float ww=0.0f;
      parse<float>(*pars,"window_width",ww);      

      // bounds
      float cmin;
      float cmax;
      float dmin;
      float dmax;
      if (!(parse<float>(*pars,"cmin",cmin)) ||
	  !(parse<float>(*pars,"cmax",cmax)) ||
	  !(parse<float>(*pars,"dmin",dmin)) ||
	  !(parse<float>(*pars,"dmax",dmax))) {
	RVLException e;
	e<<"ERROR: asgbinvslog\n";
	e<<"failed to read bounds on velo, density\n";
	throw e;
      }
      float lb=dmin*cmin*cmin;
      float ub=dmax*cmax*cmax;

      /* mute parameters */

      float s=0.0f;
      float w=0.0f;
      float tm=0.0f;
      parse<float>(*pars,"mute_slope",s);
      parse<float>(*pars,"mute_zotime",tm);
      parse<float>(*pars,"mute_width",w);

      /////////////////////////////////////////////////////
      //            SPACES, VECTORS                      //
      /////////////////////////////////////////////////////
      
#ifdef IWAVE_USE_MPI
      MPIGridSpace m1sp(initbulkname);
      MPIGridSpace m2sp(initbuoyname);
#else
      GridSpace m1sp(initbulkname);
      GridSpace m2sp(initbuoyname);
#endif
      StdProductSpace<float> msp(m1sp,m2sp);    
      
      //x0 stores initial model 
      Vector<float> x0(msp); 
      Components<float> cx0(x0);
      
      /* make SEGY space and vector */
#ifdef IWAVE_USE_MPI
      MPISEGYSpace tsp(dataname);
#else
      SEGYSpace tsp(dataname);
#endif
      // y stores data;
      Vector<float> y(tsp);
      
      /* assign model, data files */
      AssignFilename m1fn(initbulkname);
      AssignFilename m2fn(initbuoyname);
      cx0[0].eval(m1fn);
      cx0[1].eval(m2fn);
      AssignFilename tfn(dataname);
      y.eval(tfn);
      
      /////////////////////////////////////////////////////
      //                   OPERATORS                     //
      /////////////////////////////////////////////////////
      
      /* simulator */
      IWaveOp<
	ASGSamplerPolicy,
	ASGLinSamplerPolicy,
	ASGAdjSamplerPolicy,
	StdIWavePolicy,
	StdRCIWavePolicy,
	LinSimPolicy,
	FwdCPSimPolicy,
	AdjSimPolicy
	> 
	iwop(msp,tsp,*pars,stream,asg_gfdm);

      /* linear mute */
      SEGYLinMute mute(s,tm,w);
      LinearOpFO<float> mop(tsp,tsp,mute,mute);

      /* logistic function */
      RVLScalarLogistic<float> logfun(lb,ub);
      RVLScalarLogisticDeriv<float> dlogfun(lb,ub);
      RVLScalarLogisticInverse<float> ilogfun(lb,ub);
      OpFO<float> lop(m1sp,m1sp,logfun,dlogfun,dlogfun);

      /* composite simulation operator, evaluation vector -
         zero if affine window, input model else */
      Vector<float> x0log(m1sp);
      x0log.eval(ilogfun,cx0[0]);

      // finally, tack on window at front. There is no choice
      // here: a window operator is mandatory!
      Grid<float> wgrid;
      wgrid.readFile(wgn);
      GridWindowOp<float> wop(x0log,wgrid,ww);
	
      // injection operator - tacks on fixed buoyancy
      InjectOp<float> inj(x0,0);

      // put them all together into the modeling op
      OpComp<float> op(wop,lop,inj,iwop,mop);

      // build least squares fcnl
      StdLeastSquaresFcnlGN<ireal> f(op,y);
    
      /////////////////////////////////////////////////////
      //                OPTIMIZATION                     //
      /////////////////////////////////////////////////////
      
      // create solution vector, windowed/shifted to initial zero
      Vector<ireal> x(f.getDomain());
      x.zero();

      Table uminpar(uminparname);

      // if no log file specified, junk output by default
      if (invlogfn.size()<1 || rk > 0) 
	invlogfn = "/dev/null";
      ofstream invlogstream(invlogfn.c_str());

      if (rk==0 && invlogfn=="/dev/null") 
	cout<<"---- LS inversion, building LBFGSBT object -----------"<<endl;	
      else 
	invlogstream<<"---- LS inversion, building LBFGSBT object -----------"<<endl;	

      stringstream res;
      LBFGSBT<float> umin(f,x,uminpar,invlogstream);

      if (rk==0 && invlogfn=="/dev/null") 
	cout<<"---- LS inversion, starts --------------"<<endl;
      else 
	invlogstream<<"----LS inversion, starts --------------"<<endl;
    
      umin.run();

      if (rk==0 && invlogfn=="/dev/null") {
	cout<<"----LS inversion, ended --------------"<<endl;
	cout<<res;
      }
      else {
	invlogstream<<"----LS inversion, ended --------------"<<endl;
	invlogstream<<res;
      }

      Vector<ireal> xf(m1sp);

      OperatorEvaluation<ireal> wopeval(wop,x);
      OperatorEvaluation<ireal> lopeval(lop,wopeval.getValue());
      AssignFilename bminv(finalbulkname);
      xf.eval(bminv);
      xf.copy(lopeval.getValue());

      iwave_fdestroy();
#ifdef IWAVE_USE_MPI
    } /* end nontriv comm branch */
    
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
#endif
  }
  catch (RVLException & e) {
    e<<"asgbinvslog.x: ABORT\n";
    e.write(cerr);
#ifdef IWAVE_USE_MPI
    MPI_Abort(MPI_COMM_WORLD,0);
#endif
    exit(1);
  }
}
